<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl::control::OpenDEStateSpace Class Reference</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <link href="css/tabs.css" rel="stylesheet">
  <link href="css/doxygen.css" rel="stylesheet">
  <link href="css/search.css" rel="stylesheet">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="css/ompl.css" rel="stylesheet">
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="search/searchdata.js"></script>
  <script src="search/search.js"></script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="benchmark.html">Benchmarking</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
          <!-- Doxygen API search box -->
          <div id="searchli">
            <div id="MSearchBox" class="MSearchBoxInactive">
              <span class="left">
                <img id="MSearchSelect" src="search/mag_sel.png"
                onmouseover="return searchBox.OnSearchSelectShow()"
                onmouseout="return searchBox.OnSearchSelectHide()"
                alt=""/>
                <input type="text" id="MSearchField" value="Search API" accesskey="S"
                onfocus="searchBox.OnSearchFieldFocus(true)"
                onblur="searchBox.OnSearchFieldFocus(false)"
                onkeyup="searchBox.OnSearchFieldChange(event)"/>
              </span><span class="right">
                <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
              </span>
            </div>
          </div>
        </ul>
      </div>
    </div>
  </nav>
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"
  onmouseover="return searchBox.OnSearchSelectShow()"
  onmouseout="return searchBox.OnSearchSelectHide()"
  onkeydown="return searchBox.OnSearchSelectKey(event)">
  <a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="" frameborder="0"name="MSearchResults" id="MSearchResults"></iframe>
  </div>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceompl.html">ompl</a></li><li class="navelem"><a class="el" href="namespaceompl_1_1control.html">control</a></li><li class="navelem"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html">OpenDEStateSpace</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classompl_1_1control_1_1OpenDEStateSpace-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ompl::control::OpenDEStateSpace Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>State space representing OpenDE states.  
 <a href="classompl_1_1control_1_1OpenDEStateSpace.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OpenDEStateSpace_8h_source.html">ompl/extensions/opende/OpenDEStateSpace.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ompl::control::OpenDEStateSpace:</div>
<div class="dyncontent">
<div class="center"><img src="classompl_1_1control_1_1OpenDEStateSpace__inherit__graph.png" border="0" usemap="#ompl_1_1control_1_1OpenDEStateSpace_inherit__map" alt="Inheritance graph"/></div>
<map name="ompl_1_1control_1_1OpenDEStateSpace_inherit__map" id="ompl_1_1control_1_1OpenDEStateSpace_inherit__map">
<area shape="rect" id="node2" href="classompl_1_1base_1_1CompoundStateSpace.html" title="A space to allow the composition of state spaces. " alt="" coords="5,155,196,196"/><area shape="rect" id="node3" href="classompl_1_1base_1_1StateSpace.html" title="Representation of a space in which planning can be performed. Topology specific sampling, interpolation and distance are defined. " alt="" coords="19,80,183,107"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html">StateType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenDE State. This is a compound state that allows accessing the properties of the bodies the state space is constructed for.  <a href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2952bf8638854bd1e33e597713f13b29"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29aaaaf494d5dcb4ad2a2dfa118bb928cc6">STATE_COLLISION_KNOWN_BIT</a> = 0, 
<a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29a4aad4bf4c984a0a54251c6326ebc342b">STATE_COLLISION_VALUE_BIT</a> = 1, 
<a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29a5218d6e48f2d205c2adeb1c62a836f0c">STATE_VALIDITY_KNOWN_BIT</a> = 2, 
<a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29a217e97a10f0ed7704d9a9123c39d9047">STATE_VALIDITY_VALUE_BIT</a> = 3
 }</td></tr>
<tr class="separator:a2952bf8638854bd1e33e597713f13b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classompl_1_1base_1_1CompoundStateSpace"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classompl_1_1base_1_1CompoundStateSpace')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html">ompl::base::CompoundStateSpace</a></td></tr>
<tr class="memitem:af12997f7c56f7263fb78be7444b838e5 inherit pub_types_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af12997f7c56f7263fb78be7444b838e5"></a>
typedef <a class="el" href="classompl_1_1base_1_1CompoundState.html">CompoundState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#af12997f7c56f7263fb78be7444b838e5">StateType</a></td></tr>
<tr class="memdesc:af12997f7c56f7263fb78be7444b838e5 inherit pub_types_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the type of state allocated by this state space. <br /></td></tr>
<tr class="separator:af12997f7c56f7263fb78be7444b838e5 inherit pub_types_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classompl_1_1base_1_1StateSpace"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classompl_1_1base_1_1StateSpace')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classompl_1_1base_1_1StateSpace.html">ompl::base::StateSpace</a></td></tr>
<tr class="memitem:a64feddc33bb3b7459c4f589e6cd9d17e inherit pub_types_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17e">SanityChecks</a> { <br />
&#160;&#160;<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea044307209c21e4830272ca52945a3062">STATESPACE_DISTANCE_DIFFERENT_STATES</a> = (1&lt;&lt;1), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea5acf49ce656838100e44ed7ee7321ab6">STATESPACE_DISTANCE_SYMMETRIC</a> = (1&lt;&lt;2), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea26a108232d6265a1cc8bcc642216a6cf">STATESPACE_INTERPOLATION</a> = (1&lt;&lt;3), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea54e30ec7ef77f42f255951ac6be08f97">STATESPACE_TRIANGLE_INEQUALITY</a> = (1&lt;&lt;4), 
<br />
&#160;&#160;<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea0134f2a38473e775c3037fde1c336d3f">STATESPACE_DISTANCE_BOUND</a> = (1&lt;&lt;5), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea3c050038b3403113c40e3485398a9b18">STATESPACE_RESPECT_BOUNDS</a> = (1&lt;&lt;6), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17eafb4e9823a65ace5477bcc1cfc267b3fc">STATESPACE_ENFORCE_BOUNDS_NO_OP</a> = (1&lt;&lt;7), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea88b4708168876d0b1b010e40285c1cc1">STATESPACE_SERIALIZATION</a> = (1&lt;&lt;8)
<br />
 }</td></tr>
<tr class="memdesc:a64feddc33bb3b7459c4f589e6cd9d17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to use in a bit mask for state space sanity checks. Some basic checks do not have flags associated (they are always executed; for example, whether <a class="el" href="classompl_1_1base_1_1StateSpace.html#abff3478c3fc4da03c94d6f929f6ca7f9" title="Copy a state to another. The memory of source and destination should NOT overlap. ...">copyState()</a> works as expected)  <a href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17e">More...</a><br /></td></tr>
<tr class="separator:a64feddc33bb3b7459c4f589e6cd9d17e inherit pub_types_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa995357fedb73879bc7f0bb946db76d1 inherit pub_types_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa995357fedb73879bc7f0bb946db76d1"></a>
typedef <a class="el" href="classompl_1_1base_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa995357fedb73879bc7f0bb946db76d1">StateType</a></td></tr>
<tr class="memdesc:aa995357fedb73879bc7f0bb946db76d1 inherit pub_types_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the type of state allocated by this space. <br /></td></tr>
<tr class="separator:aa995357fedb73879bc7f0bb946db76d1 inherit pub_types_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac84bc49ad1ee3dd74720defe1d68c3d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#ac84bc49ad1ee3dd74720defe1d68c3d6">OpenDEStateSpace</a> (const <a class="el" href="classompl_1_1control_1_1OpenDEEnvironmentPtr.html">OpenDEEnvironmentPtr</a> &amp;env, double positionWeight=1.0, double linVelWeight=0.5, double angVelWeight=0.5, double orientationWeight=1.0)</td></tr>
<tr class="memdesc:ac84bc49ad1ee3dd74720defe1d68c3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a state space representing OpenDE states.  <a href="#ac84bc49ad1ee3dd74720defe1d68c3d6">More...</a><br /></td></tr>
<tr class="separator:ac84bc49ad1ee3dd74720defe1d68c3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c91522a2a5fa6ce41a51ba5a465692"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c91522a2a5fa6ce41a51ba5a465692"></a>
const <a class="el" href="classompl_1_1control_1_1OpenDEEnvironmentPtr.html">OpenDEEnvironmentPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a70c91522a2a5fa6ce41a51ba5a465692">getEnvironment</a> () const </td></tr>
<tr class="memdesc:a70c91522a2a5fa6ce41a51ba5a465692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the OpenDE environment this state space corresponds to. <br /></td></tr>
<tr class="separator:a70c91522a2a5fa6ce41a51ba5a465692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c027b8569663b6a76090b24764ed441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c027b8569663b6a76090b24764ed441"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a3c027b8569663b6a76090b24764ed441">getNrBodies</a> () const </td></tr>
<tr class="memdesc:a3c027b8569663b6a76090b24764ed441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bodies state is maintained for. <br /></td></tr>
<tr class="separator:a3c027b8569663b6a76090b24764ed441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508a49bf7883600347f7cdcae4665897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a508a49bf7883600347f7cdcae4665897"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a508a49bf7883600347f7cdcae4665897">setDefaultBounds</a> ()</td></tr>
<tr class="memdesc:a508a49bf7883600347f7cdcae4665897"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, the volume bounds enclosing the geometry of the environment are computed to include all objects in the spaces collision checking is performed (env.collisionSpaces_). The linear and angular velocity bounds are set as -1 to 1 for each dimension. <br /></td></tr>
<tr class="separator:a508a49bf7883600347f7cdcae4665897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d274f8765e67c330abd2006d5f659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f7d274f8765e67c330abd2006d5f659"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a7f7d274f8765e67c330abd2006d5f659">setVolumeBounds</a> (const <a class="el" href="classompl_1_1base_1_1RealVectorBounds.html">base::RealVectorBounds</a> &amp;bounds)</td></tr>
<tr class="memdesc:a7f7d274f8765e67c330abd2006d5f659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounds for each of the position subspaces. <br /></td></tr>
<tr class="separator:a7f7d274f8765e67c330abd2006d5f659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af921c16e942950ea704d4bfecf7442c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af921c16e942950ea704d4bfecf7442c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#af921c16e942950ea704d4bfecf7442c3">setLinearVelocityBounds</a> (const <a class="el" href="classompl_1_1base_1_1RealVectorBounds.html">base::RealVectorBounds</a> &amp;bounds)</td></tr>
<tr class="memdesc:af921c16e942950ea704d4bfecf7442c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounds for each of the linear velocity subspaces. <br /></td></tr>
<tr class="separator:af921c16e942950ea704d4bfecf7442c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d2f60bcad6893be7669efe16e4fc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab82d2f60bcad6893be7669efe16e4fc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#ab82d2f60bcad6893be7669efe16e4fc7">setAngularVelocityBounds</a> (const <a class="el" href="classompl_1_1base_1_1RealVectorBounds.html">base::RealVectorBounds</a> &amp;bounds)</td></tr>
<tr class="memdesc:ab82d2f60bcad6893be7669efe16e4fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounds for each of the angular velocity subspaces. <br /></td></tr>
<tr class="separator:ab82d2f60bcad6893be7669efe16e4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f6ab5f6a465fa3a0f6c5b6f2061663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f6ab5f6a465fa3a0f6c5b6f2061663"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a46f6ab5f6a465fa3a0f6c5b6f2061663">readState</a> (<a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *state) const </td></tr>
<tr class="memdesc:a46f6ab5f6a465fa3a0f6c5b6f2061663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the parameters of the OpenDE bodies and store them in <em>state</em>. <br /></td></tr>
<tr class="separator:a46f6ab5f6a465fa3a0f6c5b6f2061663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b6de682ded3e9095f15da757f2e79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44b6de682ded3e9095f15da757f2e79b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a44b6de682ded3e9095f15da757f2e79b">writeState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *state) const </td></tr>
<tr class="memdesc:a44b6de682ded3e9095f15da757f2e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parameters of the OpenDE bodies to be the ones read from <em>state</em>. The code will technically work if this function is called from multiple threads simultaneously, but the results are unpredictable. <br /></td></tr>
<tr class="separator:a44b6de682ded3e9095f15da757f2e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb2b3635829f5a07825a7e242ec5b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9eb2b3635829f5a07825a7e242ec5b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#aa9eb2b3635829f5a07825a7e242ec5b9">satisfiesBoundsExceptRotation</a> (const <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html">StateType</a> *state) const </td></tr>
<tr class="memdesc:aa9eb2b3635829f5a07825a7e242ec5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a convenience function provided for optimization purposes. It checks whether a state satisfies its bounds. Typically, in the process of simulation the rotations remain valid (very slightly out of bounds), so there is no point in updating or checking them. This function checks all other bounds (position, linear and agular velocities) <br /></td></tr>
<tr class="separator:aa9eb2b3635829f5a07825a7e242ec5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fde2b042b3a6106c07ddc65b3d1005"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8fde2b042b3a6106c07ddc65b3d1005"></a>
virtual <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#af8fde2b042b3a6106c07ddc65b3d1005">allocState</a> () const </td></tr>
<tr class="memdesc:af8fde2b042b3a6106c07ddc65b3d1005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a state that can store a point in the described space. <br /></td></tr>
<tr class="separator:af8fde2b042b3a6106c07ddc65b3d1005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6202811076c2e92b72f2298b74a96a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f6202811076c2e92b72f2298b74a96a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a0f6202811076c2e92b72f2298b74a96a">freeState</a> (<a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *state) const </td></tr>
<tr class="memdesc:a0f6202811076c2e92b72f2298b74a96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory of the allocated state. <br /></td></tr>
<tr class="separator:a0f6202811076c2e92b72f2298b74a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c83c791c78bf85d1422e37e1a3487c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a7c83c791c78bf85d1422e37e1a3487c1">copyState</a> (<a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *destination, const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *source) const </td></tr>
<tr class="memdesc:a7c83c791c78bf85d1422e37e1a3487c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a state to another. The memory of source and destination should NOT overlap.  <a href="#a7c83c791c78bf85d1422e37e1a3487c1">More...</a><br /></td></tr>
<tr class="separator:a7c83c791c78bf85d1422e37e1a3487c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995391c63557561e135535f525e53260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995391c63557561e135535f525e53260"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a995391c63557561e135535f525e53260">interpolate</a> (const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *from, const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *to, const double t, <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *state) const </td></tr>
<tr class="memdesc:a995391c63557561e135535f525e53260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the state that lies at time <em>t</em> in [0, 1] on the segment that connects <em>from</em> state to <em>to</em> state. The memory location of <em>state</em> is not required to be different from the memory of either <em>from</em> or <em>to</em>. <br /></td></tr>
<tr class="separator:a995391c63557561e135535f525e53260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b44ff1dd17119bf586a9baa6ddf389"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73b44ff1dd17119bf586a9baa6ddf389"></a>
virtual <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">base::StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a73b44ff1dd17119bf586a9baa6ddf389">allocDefaultStateSampler</a> () const </td></tr>
<tr class="memdesc:a73b44ff1dd17119bf586a9baa6ddf389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an instance of the default uniform state sampler for this space. <br /></td></tr>
<tr class="separator:a73b44ff1dd17119bf586a9baa6ddf389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3aa8c1a950a9ca22f2f30d0895a4b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b3aa8c1a950a9ca22f2f30d0895a4b6"></a>
virtual <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">base::StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a4b3aa8c1a950a9ca22f2f30d0895a4b6">allocStateSampler</a> () const </td></tr>
<tr class="memdesc:a4b3aa8c1a950a9ca22f2f30d0895a4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an instance of the state sampler for this space. This sampler will be allocated with the sampler allocator that was previously specified by <a class="el" href="classompl_1_1base_1_1StateSpace.html#aa88e8a85586b93866ef3b2a6fb31c114" title="Set the sampler allocator to use. ">setStateSamplerAllocator()</a> or, if no sampler allocator was specified, <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a73b44ff1dd17119bf586a9baa6ddf389" title="Allocate an instance of the default uniform state sampler for this space. ">allocDefaultStateSampler()</a> is called. <br /></td></tr>
<tr class="separator:a4b3aa8c1a950a9ca22f2f30d0895a4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5829ff58ba3e8949874809f773160c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c5829ff58ba3e8949874809f773160c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a7c5829ff58ba3e8949874809f773160c">evaluateCollision</a> (const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *source) const </td></tr>
<tr class="memdesc:a7c5829ff58ba3e8949874809f773160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29a4aad4bf4c984a0a54251c6326ebc342b" title="Index of bit in StateType::collision indicating whether a state is in collision or not...">OpenDEStateSpace::STATE_COLLISION_VALUE_BIT</a> of <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html#a4f1a462807534944ca791f1314a42fa8" title="Flag containing information about state validity. ">StateType::collision</a> member of a state, if unspecified. Return the value value of that bit. <br /></td></tr>
<tr class="separator:a7c5829ff58ba3e8949874809f773160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classompl_1_1base_1_1CompoundStateSpace')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html">ompl::base::CompoundStateSpace</a></td></tr>
<tr class="memitem:a2dcbcf1fac267248ea6ed756494414c8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dcbcf1fac267248ea6ed756494414c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a2dcbcf1fac267248ea6ed756494414c8">CompoundStateSpace</a> ()</td></tr>
<tr class="memdesc:a2dcbcf1fac267248ea6ed756494414c8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty compound state space. <br /></td></tr>
<tr class="separator:a2dcbcf1fac267248ea6ed756494414c8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813ec9cca9b410654350c8125892c5b2 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a813ec9cca9b410654350c8125892c5b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a813ec9cca9b410654350c8125892c5b2">CompoundStateSpace</a> (const std::vector&lt; <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &gt; &amp;components, const std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a813ec9cca9b410654350c8125892c5b2 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a compound state space from a list of subspaces (<em>components</em>) and their corresponding weights (<em>weights</em>) <br /></td></tr>
<tr class="separator:a813ec9cca9b410654350c8125892c5b2 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fab4400b17847818beeeefb7d897cc inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4fab4400b17847818beeeefb7d897cc inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ab4fab4400b17847818beeeefb7d897cc">as</a> (const unsigned int index) const </td></tr>
<tr class="memdesc:ab4fab4400b17847818beeeefb7d897cc inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a component of this instance to a desired type.  <a href="#ab4fab4400b17847818beeeefb7d897cc">More...</a><br /></td></tr>
<tr class="separator:ab4fab4400b17847818beeeefb7d897cc inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c7ce62071b8267607fa4bb3ccc5eb3 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87c7ce62071b8267607fa4bb3ccc5eb3 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a87c7ce62071b8267607fa4bb3ccc5eb3">as</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a87c7ce62071b8267607fa4bb3ccc5eb3 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a component of this instance to a desired type.  <a href="#a87c7ce62071b8267607fa4bb3ccc5eb3">More...</a><br /></td></tr>
<tr class="separator:a87c7ce62071b8267607fa4bb3ccc5eb3 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4263340b54a633505ba176a42c31e643 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4263340b54a633505ba176a42c31e643"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a4263340b54a633505ba176a42c31e643">isCompound</a> () const </td></tr>
<tr class="memdesc:a4263340b54a633505ba176a42c31e643 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the state space is compound. <br /></td></tr>
<tr class="separator:a4263340b54a633505ba176a42c31e643 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88de9632ea8bf11318916c79450df1a9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88de9632ea8bf11318916c79450df1a9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a88de9632ea8bf11318916c79450df1a9">isHybrid</a> () const </td></tr>
<tr class="memdesc:a88de9632ea8bf11318916c79450df1a9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is a hybrid state space (i.e., both discrete and continuous components exist) <br /></td></tr>
<tr class="separator:a88de9632ea8bf11318916c79450df1a9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba02f1cf2c9b0f885fb7331ef2c4a8f6 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba02f1cf2c9b0f885fb7331ef2c4a8f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#aba02f1cf2c9b0f885fb7331ef2c4a8f6">printState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aba02f1cf2c9b0f885fb7331ef2c4a8f6 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a state to a stream. <br /></td></tr>
<tr class="separator:aba02f1cf2c9b0f885fb7331ef2c4a8f6 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58df4b2dafa03e935e260c2f9ba5fc9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac58df4b2dafa03e935e260c2f9ba5fc9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ac58df4b2dafa03e935e260c2f9ba5fc9">printSettings</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac58df4b2dafa03e935e260c2f9ba5fc9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the settings for this state space to a stream. <br /></td></tr>
<tr class="separator:ac58df4b2dafa03e935e260c2f9ba5fc9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ddd1934b899da438488c5946e9eb66 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12ddd1934b899da438488c5946e9eb66"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a12ddd1934b899da438488c5946e9eb66">computeLocations</a> ()</td></tr>
<tr class="memdesc:a12ddd1934b899da438488c5946e9eb66 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the location information for various components of the state space. Either this function or <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a6d134d0ae2517e8fad63186223440c56" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> must be called before any calls to <a class="el" href="classompl_1_1base_1_1StateSpace.html#ae92aa2f2318020587918fb4dbca2eb07" title="Get a pointer to the double value in state that name points to. ">getValueAddressAtName()</a>, <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> (and other functions where those are used). <br /></td></tr>
<tr class="separator:a12ddd1934b899da438488c5946e9eb66 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d134d0ae2517e8fad63186223440c56 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d134d0ae2517e8fad63186223440c56"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a6d134d0ae2517e8fad63186223440c56">setup</a> ()</td></tr>
<tr class="memdesc:a6d134d0ae2517e8fad63186223440c56 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform final setup steps. This function is automatically called by the <a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">SpaceInformation</a>. If any default projections are to be registered, this call will set them and call their <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a6d134d0ae2517e8fad63186223440c56" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a6d134d0ae2517e8fad63186223440c56" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> method is still called. <br /></td></tr>
<tr class="separator:a6d134d0ae2517e8fad63186223440c56 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c772d5b74271f79d95531d00ed36bf7 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c772d5b74271f79d95531d00ed36bf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a9c772d5b74271f79d95531d00ed36bf7">addSubspace</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;component, double weight)</td></tr>
<tr class="memdesc:a9c772d5b74271f79d95531d00ed36bf7 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new state space as part of the compound state space. For computing distances within the compound state space, the weight of the component also needs to be specified. <br /></td></tr>
<tr class="separator:a9c772d5b74271f79d95531d00ed36bf7 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ea86757dc3984b00108e70d14c6e8d inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29ea86757dc3984b00108e70d14c6e8d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a29ea86757dc3984b00108e70d14c6e8d">getSubspaceCount</a> () const </td></tr>
<tr class="memdesc:a29ea86757dc3984b00108e70d14c6e8d inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of state spaces that make up the compound state space. <br /></td></tr>
<tr class="separator:a29ea86757dc3984b00108e70d14c6e8d inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb90480c2747977ebf6d2972aaa851a inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb90480c2747977ebf6d2972aaa851a"></a>
const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a1fb90480c2747977ebf6d2972aaa851a">getSubspace</a> (const unsigned int index) const </td></tr>
<tr class="memdesc:a1fb90480c2747977ebf6d2972aaa851a inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific subspace from the compound state space. <br /></td></tr>
<tr class="separator:a1fb90480c2747977ebf6d2972aaa851a inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34ec74d96fda1c3dda7650f92932290 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa34ec74d96fda1c3dda7650f92932290"></a>
const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#aa34ec74d96fda1c3dda7650f92932290">getSubspace</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:aa34ec74d96fda1c3dda7650f92932290 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific subspace from the compound state space. <br /></td></tr>
<tr class="separator:aa34ec74d96fda1c3dda7650f92932290 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fd0412787c2288b20a4db5d1d19a00 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64fd0412787c2288b20a4db5d1d19a00"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a64fd0412787c2288b20a4db5d1d19a00">getSubspaceIndex</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a64fd0412787c2288b20a4db5d1d19a00 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specific subspace from the compound state space. <br /></td></tr>
<tr class="separator:a64fd0412787c2288b20a4db5d1d19a00 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd1ef61c7d83879ff4b4da7bcde3167 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd1ef61c7d83879ff4b4da7bcde3167"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a6bd1ef61c7d83879ff4b4da7bcde3167">hasSubspace</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a6bd1ef61c7d83879ff4b4da7bcde3167 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific subspace is contained in this state space. <br /></td></tr>
<tr class="separator:a6bd1ef61c7d83879ff4b4da7bcde3167 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0a5e4f087cf1a5a5bef01136bfe280 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f0a5e4f087cf1a5a5bef01136bfe280"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a7f0a5e4f087cf1a5a5bef01136bfe280">getSubspaceWeight</a> (const unsigned int index) const </td></tr>
<tr class="memdesc:a7f0a5e4f087cf1a5a5bef01136bfe280 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight of a subspace from the compound state space (used in distance computation) <br /></td></tr>
<tr class="separator:a7f0a5e4f087cf1a5a5bef01136bfe280 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a7044d0cf02521d7fa25175c56ff7d inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3a7044d0cf02521d7fa25175c56ff7d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#af3a7044d0cf02521d7fa25175c56ff7d">getSubspaceWeight</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:af3a7044d0cf02521d7fa25175c56ff7d inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight of a subspace from the compound state space (used in distance computation) <br /></td></tr>
<tr class="separator:af3a7044d0cf02521d7fa25175c56ff7d inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd107b9b1dadcaf1be6adf83d34f38cf inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd107b9b1dadcaf1be6adf83d34f38cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#abd107b9b1dadcaf1be6adf83d34f38cf">setSubspaceWeight</a> (const unsigned int index, double weight)</td></tr>
<tr class="memdesc:abd107b9b1dadcaf1be6adf83d34f38cf inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weight of a subspace in the compound state space (used in distance computation) <br /></td></tr>
<tr class="separator:abd107b9b1dadcaf1be6adf83d34f38cf inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaadb6fc872c2ad7ec0f6d2ad2339e14 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaadb6fc872c2ad7ec0f6d2ad2339e14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#acaadb6fc872c2ad7ec0f6d2ad2339e14">setSubspaceWeight</a> (const std::string &amp;name, double weight)</td></tr>
<tr class="memdesc:acaadb6fc872c2ad7ec0f6d2ad2339e14 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weight of a subspace in the compound state space (used in distance computation) <br /></td></tr>
<tr class="separator:acaadb6fc872c2ad7ec0f6d2ad2339e14 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb551d80251d565baf96172754066573 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb551d80251d565baf96172754066573"></a>
const std::vector&lt; <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#aeb551d80251d565baf96172754066573">getSubspaces</a> () const </td></tr>
<tr class="memdesc:aeb551d80251d565baf96172754066573 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of components. <br /></td></tr>
<tr class="separator:aeb551d80251d565baf96172754066573 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12daaeda5c53935c288a371f1379a4a4 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12daaeda5c53935c288a371f1379a4a4"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a12daaeda5c53935c288a371f1379a4a4">getSubspaceWeights</a> () const </td></tr>
<tr class="memdesc:a12daaeda5c53935c288a371f1379a4a4 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of component weights. <br /></td></tr>
<tr class="separator:a12daaeda5c53935c288a371f1379a4a4 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bfc917eff0491fbacc844b63b05297 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80bfc917eff0491fbacc844b63b05297"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a80bfc917eff0491fbacc844b63b05297">isLocked</a> () const </td></tr>
<tr class="memdesc:a80bfc917eff0491fbacc844b63b05297 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the state space is locked. A value of true means that no further spaces can be added as components. <br /></td></tr>
<tr class="separator:a80bfc917eff0491fbacc844b63b05297 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab344f21f0aba84c14fda3ec87a0b21ab inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab344f21f0aba84c14fda3ec87a0b21ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ab344f21f0aba84c14fda3ec87a0b21ab">lock</a> ()</td></tr>
<tr class="memdesc:ab344f21f0aba84c14fda3ec87a0b21ab inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this state space. This means no further spaces can be added as components. This function can be for instance called from the constructor of a state space that inherits from <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html" title="A space to allow the composition of state spaces. ">CompoundStateSpace</a> to prevent the user to add further components. <br /></td></tr>
<tr class="separator:ab344f21f0aba84c14fda3ec87a0b21ab inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae962c0a4e6b229dc0960d2e927dfb757 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae962c0a4e6b229dc0960d2e927dfb757"></a>
virtual <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ae962c0a4e6b229dc0960d2e927dfb757">allocSubspaceStateSampler</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *subspace) const </td></tr>
<tr class="memdesc:ae962c0a4e6b229dc0960d2e927dfb757 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a sampler that actually samples only components that are part of <em>subspace</em>. <br /></td></tr>
<tr class="separator:ae962c0a4e6b229dc0960d2e927dfb757 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ab8864a691b72ccaaba25df55cdf61 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ab8864a691b72ccaaba25df55cdf61"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a38ab8864a691b72ccaaba25df55cdf61">getDimension</a> () const </td></tr>
<tr class="memdesc:a38ab8864a691b72ccaaba25df55cdf61 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the space (not the dimension of the surrounding ambient space) <br /></td></tr>
<tr class="separator:a38ab8864a691b72ccaaba25df55cdf61 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e40317c4c6ed599f2f56fa40f7f28a inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a49e40317c4c6ed599f2f56fa40f7f28a">getMaximumExtent</a> () const </td></tr>
<tr class="memdesc:a49e40317c4c6ed599f2f56fa40f7f28a inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum value a call to <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a3f3a7c201f2deb0e8f4c5d3be02300eb" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">distance()</a> can return (or an upper bound). For unbounded state spaces, this function can return infinity.  <a href="#a49e40317c4c6ed599f2f56fa40f7f28a">More...</a><br /></td></tr>
<tr class="separator:a49e40317c4c6ed599f2f56fa40f7f28a inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbdb868c229def0538fcfdacf5858be inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cbdb868c229def0538fcfdacf5858be"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a4cbdb868c229def0538fcfdacf5858be">getMeasure</a> () const </td></tr>
<tr class="memdesc:a4cbdb868c229def0538fcfdacf5858be inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a measure of the space (this can be thought of as a generalization of volume) <br /></td></tr>
<tr class="separator:a4cbdb868c229def0538fcfdacf5858be inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894235af9908df797d88f0df6e81b8d1 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894235af9908df797d88f0df6e81b8d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a894235af9908df797d88f0df6e81b8d1">enforceBounds</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const </td></tr>
<tr class="memdesc:a894235af9908df797d88f0df6e81b8d1 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring the state within the bounds of the state space. For unbounded spaces this function can be a no-op. <br /></td></tr>
<tr class="separator:a894235af9908df797d88f0df6e81b8d1 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9774b49bc4ac4bcb6aed4f6a99454385 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9774b49bc4ac4bcb6aed4f6a99454385"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a9774b49bc4ac4bcb6aed4f6a99454385">satisfiesBounds</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const </td></tr>
<tr class="memdesc:a9774b49bc4ac4bcb6aed4f6a99454385 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state is inside the bounding box. For unbounded spaces this function can always return true. <br /></td></tr>
<tr class="separator:a9774b49bc4ac4bcb6aed4f6a99454385 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb0c910eba4d5e0ac961c21dbb1ecf8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb0c910eba4d5e0ac961c21dbb1ecf8"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#aceb0c910eba4d5e0ac961c21dbb1ecf8">getSerializationLength</a> () const </td></tr>
<tr class="memdesc:aceb0c910eba4d5e0ac961c21dbb1ecf8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of chars in the serialization of a state in this space. <br /></td></tr>
<tr class="separator:aceb0c910eba4d5e0ac961c21dbb1ecf8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eafcd6aab8e6751022dd7c86b2a5316 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eafcd6aab8e6751022dd7c86b2a5316"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a1eafcd6aab8e6751022dd7c86b2a5316">serialize</a> (void *serialization, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const </td></tr>
<tr class="memdesc:a1eafcd6aab8e6751022dd7c86b2a5316 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the binary representation of <em>state</em> to <em>serialization</em>. <br /></td></tr>
<tr class="separator:a1eafcd6aab8e6751022dd7c86b2a5316 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286eecaef26d805971fee8781ab59ab8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a286eecaef26d805971fee8781ab59ab8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a286eecaef26d805971fee8781ab59ab8">deserialize</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const void *serialization) const </td></tr>
<tr class="memdesc:a286eecaef26d805971fee8781ab59ab8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the binary representation of a state from <em>serialization</em> and write it to <em>state</em>. <br /></td></tr>
<tr class="separator:a286eecaef26d805971fee8781ab59ab8 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3a7c201f2deb0e8f4c5d3be02300eb inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f3a7c201f2deb0e8f4c5d3be02300eb"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a3f3a7c201f2deb0e8f4c5d3be02300eb">distance</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state1, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state2) const </td></tr>
<tr class="memdesc:a3f3a7c201f2deb0e8f4c5d3be02300eb inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes distance between two states. This function satisfies the properties of a metric if <a class="el" href="classompl_1_1base_1_1StateSpace.html#a448989a6c1d0b9e40a4f5a194ec3a92a" title="Return true if the distance function associated with the space is a metric. ">isMetricSpace()</a> is true, and its return value will always be between 0 and <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a49e40317c4c6ed599f2f56fa40f7f28a" title="Get the maximum value a call to distance() can return (or an upper bound). For unbounded state spaces...">getMaximumExtent()</a> <br /></td></tr>
<tr class="separator:a3f3a7c201f2deb0e8f4c5d3be02300eb inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e99d9d6749436e4e3549023ae96fe inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07e99d9d6749436e4e3549023ae96fe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ac07e99d9d6749436e4e3549023ae96fe">setLongestValidSegmentFraction</a> (double segmentFraction)</td></tr>
<tr class="memdesc:ac07e99d9d6749436e4e3549023ae96fe inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing discrete validation of motions, the length of the longest segment that does not require state validation needs to be specified. This function sets this length as a fraction of the space's maximum extent. The call is passed to all contained subspaces. <br /></td></tr>
<tr class="separator:ac07e99d9d6749436e4e3549023ae96fe inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9e674f7301a307b1a547d9548b542f inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc9e674f7301a307b1a547d9548b542f"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#adc9e674f7301a307b1a547d9548b542f">validSegmentCount</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state1, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state2) const </td></tr>
<tr class="memdesc:adc9e674f7301a307b1a547d9548b542f inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many segments of the "longest valid length" fit on the motion from <em>state1</em> to <em>state2</em>. This is the max() of the counts returned by contained subspaces. <br /></td></tr>
<tr class="separator:adc9e674f7301a307b1a547d9548b542f inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382c3d7ac348ae7ea9ef6f8a4284d8f9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a382c3d7ac348ae7ea9ef6f8a4284d8f9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a382c3d7ac348ae7ea9ef6f8a4284d8f9">equalStates</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state1, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state2) const </td></tr>
<tr class="memdesc:a382c3d7ac348ae7ea9ef6f8a4284d8f9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two states are equal. <br /></td></tr>
<tr class="separator:a382c3d7ac348ae7ea9ef6f8a4284d8f9 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d40189fcde811ba620ebc96af33901 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a88d40189fcde811ba620ebc96af33901">getValueAddressAtIndex</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const unsigned int index) const </td></tr>
<tr class="memdesc:a88d40189fcde811ba620ebc96af33901 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many states contain a number of double values. This function provides a means to get the memory address of a double value from state <em>state</em> located at position <em>index</em>. The first double value is returned for <em>index</em> = 0. If <em>index</em> is too large (does not point to any double values in the state), the return value is NULL.  <a href="#a88d40189fcde811ba620ebc96af33901">More...</a><br /></td></tr>
<tr class="separator:a88d40189fcde811ba620ebc96af33901 inherit pub_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classompl_1_1base_1_1StateSpace"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classompl_1_1base_1_1StateSpace')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classompl_1_1base_1_1StateSpace.html">ompl::base::StateSpace</a></td></tr>
<tr class="memitem:acfcc534e7c16c163ef33a05f195a0305 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfcc534e7c16c163ef33a05f195a0305"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#acfcc534e7c16c163ef33a05f195a0305">StateSpace</a> ()</td></tr>
<tr class="memdesc:acfcc534e7c16c163ef33a05f195a0305 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Assigns a <b>unique</b> name to the space. <br /></td></tr>
<tr class="separator:acfcc534e7c16c163ef33a05f195a0305 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd88dea5b056dae47158f22edb21e562 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afd88dea5b056dae47158f22edb21e562 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#afd88dea5b056dae47158f22edb21e562">as</a> ()</td></tr>
<tr class="memdesc:afd88dea5b056dae47158f22edb21e562 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this instance to a desired type.  <a href="#afd88dea5b056dae47158f22edb21e562">More...</a><br /></td></tr>
<tr class="separator:afd88dea5b056dae47158f22edb21e562 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f4c7086d9f337752ba1522d2dc5b3e inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a97f4c7086d9f337752ba1522d2dc5b3e inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a97f4c7086d9f337752ba1522d2dc5b3e">as</a> () const </td></tr>
<tr class="memdesc:a97f4c7086d9f337752ba1522d2dc5b3e inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this instance to a desired type.  <a href="#a97f4c7086d9f337752ba1522d2dc5b3e">More...</a><br /></td></tr>
<tr class="separator:a97f4c7086d9f337752ba1522d2dc5b3e inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ca6eb429ff4f3bb0cf2f485b5f340 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae51ca6eb429ff4f3bb0cf2f485b5f340">isDiscrete</a> () const </td></tr>
<tr class="memdesc:ae51ca6eb429ff4f3bb0cf2f485b5f340 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the set of states is discrete.  <a href="#ae51ca6eb429ff4f3bb0cf2f485b5f340">More...</a><br /></td></tr>
<tr class="separator:ae51ca6eb429ff4f3bb0cf2f485b5f340 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448989a6c1d0b9e40a4f5a194ec3a92a inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a448989a6c1d0b9e40a4f5a194ec3a92a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a448989a6c1d0b9e40a4f5a194ec3a92a">isMetricSpace</a> () const </td></tr>
<tr class="memdesc:a448989a6c1d0b9e40a4f5a194ec3a92a inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the distance function associated with the space is a metric. <br /></td></tr>
<tr class="separator:a448989a6c1d0b9e40a4f5a194ec3a92a inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4245c946e2a60bf2a6cfa611cbf64ced inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4245c946e2a60bf2a6cfa611cbf64ced"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a4245c946e2a60bf2a6cfa611cbf64ced">hasSymmetricDistance</a> () const </td></tr>
<tr class="memdesc:a4245c946e2a60bf2a6cfa611cbf64ced inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the distance function on this state space is symmetric, i.e. distance(s1,s2) = distance(s2,s1). Default implementation returns true. <br /></td></tr>
<tr class="separator:a4245c946e2a60bf2a6cfa611cbf64ced inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9b314f8a64031e8269cd76489b629d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a9b314f8a64031e8269cd76489b629d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a4a9b314f8a64031e8269cd76489b629d">hasSymmetricInterpolate</a> () const </td></tr>
<tr class="memdesc:a4a9b314f8a64031e8269cd76489b629d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the interpolation function on this state space is symmetric, i.e. interpolate(from, to, t, state) = interpolate(to, from, 1-t, state). Default implementation returns true. <br /></td></tr>
<tr class="separator:a4a9b314f8a64031e8269cd76489b629d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c188c7dc690b152b7a61aae19b9015 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c188c7dc690b152b7a61aae19b9015"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a01c188c7dc690b152b7a61aae19b9015">getName</a> () const </td></tr>
<tr class="memdesc:a01c188c7dc690b152b7a61aae19b9015 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the state space. <br /></td></tr>
<tr class="separator:a01c188c7dc690b152b7a61aae19b9015 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cc022ef531dcb563f6d3d13b847ad inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad12cc022ef531dcb563f6d3d13b847ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad12cc022ef531dcb563f6d3d13b847ad">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad12cc022ef531dcb563f6d3d13b847ad inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the state space. <br /></td></tr>
<tr class="separator:ad12cc022ef531dcb563f6d3d13b847ad inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626ff04e6b9c4c9fa2c1392713861bf inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa626ff04e6b9c4c9fa2c1392713861bf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa626ff04e6b9c4c9fa2c1392713861bf">getType</a> () const </td></tr>
<tr class="memdesc:aa626ff04e6b9c4c9fa2c1392713861bf inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the state space. The type can be used to verify whether two space instances are of the same type (e.g., SO2) <br /></td></tr>
<tr class="separator:aa626ff04e6b9c4c9fa2c1392713861bf inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af294ec92dcc0e35793570d039d61d019 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af294ec92dcc0e35793570d039d61d019"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#af294ec92dcc0e35793570d039d61d019">includes</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;other) const </td></tr>
<tr class="memdesc:af294ec92dcc0e35793570d039d61d019 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space included (perhaps equal, perhaps a subspace) in this one. <br /></td></tr>
<tr class="separator:af294ec92dcc0e35793570d039d61d019 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7768e633f4c4c09f02d01f7ad765dcd1 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7768e633f4c4c09f02d01f7ad765dcd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a7768e633f4c4c09f02d01f7ad765dcd1">includes</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *other) const </td></tr>
<tr class="memdesc:a7768e633f4c4c09f02d01f7ad765dcd1 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space included (perhaps equal, perhaps a subspace) in this one. <br /></td></tr>
<tr class="separator:a7768e633f4c4c09f02d01f7ad765dcd1 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a2cdf29ab85faa2b76cca36c23229d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a2cdf29ab85faa2b76cca36c23229d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a41a2cdf29ab85faa2b76cca36c23229d">covers</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;other) const </td></tr>
<tr class="memdesc:a41a2cdf29ab85faa2b76cca36c23229d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space that is either included (perhaps equal, perhaps a subspace) in this one, or all of its subspaces are included in this one. <br /></td></tr>
<tr class="separator:a41a2cdf29ab85faa2b76cca36c23229d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e585bf55e4cbb03ad2da5f192df01ee inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e585bf55e4cbb03ad2da5f192df01ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a3e585bf55e4cbb03ad2da5f192df01ee">covers</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *other) const </td></tr>
<tr class="memdesc:a3e585bf55e4cbb03ad2da5f192df01ee inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space that is either included (perhaps equal, perhaps a subspace) in this one, or all of its subspaces are included in this one. <br /></td></tr>
<tr class="separator:a3e585bf55e4cbb03ad2da5f192df01ee inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9fee742c4811d13f236aecd6b9d901 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d9fee742c4811d13f236aecd6b9d901"></a>
<a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9d9fee742c4811d13f236aecd6b9d901">params</a> ()</td></tr>
<tr class="memdesc:a9d9fee742c4811d13f236aecd6b9d901 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters for this space. <br /></td></tr>
<tr class="separator:a9d9fee742c4811d13f236aecd6b9d901 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f942d26b8d63262ff5fb5e8774bf4e0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f942d26b8d63262ff5fb5e8774bf4e0"></a>
const <a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9f942d26b8d63262ff5fb5e8774bf4e0">params</a> () const </td></tr>
<tr class="memdesc:a9f942d26b8d63262ff5fb5e8774bf4e0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters for this space. <br /></td></tr>
<tr class="separator:a9f942d26b8d63262ff5fb5e8774bf4e0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6098a238a7cc1925c58e9983ab5f2967 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6098a238a7cc1925c58e9983ab5f2967"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a6098a238a7cc1925c58e9983ab5f2967">getLongestValidSegmentFraction</a> () const </td></tr>
<tr class="memdesc:a6098a238a7cc1925c58e9983ab5f2967 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing discrete validation of motions, the length of the longest segment that does not require state validation needs to be specified. This function returns this length, for this state space, as a fraction of the space's maximum extent. <br /></td></tr>
<tr class="separator:a6098a238a7cc1925c58e9983ab5f2967 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9babd71497fc6a6f82fe97f699531ceb inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9babd71497fc6a6f82fe97f699531ceb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9babd71497fc6a6f82fe97f699531ceb">setValidSegmentCountFactor</a> (unsigned int factor)</td></tr>
<tr class="memdesc:a9babd71497fc6a6f82fe97f699531ceb inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>factor</em> to be the value to multiply the return value of <a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7" title="Count how many segments of the &quot;longest valid length&quot; fit on the motion from state1 to state2...">validSegmentCount()</a>. By default, this value is 1. The higher the value, the smaller the size of the segments considered valid. The effect of this function is immediate (<a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> does not need to be called). <br /></td></tr>
<tr class="separator:a9babd71497fc6a6f82fe97f699531ceb inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed57ae383c07bbc4fddbd9ab66de466b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed57ae383c07bbc4fddbd9ab66de466b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aed57ae383c07bbc4fddbd9ab66de466b">getValidSegmentCountFactor</a> () const </td></tr>
<tr class="memdesc:aed57ae383c07bbc4fddbd9ab66de466b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value used to multiply the return value of <a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7" title="Count how many segments of the &quot;longest valid length&quot; fit on the motion from state1 to state2...">validSegmentCount()</a>. <br /></td></tr>
<tr class="separator:aed57ae383c07bbc4fddbd9ab66de466b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8381e2478361e9326480b622e4c03b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c8381e2478361e9326480b622e4c03b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a0c8381e2478361e9326480b622e4c03b">getLongestValidSegmentLength</a> () const </td></tr>
<tr class="memdesc:a0c8381e2478361e9326480b622e4c03b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the longest valid segment at the time <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> was called. <br /></td></tr>
<tr class="separator:a0c8381e2478361e9326480b622e4c03b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea93afe2f6c3af1702178992554519c0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea93afe2f6c3af1702178992554519c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aea93afe2f6c3af1702178992554519c0">computeSignature</a> (std::vector&lt; int &gt; &amp;signature) const </td></tr>
<tr class="memdesc:aea93afe2f6c3af1702178992554519c0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an array of ints that uniquely identifies the structure of the state space. The first element of the signature is the number of integers that follow. <br /></td></tr>
<tr class="separator:aea93afe2f6c3af1702178992554519c0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88e8a85586b93866ef3b2a6fb31c114 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88e8a85586b93866ef3b2a6fb31c114"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa88e8a85586b93866ef3b2a6fb31c114">setStateSamplerAllocator</a> (const <a class="el" href="namespaceompl_1_1base.html#a0898b21bd2fed51298626f7be55779b8">StateSamplerAllocator</a> &amp;ssa)</td></tr>
<tr class="memdesc:aa88e8a85586b93866ef3b2a6fb31c114 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sampler allocator to use. <br /></td></tr>
<tr class="separator:aa88e8a85586b93866ef3b2a6fb31c114 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c1c40dcb3687c024629119e2d905d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd0c1c40dcb3687c024629119e2d905d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#abd0c1c40dcb3687c024629119e2d905d">clearStateSamplerAllocator</a> ()</td></tr>
<tr class="memdesc:abd0c1c40dcb3687c024629119e2d905d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the state sampler allocator (reset to default) <br /></td></tr>
<tr class="separator:abd0c1c40dcb3687c024629119e2d905d inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a758dfef4b4e0ca3aa126862e0e834 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a758dfef4b4e0ca3aa126862e0e834"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae8a758dfef4b4e0ca3aa126862e0e834">getValueAddressAtIndex</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const unsigned int index) const </td></tr>
<tr class="memdesc:ae8a758dfef4b4e0ca3aa126862e0e834 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of the same function as above;. <br /></td></tr>
<tr class="separator:ae8a758dfef4b4e0ca3aa126862e0e834 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a3c20690488593be339b034c65a1ec inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a3c20690488593be339b034c65a1ec"></a>
const std::vector&lt; <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa5a3c20690488593be339b034c65a1ec">getValueLocations</a> () const </td></tr>
<tr class="memdesc:aa5a3c20690488593be339b034c65a1ec inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locations of values of type double contained in a state from this space. The order of the values is consistent with <a class="el" href="classompl_1_1base_1_1StateSpace.html#a8584afb9165d2aa7408fec81c18659f4" title="Many states contain a number of double values. This function provides a means to get the memory addre...">getValueAddressAtIndex()</a>. The <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> function must have been previously called. <br /></td></tr>
<tr class="separator:aa5a3c20690488593be339b034c65a1ec inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7757bb42622aef8a20ae44b2174124ae inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7757bb42622aef8a20ae44b2174124ae"></a>
const std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a7757bb42622aef8a20ae44b2174124ae">getValueLocationsByName</a> () const </td></tr>
<tr class="memdesc:a7757bb42622aef8a20ae44b2174124ae inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the named locations of values of type double contained in a state from this space. The <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> function must have been previously called. <br /></td></tr>
<tr class="separator:a7757bb42622aef8a20ae44b2174124ae inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1440136336d3b92067e77b8586db5448 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1440136336d3b92067e77b8586db5448"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448">getValueAddressAtLocation</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:a1440136336d3b92067e77b8586db5448 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the double value in <em>state</em> that <em>loc</em> points to. <br /></td></tr>
<tr class="separator:a1440136336d3b92067e77b8586db5448 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b21b2faa7e5f93512a2a4b40f8599ab inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b21b2faa7e5f93512a2a4b40f8599ab"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a2b21b2faa7e5f93512a2a4b40f8599ab">getValueAddressAtLocation</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:a2b21b2faa7e5f93512a2a4b40f8599ab inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of the same function as above;. <br /></td></tr>
<tr class="separator:a2b21b2faa7e5f93512a2a4b40f8599ab inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92aa2f2318020587918fb4dbca2eb07 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae92aa2f2318020587918fb4dbca2eb07"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae92aa2f2318020587918fb4dbca2eb07">getValueAddressAtName</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const std::string &amp;name) const </td></tr>
<tr class="memdesc:ae92aa2f2318020587918fb4dbca2eb07 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the double value in <em>state</em> that <em>name</em> points to. <br /></td></tr>
<tr class="separator:ae92aa2f2318020587918fb4dbca2eb07 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8399a3f967203a5035da33c5eb5b04cc inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8399a3f967203a5035da33c5eb5b04cc"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a8399a3f967203a5035da33c5eb5b04cc">getValueAddressAtName</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const std::string &amp;name) const </td></tr>
<tr class="memdesc:a8399a3f967203a5035da33c5eb5b04cc inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of the same function as above;. <br /></td></tr>
<tr class="separator:a8399a3f967203a5035da33c5eb5b04cc inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6fc5ba387526bb853b6a2d3d3f2bd inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02c6fc5ba387526bb853b6a2d3d3f2bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a02c6fc5ba387526bb853b6a2d3d3f2bd">copyToReals</a> (std::vector&lt; double &gt; &amp;reals, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source) const </td></tr>
<tr class="memdesc:a02c6fc5ba387526bb853b6a2d3d3f2bd inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all the real values from a state <em>source</em> to the array <em>reals</em> using <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> <br /></td></tr>
<tr class="separator:a02c6fc5ba387526bb853b6a2d3d3f2bd inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d9f193839b8c57a3d1dc11dfb364db inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d9f193839b8c57a3d1dc11dfb364db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a86d9f193839b8c57a3d1dc11dfb364db">copyFromReals</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *destination, const std::vector&lt; double &gt; &amp;reals) const </td></tr>
<tr class="memdesc:a86d9f193839b8c57a3d1dc11dfb364db inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from <em>reals</em> to the state <em>destination</em> using <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> <br /></td></tr>
<tr class="separator:a86d9f193839b8c57a3d1dc11dfb364db inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309f2cdc5412ff16d31b87fec92b3595 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a309f2cdc5412ff16d31b87fec92b3595"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a309f2cdc5412ff16d31b87fec92b3595">registerProjection</a> (const std::string &amp;name, const <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &amp;projection)</td></tr>
<tr class="memdesc:a309f2cdc5412ff16d31b87fec92b3595 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a projection for this state space under a specified name. <br /></td></tr>
<tr class="separator:a309f2cdc5412ff16d31b87fec92b3595 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79f6342fb2d85f1c2c87bfff812fbbf inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79f6342fb2d85f1c2c87bfff812fbbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac79f6342fb2d85f1c2c87bfff812fbbf">registerDefaultProjection</a> (const <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &amp;projection)</td></tr>
<tr class="memdesc:ac79f6342fb2d85f1c2c87bfff812fbbf inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the default projection for this state space. <br /></td></tr>
<tr class="separator:ac79f6342fb2d85f1c2c87bfff812fbbf inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d83398ca1647e06036d9e69ebad7cf8 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d83398ca1647e06036d9e69ebad7cf8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9d83398ca1647e06036d9e69ebad7cf8">registerProjections</a> ()</td></tr>
<tr class="memdesc:a9d83398ca1647e06036d9e69ebad7cf8 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the projections for this state space. Usually, this is at least the default projection. These are implicit projections, set by the implementation of the state space. This is called by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a>. <br /></td></tr>
<tr class="separator:a9d83398ca1647e06036d9e69ebad7cf8 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e75a507f6e8e538d1542bc9e31b256 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e75a507f6e8e538d1542bc9e31b256"></a>
<a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a05e75a507f6e8e538d1542bc9e31b256">getProjection</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a05e75a507f6e8e538d1542bc9e31b256 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection registered under a specific name. <br /></td></tr>
<tr class="separator:a05e75a507f6e8e538d1542bc9e31b256 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72230e2d66fc50b2670d21906397eeb2 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72230e2d66fc50b2670d21906397eeb2"></a>
<a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a72230e2d66fc50b2670d21906397eeb2">getDefaultProjection</a> () const </td></tr>
<tr class="memdesc:a72230e2d66fc50b2670d21906397eeb2 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default projection. <br /></td></tr>
<tr class="separator:a72230e2d66fc50b2670d21906397eeb2 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8b8097e7c5defa159797a80c2ebf2 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade8b8097e7c5defa159797a80c2ebf2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aade8b8097e7c5defa159797a80c2ebf2">hasProjection</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:aade8b8097e7c5defa159797a80c2ebf2 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a projection with a specified name is available. <br /></td></tr>
<tr class="separator:aade8b8097e7c5defa159797a80c2ebf2 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19df18cdd2ae774d223faac12c116d0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19df18cdd2ae774d223faac12c116d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae19df18cdd2ae774d223faac12c116d0">hasDefaultProjection</a> () const </td></tr>
<tr class="memdesc:ae19df18cdd2ae774d223faac12c116d0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a default projection is available. <br /></td></tr>
<tr class="separator:ae19df18cdd2ae774d223faac12c116d0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8712f482e90c8a0c666bb89ef0711b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe8712f482e90c8a0c666bb89ef0711b"></a>
const std::map&lt; std::string, <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#abe8712f482e90c8a0c666bb89ef0711b">getRegisteredProjections</a> () const </td></tr>
<tr class="memdesc:abe8712f482e90c8a0c666bb89ef0711b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the registered projections. <br /></td></tr>
<tr class="separator:abe8712f482e90c8a0c666bb89ef0711b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d8370d634b7e6fcb38d072c9ef317 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3d8370d634b7e6fcb38d072c9ef317"></a>
<a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#adc3d8370d634b7e6fcb38d072c9ef317">allocSubspaceStateSampler</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;subspace) const </td></tr>
<tr class="memdesc:adc3d8370d634b7e6fcb38d072c9ef317 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a sampler that actually samples only components that are part of <em>subspace</em>. <br /></td></tr>
<tr class="separator:adc3d8370d634b7e6fcb38d072c9ef317 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d545b50a54e230bbdac1e0eb7e945b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7d545b50a54e230bbdac1e0eb7e945b"></a>
<a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac7d545b50a54e230bbdac1e0eb7e945b">getSubstateAtLocation</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:ac7d545b50a54e230bbdac1e0eb7e945b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substate of <em>state</em> that is pointed to by <em>loc</em>. <br /></td></tr>
<tr class="separator:ac7d545b50a54e230bbdac1e0eb7e945b inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad714cae5c068fb733df05b53b6816d63 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad714cae5c068fb733df05b53b6816d63"></a>
const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad714cae5c068fb733df05b53b6816d63">getSubstateAtLocation</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:ad714cae5c068fb733df05b53b6816d63 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substate of <em>state</em> that is pointed to by <em>loc</em>. <br /></td></tr>
<tr class="separator:ad714cae5c068fb733df05b53b6816d63 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535a54d0cedf038703db2fbfd00fb5d0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535a54d0cedf038703db2fbfd00fb5d0"></a>
const std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a535a54d0cedf038703db2fbfd00fb5d0">getSubstateLocationsByName</a> () const </td></tr>
<tr class="memdesc:a535a54d0cedf038703db2fbfd00fb5d0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of known substate locations (keys of the map corrspond to names of subspaces) <br /></td></tr>
<tr class="separator:a535a54d0cedf038703db2fbfd00fb5d0 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbffba40d1dff6e3c0b80cc2439f2378 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbffba40d1dff6e3c0b80cc2439f2378"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#afbffba40d1dff6e3c0b80cc2439f2378">getCommonSubspaces</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;other, std::vector&lt; std::string &gt; &amp;subspaces) const </td></tr>
<tr class="memdesc:afbffba40d1dff6e3c0b80cc2439f2378 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of subspaces that this space and <em>other</em> have in common. The computed list of <em>subspaces</em> does not contain spaces that cover each other, even though they may be common, as that is redundant information. <br /></td></tr>
<tr class="separator:afbffba40d1dff6e3c0b80cc2439f2378 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fa8c0af22fe3f28f2fc9d551082455 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fa8c0af22fe3f28f2fc9d551082455"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a40fa8c0af22fe3f28f2fc9d551082455">getCommonSubspaces</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *other, std::vector&lt; std::string &gt; &amp;subspaces) const </td></tr>
<tr class="memdesc:a40fa8c0af22fe3f28f2fc9d551082455 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of subspaces that this space and <em>other</em> have in common. The computed list of <em>subspaces</em> does not contain spaces that cover each other, even though they may be common, as that is redundant information. <br /></td></tr>
<tr class="separator:a40fa8c0af22fe3f28f2fc9d551082455 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d0d31d8cf99ca55e83d83be778918 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a988d0d31d8cf99ca55e83d83be778918"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a988d0d31d8cf99ca55e83d83be778918">printProjections</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a988d0d31d8cf99ca55e83d83be778918 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of registered projections. This function is also called by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a0d78e50cceae2e0a432fea171a431324" title="Print the settings for this state space to a stream. ">printSettings()</a> <br /></td></tr>
<tr class="separator:a988d0d31d8cf99ca55e83d83be778918 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f53aa590e5054a150861d2d1689522 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a24f53aa590e5054a150861d2d1689522">sanityChecks</a> (double zero, double eps, unsigned int flags) const </td></tr>
<tr class="memdesc:a24f53aa590e5054a150861d2d1689522 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sanity checks for this state space. Throws an exception if failures are found.  <a href="#a24f53aa590e5054a150861d2d1689522">More...</a><br /></td></tr>
<tr class="separator:a24f53aa590e5054a150861d2d1689522 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bf3d53b9a2292d1df64f9908980fb inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a332bf3d53b9a2292d1df64f9908980fb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a332bf3d53b9a2292d1df64f9908980fb">sanityChecks</a> () const </td></tr>
<tr class="memdesc:a332bf3d53b9a2292d1df64f9908980fb inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that allows derived state spaces to choose which checks should pass (see SanityChecks flags) and how strict the checks are. This just calls <a class="el" href="classompl_1_1base_1_1StateSpace.html#a24f53aa590e5054a150861d2d1689522" title="Perform sanity checks for this state space. Throws an exception if failures are found. ">sanityChecks()</a> with some default arguments. <br /></td></tr>
<tr class="separator:a332bf3d53b9a2292d1df64f9908980fb inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d094a956a3819951ea60233ec5d5d9 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d094a956a3819951ea60233ec5d5d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac9d094a956a3819951ea60233ec5d5d9">diagram</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac9d094a956a3819951ea60233ec5d5d9 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a Graphviz digraph that represents the containment diagram for the state space. <br /></td></tr>
<tr class="separator:ac9d094a956a3819951ea60233ec5d5d9 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf040ebe3877e36856fa4370434f61b5 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf040ebe3877e36856fa4370434f61b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aaf040ebe3877e36856fa4370434f61b5">list</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aaf040ebe3877e36856fa4370434f61b5 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of all contained state space instances. <br /></td></tr>
<tr class="separator:aaf040ebe3877e36856fa4370434f61b5 inherit pub_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae83d9fb6b1e5cda6f0f3650014838085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae83d9fb6b1e5cda6f0f3650014838085"></a>
<a class="el" href="classompl_1_1control_1_1OpenDEEnvironmentPtr.html">OpenDEEnvironmentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#ae83d9fb6b1e5cda6f0f3650014838085">env_</a></td></tr>
<tr class="memdesc:ae83d9fb6b1e5cda6f0f3650014838085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of the OpenDE parameters OMPL needs to plan. <br /></td></tr>
<tr class="separator:ae83d9fb6b1e5cda6f0f3650014838085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classompl_1_1base_1_1CompoundStateSpace')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html">ompl::base::CompoundStateSpace</a></td></tr>
<tr class="memitem:ae5f43ed0a30998604b18f50b007455b4 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5f43ed0a30998604b18f50b007455b4"></a>
std::vector&lt; <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ae5f43ed0a30998604b18f50b007455b4">components_</a></td></tr>
<tr class="memdesc:ae5f43ed0a30998604b18f50b007455b4 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state spaces that make up the compound state space. <br /></td></tr>
<tr class="separator:ae5f43ed0a30998604b18f50b007455b4 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53501d4730a16782ad9619e8423d15 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c53501d4730a16782ad9619e8423d15"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a8c53501d4730a16782ad9619e8423d15">componentCount_</a></td></tr>
<tr class="memdesc:a8c53501d4730a16782ad9619e8423d15 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of components. <br /></td></tr>
<tr class="separator:a8c53501d4730a16782ad9619e8423d15 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc7fd19539c47056f3395a39d2ef67 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbbc7fd19539c47056f3395a39d2ef67"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#adbbc7fd19539c47056f3395a39d2ef67">weights_</a></td></tr>
<tr class="memdesc:adbbc7fd19539c47056f3395a39d2ef67 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight assigned to each component of the state space when computing the compound distance. <br /></td></tr>
<tr class="separator:adbbc7fd19539c47056f3395a39d2ef67 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49177a2fbfdbd97e8cfd75743fc939dd inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49177a2fbfdbd97e8cfd75743fc939dd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a49177a2fbfdbd97e8cfd75743fc939dd">weightSum_</a></td></tr>
<tr class="memdesc:a49177a2fbfdbd97e8cfd75743fc939dd inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of all the weights in <em>weights_</em>. <br /></td></tr>
<tr class="separator:a49177a2fbfdbd97e8cfd75743fc939dd inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed84298425b21e1d2b120a85c124427 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ed84298425b21e1d2b120a85c124427"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a4ed84298425b21e1d2b120a85c124427">locked_</a></td></tr>
<tr class="memdesc:a4ed84298425b21e1d2b120a85c124427 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether adding further components is allowed or not. <br /></td></tr>
<tr class="separator:a4ed84298425b21e1d2b120a85c124427 inherit pro_attribs_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classompl_1_1base_1_1StateSpace"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classompl_1_1base_1_1StateSpace')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classompl_1_1base_1_1StateSpace.html">ompl::base::StateSpace</a></td></tr>
<tr class="memitem:a68556edd816136a66a0d81544baef08c inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68556edd816136a66a0d81544baef08c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a68556edd816136a66a0d81544baef08c">type_</a></td></tr>
<tr class="memdesc:a68556edd816136a66a0d81544baef08c inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type assigned for this state space. <br /></td></tr>
<tr class="separator:a68556edd816136a66a0d81544baef08c inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db3152c4edbac084af3ec6962107ddb inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2db3152c4edbac084af3ec6962107ddb"></a>
<a class="el" href="namespaceompl_1_1base.html#a0898b21bd2fed51298626f7be55779b8">StateSamplerAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a2db3152c4edbac084af3ec6962107ddb">ssa_</a></td></tr>
<tr class="memdesc:a2db3152c4edbac084af3ec6962107ddb inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional state sampler allocator. <br /></td></tr>
<tr class="separator:a2db3152c4edbac084af3ec6962107ddb inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139d63d7b1067a70cb6e744e85fef96 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af139d63d7b1067a70cb6e744e85fef96"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#af139d63d7b1067a70cb6e744e85fef96">maxExtent_</a></td></tr>
<tr class="memdesc:af139d63d7b1067a70cb6e744e85fef96 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extent of this space at the time <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> was called. <br /></td></tr>
<tr class="separator:af139d63d7b1067a70cb6e744e85fef96 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaba86765fbfc6686312e50934edfd70 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaba86765fbfc6686312e50934edfd70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aeaba86765fbfc6686312e50934edfd70">longestValidSegmentFraction_</a></td></tr>
<tr class="memdesc:aeaba86765fbfc6686312e50934edfd70 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction of the longest valid segment. <br /></td></tr>
<tr class="separator:aeaba86765fbfc6686312e50934edfd70 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967afde4dc99333aef63eb85554bf81 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8967afde4dc99333aef63eb85554bf81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a8967afde4dc99333aef63eb85554bf81">longestValidSegment_</a></td></tr>
<tr class="memdesc:a8967afde4dc99333aef63eb85554bf81 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The longest valid segment at the time <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> was called. <br /></td></tr>
<tr class="separator:a8967afde4dc99333aef63eb85554bf81 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fbdc24d4e07283890eb68f49bc1467 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3fbdc24d4e07283890eb68f49bc1467"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa3fbdc24d4e07283890eb68f49bc1467">longestValidSegmentCountFactor_</a></td></tr>
<tr class="memdesc:aa3fbdc24d4e07283890eb68f49bc1467 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factor to multiply the value returned by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7" title="Count how many segments of the &quot;longest valid length&quot; fit on the motion from state1 to state2...">validSegmentCount()</a>. Rarely used but useful for things like doubling the resolution. <br /></td></tr>
<tr class="separator:aa3fbdc24d4e07283890eb68f49bc1467 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32be9ff082fcb2926cbc8166613e09a inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab32be9ff082fcb2926cbc8166613e09a"></a>
std::map&lt; std::string, <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ab32be9ff082fcb2926cbc8166613e09a">projections_</a></td></tr>
<tr class="memdesc:ab32be9ff082fcb2926cbc8166613e09a inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of available projections. <br /></td></tr>
<tr class="separator:ab32be9ff082fcb2926cbc8166613e09a inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b0b30f238bff63ecb43542aee6ebf3 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11b0b30f238bff63ecb43542aee6ebf3"></a>
<a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a11b0b30f238bff63ecb43542aee6ebf3">params_</a></td></tr>
<tr class="memdesc:a11b0b30f238bff63ecb43542aee6ebf3 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of parameters for this space. <br /></td></tr>
<tr class="separator:a11b0b30f238bff63ecb43542aee6ebf3 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f6c83355692e7f40d4ead85b9f225b inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f6c83355692e7f40d4ead85b9f225b"></a>
std::vector&lt; <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac0f6c83355692e7f40d4ead85b9f225b">valueLocationsInOrder_</a></td></tr>
<tr class="memdesc:ac0f6c83355692e7f40d4ead85b9f225b inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value locations for all varliables of type double contained in a state; The locations point to values in the same order as that returned by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a8584afb9165d2aa7408fec81c18659f4" title="Many states contain a number of double values. This function provides a means to get the memory addre...">getValueAddressAtIndex()</a> <br /></td></tr>
<tr class="separator:ac0f6c83355692e7f40d4ead85b9f225b inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24c368e6e9130b505d89c824a9ec1e7 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24c368e6e9130b505d89c824a9ec1e7"></a>
std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac24c368e6e9130b505d89c824a9ec1e7">valueLocationsByName_</a></td></tr>
<tr class="memdesc:ac24c368e6e9130b505d89c824a9ec1e7 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the known value locations, by name. The names of state spaces access the first element of a state. <a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html" title="A state space representing Rn. The distance function is the L2 norm. ">RealVectorStateSpace</a> dimensions are used to access individual dimensions. <br /></td></tr>
<tr class="separator:ac24c368e6e9130b505d89c824a9ec1e7 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa4613b3ef62e88fbfc23fb6757e34 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23aa4613b3ef62e88fbfc23fb6757e34"></a>
std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a23aa4613b3ef62e88fbfc23fb6757e34">substateLocationsByName_</a></td></tr>
<tr class="memdesc:a23aa4613b3ef62e88fbfc23fb6757e34 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the known substat locations, by name. <br /></td></tr>
<tr class="separator:a23aa4613b3ef62e88fbfc23fb6757e34 inherit pro_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classompl_1_1base_1_1StateSpace"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classompl_1_1base_1_1StateSpace')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classompl_1_1base_1_1StateSpace.html">ompl::base::StateSpace</a></td></tr>
<tr class="memitem:a925ed4f0e97f137b4c2128afe9f36b2f inherit pub_static_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a925ed4f0e97f137b4c2128afe9f36b2f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a925ed4f0e97f137b4c2128afe9f36b2f">Diagram</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:a925ed4f0e97f137b4c2128afe9f36b2f inherit pub_static_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a Graphviz digraph that represents the containment diagram for all the instantiated state spaces. <br /></td></tr>
<tr class="separator:a925ed4f0e97f137b4c2128afe9f36b2f inherit pub_static_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab5334644d6c9f8538f59a21bec854 inherit pub_static_methods_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3ab5334644d6c9f8538f59a21bec854"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad3ab5334644d6c9f8538f59a21bec854">List</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ad3ab5334644d6c9f8538f59a21bec854 inherit pub_static_methods_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of available state space instances. <br /></td></tr>
<tr class="separator:ad3ab5334644d6c9f8538f59a21bec854 inherit pub_static_methods_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classompl_1_1base_1_1CompoundStateSpace"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classompl_1_1base_1_1CompoundStateSpace')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html">ompl::base::CompoundStateSpace</a></td></tr>
<tr class="memitem:a1486c4680ec6e01c579fba2b3614d137 inherit pro_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1486c4680ec6e01c579fba2b3614d137"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a1486c4680ec6e01c579fba2b3614d137">allocStateComponents</a> (<a class="el" href="classompl_1_1base_1_1CompoundState.html">CompoundState</a> *state) const </td></tr>
<tr class="memdesc:a1486c4680ec6e01c579fba2b3614d137 inherit pro_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the state components. Called by <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a90179d53a72d95ec08573e921fd12636" title="Allocate a state that can store a point in the described space. ">allocState()</a>. Usually called by derived state spaces. <br /></td></tr>
<tr class="separator:a1486c4680ec6e01c579fba2b3614d137 inherit pro_methods_classompl_1_1base_1_1CompoundStateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classompl_1_1base_1_1StateSpace"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classompl_1_1base_1_1StateSpace')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classompl_1_1base_1_1StateSpace.html">ompl::base::StateSpace</a></td></tr>
<tr class="memitem:a45e65cf86a2c5cb1e4394dd8aafb4d3b inherit pro_static_attribs_classompl_1_1base_1_1StateSpace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e65cf86a2c5cb1e4394dd8aafb4d3b"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a45e65cf86a2c5cb1e4394dd8aafb4d3b">DEFAULT_PROJECTION_NAME</a> = &quot;&quot;</td></tr>
<tr class="memdesc:a45e65cf86a2c5cb1e4394dd8aafb4d3b inherit pro_static_attribs_classompl_1_1base_1_1StateSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name used for the default projection. <br /></td></tr>
<tr class="separator:a45e65cf86a2c5cb1e4394dd8aafb4d3b inherit pro_static_attribs_classompl_1_1base_1_1StateSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>State space representing OpenDE states. </p>

<p>Definition at line <a class="el" href="OpenDEStateSpace_8h_source.html#l00051">51</a> of file <a class="el" href="OpenDEStateSpace_8h_source.html">OpenDEStateSpace.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a2952bf8638854bd1e33e597713f13b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2952bf8638854bd1e33e597713f13b29aaaaf494d5dcb4ad2a2dfa118bb928cc6"></a>STATE_COLLISION_KNOWN_BIT&#160;</td><td class="fielddoc">
<p>Index of bit in <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html#a4f1a462807534944ca791f1314a42fa8" title="Flag containing information about state validity. ">StateType::collision</a> indicating whether it is known if a state is in collision or not. Initially this is 0. The value of this bit is updated by <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a7c5829ff58ba3e8949874809f773160c" title="Fill the OpenDEStateSpace::STATE_COLLISION_VALUE_BIT of StateType::collision member of a state...">OpenDEStateSpace::evaluateCollision()</a> and OpenDEControlSpace::propagate(). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2952bf8638854bd1e33e597713f13b29a4aad4bf4c984a0a54251c6326ebc342b"></a>STATE_COLLISION_VALUE_BIT&#160;</td><td class="fielddoc">
<p>Index of bit in <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html#a4f1a462807534944ca791f1314a42fa8" title="Flag containing information about state validity. ">StateType::collision</a> indicating whether a state is in collision or not. Initially the value of this field is unspecified. The value gains meaning (1 or 0) when <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29aaaaf494d5dcb4ad2a2dfa118bb928cc6" title="Index of bit in StateType::collision indicating whether it is known if a state is in collision or not...">OpenDEStateSpace::STATE_COLLISION_KNOWN_BIT</a> becomes 1. The value of this bit is updated by <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a7c5829ff58ba3e8949874809f773160c" title="Fill the OpenDEStateSpace::STATE_COLLISION_VALUE_BIT of StateType::collision member of a state...">OpenDEStateSpace::evaluateCollision()</a> and OpenDEControlSpace::propagate(). A value of 1 implies that there is no collision for which <a class="el" href="classompl_1_1control_1_1OpenDEEnvironment.html#a48e3ebea213175c3ec3fb497f4bdc360" title="Decide whether a collision is a valid one or not. In some cases, collisions between some bodies can b...">OpenDEEnvironment::isValidCollision()</a> returns false. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2952bf8638854bd1e33e597713f13b29a5218d6e48f2d205c2adeb1c62a836f0c"></a>STATE_VALIDITY_KNOWN_BIT&#160;</td><td class="fielddoc">
<p>Index of bit in <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html#a4f1a462807534944ca791f1314a42fa8" title="Flag containing information about state validity. ">StateType::collision</a> indicating whether it is known if a state is in valid or not. Initially this is 0. The value of this bit is updated by <a class="el" href="classompl_1_1control_1_1OpenDEStateValidityChecker.html#a2127521f36abfd81f4be598acf19ccd7" title="A state is considered valid if it is within bounds and not in collision. ">OpenDEStateValidityChecker::isValid()</a>. This bit is only used if the <a class="el" href="classompl_1_1control_1_1OpenDEStateValidityChecker.html" title="The simplest state validity checker: all states are valid. ">OpenDEStateValidityChecker</a> is used. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2952bf8638854bd1e33e597713f13b29a217e97a10f0ed7704d9a9123c39d9047"></a>STATE_VALIDITY_VALUE_BIT&#160;</td><td class="fielddoc">
<p>Index of bit in <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace_1_1StateType.html#a4f1a462807534944ca791f1314a42fa8" title="Flag containing information about state validity. ">StateType::collision</a> indicating whether a state is valid or not. Initially the value of this field is unspecified. The value gains meaning (1 or 0) when <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a2952bf8638854bd1e33e597713f13b29a5218d6e48f2d205c2adeb1c62a836f0c" title="Index of bit in StateType::collision indicating whether it is known if a state is in valid or not...">OpenDEStateSpace::STATE_VALIDITY_KNOWN_BIT</a> becomes 1. The value of this bit is updated by OpenDEEnvironment::isValid(). A value of 1 implies that a state is valid. This bit is only used if the <a class="el" href="classompl_1_1control_1_1OpenDEStateValidityChecker.html" title="The simplest state validity checker: all states are valid. ">OpenDEStateValidityChecker</a> is used. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="OpenDEStateSpace_8h_source.html#l00055">55</a> of file <a class="el" href="OpenDEStateSpace_8h_source.html">OpenDEStateSpace.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac84bc49ad1ee3dd74720defe1d68c3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ompl::control::OpenDEStateSpace::OpenDEStateSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1control_1_1OpenDEEnvironmentPtr.html">OpenDEEnvironmentPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>positionWeight</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>linVelWeight</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angVelWeight</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>orientationWeight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a state space representing OpenDE states. </p>
<p>This will be a compound state space with 4 components for each body in <em>env.stateBodies_</em>. The 4 subspaces constructed for each body are: position (R<sup>3</sup>), linear velocity (R<sup>3</sup>), angular velocity (R<sup>3</sup>) and orientation (SO(3)). Default bounds are set by calling <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a508a49bf7883600347f7cdcae4665897" title="By default, the volume bounds enclosing the geometry of the environment are computed to include all o...">setDefaultBounds()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>the environment to construct the state space for </td></tr>
    <tr><td class="paramname">positionWeight</td><td>the weight to pass to CompoundStateSpace::addSubspace() for position subspaces </td></tr>
    <tr><td class="paramname">linVelWeight</td><td>the weight to pass to CompoundStateSpace::addSubspace() for linear velocity subspaces </td></tr>
    <tr><td class="paramname">angVelWeight</td><td>the weight to pass to CompoundStateSpace::addSubspace() for angular velocity subspaces </td></tr>
    <tr><td class="paramname">orientationWeight</td><td>the weight to pass to CompoundStateSpace::addSubspace() for orientation subspaces </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OpenDEStateSpace_8cpp_source.html#l00043">43</a> of file <a class="el" href="OpenDEStateSpace_8cpp_source.html">OpenDEStateSpace.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7c83c791c78bf85d1422e37e1a3487c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::control::OpenDEStateSpace::copyState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a state to another. The memory of source and destination should NOT overlap. </p>
<dl class="section note"><dt>Note</dt><dd>For more advanced state copying methods (partial copy, for example), see <a class="el" href="group__advancedStateCopy.html">Advanced methods for copying states</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a4dbc38743832260896d42d89e0b3feec">ompl::base::CompoundStateSpace</a>.</p>

<p>Definition at line <a class="el" href="OpenDEStateSpace_8cpp_source.html#l00150">150</a> of file <a class="el" href="OpenDEStateSpace_8cpp_source.html">OpenDEStateSpace.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ompl/extensions/opende/<a class="el" href="OpenDEStateSpace_8h_source.html">OpenDEStateSpace.h</a></li>
<li>ompl/extensions/opende/src/<a class="el" href="OpenDEStateSpace_8cpp_source.html">OpenDEStateSpace.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.9.1</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="js/jquery.js"></script>
<script src="js/jquery.powertip.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/dynsections.js"></script>
<script src="js/ompl.js"></script>
</body>
</html>
