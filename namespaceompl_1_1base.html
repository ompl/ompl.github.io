<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.9.1"/>
  <title>ompl::base Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="jquery.js"></script>
  <script src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-expand-md fixed-top navbar-dark">
      <a class="navbar-brand" href="./index.html">OMPL</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
          <li class="nav-item"><a class="nav-link" href="download.html">Download</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="docDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Documentation</a>
            <div class="dropdown-menu" aria-labelledby="docDropdown">
              <a class="dropdown-item" href="https://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a>
              <a class="dropdown-item" href="installation.html">Installation</a>
              <a class="dropdown-item" href="tutorials.html">Tutorials</a>
              <a class="dropdown-item" href="group__demos.html">Demos</a>
              <a class="dropdown-item omplapp" href="gui.html">OMPL.app GUI</a>
              <a class="dropdown-item omplapp" href="webapp.html">OMPL web app</a>
              <a class="dropdown-item" href="python.html">Python Bindings</a>
              <a class="dropdown-item" href="planners.html">Available Planners</a>
              <a class="dropdown-item" href="plannerTerminationConditions.html">Planner Termination Conditions</a>
              <a class="dropdown-item" href="benchmark.html">Benchmarking Planners</a>
              <a class="dropdown-item" href="spaces.html">Available State Spaces</a>
              <a class="dropdown-item" href="optimalPlanning.html">Optimal Planning</a>
              <a class="dropdown-item" href="constrainedPlanning.html">Constrained Planning</a>
              <a class="dropdown-item" href="FAQ.html">FAQ</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">External links</div>
              <a class="dropdown-item" href="http://moveit.ros.org">MoveIt</a>
              <a class="dropdown-item" href="http://plannerarena.org">Planner Arena</a>
              <a class="dropdown-item" href="https://moveit.ros.org//moveit!/ros/2013/05/07/icra-motion-planning-tutorial.html">ICRA 2013 Tutorial</a>
              <a class="dropdown-item" href="http://kavrakilab.org/iros2011/">IROS 2011 Tutorial</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="gallery.html">Gallery</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="codeDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Code</a>
            <div class="dropdown-menu" aria-labelledby="codeDropdown">
              <a class="dropdown-item" href="api_overview.html">API Overview</a>
              <a class="dropdown-item" href="annotated.html">Classes</a>
              <a class="dropdown-item" href="files.html">Files</a>
              <a class="dropdown-item" href="styleGuide.html">Style Guide</a>
              <a class="dropdown-item" href="integration.html">Use OMPL within Other Systems</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">Repositories</div>
              <a class="dropdown-item" href="https://github.com/ompl/ompl">ompl on GitHub</a>
              <a class="dropdown-item" href="https://github.com/ompl/omplapp">omplapp on GitHub</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">Continuous Integration</div>
              <a class="dropdown-item" href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux/macOS)</a>
              <a class="dropdown-item" href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux/macOS)</a>
              <a class="dropdown-item" href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a>
              <a class="dropdown-item" href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://github.com/ompl/ompl/issues">Issues</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="communityDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Community</a>
            <div class="dropdown-menu" aria-labelledby="communityDropdown">
              <a class="dropdown-item" href="support.html">Get Support</a>
              <a class="dropdown-item" href="developers.html">Developers/Contributors</a>
              <a class="dropdown-item" href="contrib.html">Submit a Contribution</a>
              <a class="dropdown-item" href="education.html">Education</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="aboutDropdown" role="button"  data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">About</a>
            <div class="dropdown-menu" aria-labelledby="aboutDropdown">
              <a class="dropdown-item" href="license.html">License</a>
              <a class="dropdown-item" href="citations.html">Citations</a>
              <a class="dropdown-item" href="acknowledgements.html">Acknowledgments</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://ompl.kavrakilab.org/blog.html">Blog</a></li>
        </ul>
                <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </div>
    </nav>
  <div class="container" role="main">
    <div><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceompl.html">ompl</a></li><li class="navelem"><a class="el" href="namespaceompl_1_1base.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ompl::base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains sampling based planning routines shared by both planning under geometric constraints (geometric) and planning under differential constraints (dynamic)  
<a href="namespaceompl_1_1base.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ConstrainedValidStateSampler.html">ConstrainedValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid state sampler for constrained state spaces.  <a href="classompl_1_1base_1_1ConstrainedValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ConstrainedSpaceInformation.html">ConstrainedSpaceInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space information for a constrained state space. Implements more direct for getting motion states.  <a href="classompl_1_1base_1_1ConstrainedSpaceInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1TangentBundleSpaceInformation.html">TangentBundleSpaceInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space information for a tangent bundle-based state space. Implements more direct for getting motion states and checking motion, as the lazy approach requires post-processing.  <a href="classompl_1_1base_1_1TangentBundleSpaceInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1Constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a differentiable holonomic constraint on a configuration space. See <a class="el" href="constrainedPlanning.html">Constrained Planning</a> for more details.  <a href="classompl_1_1base_1_1Constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ConstraintIntersection.html">ConstraintIntersection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a constraint composed of multiple constraints that all must be satisfied simultaneously. This class &lsquo;stacks&rsquo; the constraint functions together.  <a href="classompl_1_1base_1_1ConstraintIntersection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ConstraintObjective.html">ConstraintObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="classompl_1_1base_1_1Constraint.html" title="Definition of a differentiable holonomic constraint on a configuration space. See Constrained Plannin...">ompl::base::Constraint</a> to use as an optimization objective.  <a href="classompl_1_1base_1_1ConstraintObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a cost value. Can represent the cost of a motion or the cost of a state.  <a href="classompl_1_1base_1_1Cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DiscreteMotionValidator.html">DiscreteMotionValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A motion validator that only uses the state validity checker. Motions are checked for validity at a specified resolution.  <a href="classompl_1_1base_1_1DiscreteMotionValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GenericParam.html">GenericParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Motion planning algorithms often employ parameters to guide their exploration process. (e.g., goal biasing). Motion planners (and some of their components) use this class to declare what the parameters are, in a generic way, so that they can be set externally.  <a href="classompl_1_1base_1_1GenericParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SpecificParam.html">SpecificParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper class that instantiates parameters with different data types.  <a href="classompl_1_1base_1_1SpecificParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a set of parameters.  <a href="classompl_1_1base_1_1ParamSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1Goal.html">Goal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of goals.  <a href="classompl_1_1base_1_1Goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GoalLazySamples.html">GoalLazySamples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a goal region that can be sampled, but the sampling process can be slow. This class allows sampling the happen in a separate thread, and the number of goals may increase, as the planner is running, in a thread-safe manner.  <a href="classompl_1_1base_1_1GoalLazySamples.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GoalRegion.html">GoalRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a goal region.  <a href="classompl_1_1base_1_1GoalRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GoalSampleableRegion.html">GoalSampleableRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of a goal region that can be sampled.  <a href="classompl_1_1base_1_1GoalSampleableRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GoalSpace.html">GoalSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a goal space, i.e., a subspace of the problem state space that defines the goal.  <a href="classompl_1_1base_1_1GoalSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GoalState.html">GoalState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a goal state.  <a href="classompl_1_1base_1_1GoalState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GoalStates.html">GoalStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a set of goal states.  <a href="classompl_1_1base_1_1GoalStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MotionValidator.html">MotionValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition for a class checking the validity of motions &ndash; path segments between states. This is often called a local planner. The implementation of this class must be thread safe.  <a href="classompl_1_1base_1_1MotionValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MaximizeMinClearanceObjective.html">MaximizeMinClearanceObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objective for attempting to maximize the minimum clearance along a path.  <a href="classompl_1_1base_1_1MaximizeMinClearanceObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MechanicalWorkOptimizationObjective.html">MechanicalWorkOptimizationObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimization objective which defines path cost using the idea of mechanical work. To be used in conjunction with TRRT.  <a href="classompl_1_1base_1_1MechanicalWorkOptimizationObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MinimaxObjective.html">MinimaxObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost of a path is defined as the worst state cost over the entire path. This objective attempts to find the path with the "best worst cost" over all paths.  <a href="classompl_1_1base_1_1MinimaxObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PathLengthOptimizationObjective.html">PathLengthOptimizationObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimization objective which corresponds to optimizing path length.  <a href="classompl_1_1base_1_1PathLengthOptimizationObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html">StateCostIntegralObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines optimization objectives where path cost can be represented as a path integral over a cost function defined over the state space. This cost function is specified by implementing the <a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html#ad8e2fb06a89783826cfb62e706e125f0" title="Returns a cost with a value of 1.">stateCost()</a> method.  <a href="classompl_1_1base_1_1StateCostIntegralObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1VFMechanicalWorkOptimizationObjective.html">VFMechanicalWorkOptimizationObjective</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1VFUpstreamCriterionOptimizationObjective.html">VFUpstreamCriterionOptimizationObjective</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of optimization objectives.  <a href="classompl_1_1base_1_1OptimizationObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html">MultiOptimizationObjective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for the definition of multiobjective optimal planning problems. Objectives are added to this compound object, and motion costs are computed by taking a weighted sum of the individual objective costs.  <a href="classompl_1_1base_1_1MultiOptimizationObjective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1Path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of a path.  <a href="classompl_1_1base_1_1Path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerInputStates.html">PlannerInputStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to extract valid start &amp; goal states. Usually used internally by planners.  <a href="classompl_1_1base_1_1PlannerInputStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1PlannerSpecs.html">PlannerSpecs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties that planners may have.  <a href="structompl_1_1base_1_1PlannerSpecs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1Planner.html">Planner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a planner.  <a href="classompl_1_1base_1_1Planner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a vertex in the <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> structure. All derived classes must implement the clone and equivalence operators. It is assumed that each vertex in the <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> structure is unique (i.e. no duplicates allowed).  <a href="classompl_1_1base_1_1PlannerDataVertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> edge.  <a href="classompl_1_1base_1_1PlannerDataEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing planner generated vertex and edge data. It is assumed that all vertices are unique, and only a single directed edge connects two vertices.  <a href="classompl_1_1base_1_1PlannerData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerDataStorage.html">PlannerDataStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that handles loading/storing a <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> object to/from a binary stream. Serialization of vertices and edges is performed using the Boost archive method <em>serialize</em>. Derived vertex/edge classes are handled, presuming those classes implement the <em>serialize</em> method.  <a href="classompl_1_1base_1_1PlannerDataStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1PlannerStatus.html">PlannerStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to store the exit status of <a class="el" href="classompl_1_1base_1_1Planner.html#aea8c56d18a0326b10fd111872ebd674a" title="Function that can solve the motion planning problem. This function can be called multiple times on th...">Planner::solve()</a>  <a href="structompl_1_1base_1_1PlannerStatus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate a termination condition for a motion planner. Planners will call operator() to decide whether they should terminate before a solution is found or not. operator() will return true if either the implemented condition is met (the call to <a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html#a152fa2dc47d52eac57063dc93882559e" title="The implementation of some termination condition. By default, this just calls fn_()">eval()</a> returns true) or if the user called terminate(true).  <a href="classompl_1_1base_1_1PlannerTerminationCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PrecomputedStateSampler.html">PrecomputedStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space sampler for discrete states.  <a href="classompl_1_1base_1_1PrecomputedStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1PlannerSolution.html">PlannerSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a solution to a planning problem.  <a href="structompl_1_1base_1_1PlannerSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ProblemDefinition.html">ProblemDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a problem to be solved. This includes the start state(s) for the system and a goal specification. Will contain solutions, if found. <br  />
  <a href="classompl_1_1base_1_1ProblemDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ProjectionMatrix.html">ProjectionMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A projection matrix &ndash; it allows multiplication of real vectors by a specified matrix. The matrix can also be randomly generated.  <a href="classompl_1_1base_1_1ProjectionMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ProjectionEvaluator.html">ProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition for a class computing projections to R<sup>n</sup>. Implicit integer grids are imposed on this projection space by setting cell sizes. Before use, the user must supply cell sizes for the integer grid (<a class="el" href="classompl_1_1base_1_1ProjectionEvaluator.html#a159e26be9f83a75a001ad2d3ba477f71" title="Define the size (in each dimension) of a grid cell. The number of sizes set here must be the same as ...">setCellSizes()</a>). The implementation of this class is thread safe.  <a href="classompl_1_1base_1_1ProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SubspaceProjectionEvaluator.html">SubspaceProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the projection for a <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html" title="A space to allow the composition of state spaces.">CompoundStateSpace</a> is supposed to be the same as the one for one of its included subspaces, this class facilitates selecting a projection of that subspace.  <a href="classompl_1_1base_1_1SubspaceProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1BridgeTestValidStateSampler.html">BridgeTestValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate valid samples using bridge test. First sample an invalid state, then sample another invalid state. Take the midpoint of those samples. If midpoint is valid, return. If midpoint is invalid continue.  <a href="classompl_1_1base_1_1BridgeTestValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DeterministicSequence.html">DeterministicSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for deterministic sequences in arbitrary dimensions.  <a href="classompl_1_1base_1_1DeterministicSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1HaltonSequence1D.html">HaltonSequence1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realization of the Halton sequence for the generation of arbitrary dimensional, low-dispersion sequences.  <a href="classompl_1_1base_1_1HaltonSequence1D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1HaltonSequence.html">HaltonSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realization of the Halton sequence for the generation of arbitrary dimensional, low-dispersion sequences.  <a href="classompl_1_1base_1_1HaltonSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PrecomputedSequence.html">PrecomputedSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General realization for a sampler of precomputed sequences or sets.  <a href="classompl_1_1base_1_1PrecomputedSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DeterministicStateSampler.html">DeterministicStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for the concept of using deterministic sampling sequences to decrease the dispersion of the samples.  <a href="classompl_1_1base_1_1DeterministicStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SO2DeterministicStateSampler.html">SO2DeterministicStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministic state space sampler for SO(2)  <a href="classompl_1_1base_1_1SO2DeterministicStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorDeterministicStateSampler.html">RealVectorDeterministicStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministic state sampler for the R<sup>n</sup> state space.  <a href="classompl_1_1base_1_1RealVectorDeterministicStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SE2DeterministicStateSampler.html">SE2DeterministicStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministic state sampler for the R<sup>n</sup> state space.  <a href="classompl_1_1base_1_1SE2DeterministicStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1GaussianValidStateSampler.html">GaussianValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate valid samples using the Gaussian sampling strategy.  <a href="classompl_1_1base_1_1GaussianValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1OrderedInfSampler.html">OrderedInfSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An informed sampler wrapper that generates <em>m</em> samples and then returns them in order of the heuristic.  <a href="classompl_1_1base_1_1OrderedInfSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PathLengthDirectInfSampler.html">PathLengthDirectInfSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An informed sampler for problems seeking to minimize path length.  <a href="classompl_1_1base_1_1PathLengthDirectInfSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RejectionInfSampler.html">RejectionInfSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default rejection sampling scheme that samples uniformly from the entire planning domain. Samples are rejected until one is found that has a heuristic solution estimate that is less than the current solution. In general, direct sampling of the informed subset is much better, but this is a general default.  <a href="classompl_1_1base_1_1RejectionInfSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1InformedSampler.html">InformedSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for the concept of using information about the state space and the current solution cost to limit future search to a planning subproblem that contains all possibly better solutions.  <a href="classompl_1_1base_1_1InformedSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1InformedStateSampler.html">InformedStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class that allows an <a class="el" href="classompl_1_1base_1_1InformedSampler.html" title="An abstract class for the concept of using information about the state space and the current solution...">InformedSampler</a> to be used as a <a class="el" href="classompl_1_1base_1_1StateSampler.html" title="Abstract definition of a state space sampler.">StateSampler</a>.  <a href="classompl_1_1base_1_1InformedStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MaximizeClearanceValidStateSampler.html">MaximizeClearanceValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate valid samples randomly, but with a bias towards higher clearance.  <a href="classompl_1_1base_1_1MaximizeClearanceValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MinimumClearanceValidStateSampler.html">MinimumClearanceValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate valid samples randomly with extra requirement of min for clearance to nearest obstacle.  <a href="classompl_1_1base_1_1MinimumClearanceValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ObstacleBasedValidStateSampler.html">ObstacleBasedValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate valid samples using obstacle based sampling. First sample an invalid state, then sample a valid state. Then, interpolate from the invalid state to the valid state, returning the first valid state encountered.  <a href="classompl_1_1base_1_1ObstacleBasedValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1UniformValidStateSampler.html">UniformValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state sampler that only samples valid states, uniformly.  <a href="classompl_1_1base_1_1UniformValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a scoped state.  <a href="classompl_1_1base_1_1ScopedState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SolutionNonExistenceProof.html">SolutionNonExistenceProof</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of a proof for the non-existence of a solution to a problem.  <a href="classompl_1_1base_1_1SolutionNonExistenceProof.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SpaceInformation.html">SpaceInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for space information. This contains all the information about the space planning is done in. <a class="el" href="classompl_1_1base_1_1SpaceInformation.html#a6e8c41f946c3c04d126983e145404ad4" title="Perform additional setup tasks (run once, before use). If state validity checking resolution has not ...">setup()</a> needs to be called as well, before use.  <a href="classompl_1_1base_1_1SpaceInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1AtlasChart.html">AtlasChart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tangent space and bounding polytope approximating some patch of the manifold.  <a href="classompl_1_1base_1_1AtlasChart.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1AtlasStateSampler.html">AtlasStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1StateSampler.html" title="Abstract definition of a state space sampler.">StateSampler</a> for use on an atlas.  <a href="classompl_1_1base_1_1AtlasStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1AtlasStateSpace.html">AtlasStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1ConstrainedStateSpace.html" title="A StateSpace that has a Constraint imposed upon it. Underlying space functions are passed to the ambi...">ConstrainedStateSpace</a> encapsulating a planner-agnostic atlas algorithm for planning on a constraint manifold.  <a href="classompl_1_1base_1_1AtlasStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ConstrainedMotionValidator.html">ConstrainedMotionValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained configuration space specific implementation of <a class="el" href="classompl_1_1base_1_1ConstrainedMotionValidator.html#a534eb8dfda829df2da4795352bc48d62" title="Return whether we can step from s1 to s2 along the manifold without collision.">checkMotion()</a> that uses discreteGeodesic().  <a href="classompl_1_1base_1_1ConstrainedMotionValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ConstrainedStateSpace.html">ConstrainedStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classompl_1_1base_1_1StateSpace.html" title="Representation of a space in which planning can be performed. Topology specific sampling,...">StateSpace</a> that has a <em><a class="el" href="classompl_1_1base_1_1Constraint.html" title="Definition of a differentiable holonomic constraint on a configuration space. See Constrained Plannin...">Constraint</a></em> imposed upon it. Underlying space functions are passed to the ambient space, and the constraint is used to inform any manifold related operations. <a class="el" href="classompl_1_1base_1_1ConstrainedStateSpace.html#a349cdde886586bc63b243c49176650ba" title="Sets the space information for this state space. Required for collision checking in manifold traversa...">setSpaceInformation()</a> must be called in order for collision checking to be done in tandem with manifold traversal.  <a href="classompl_1_1base_1_1ConstrainedStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ProjectedStateSampler.html">ProjectedStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1StateSampler.html" title="Abstract definition of a state space sampler.">StateSampler</a> for use for a projection-based state space.  <a href="classompl_1_1base_1_1ProjectedStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ProjectedStateSpace.html">ProjectedStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1ConstrainedStateSpace.html" title="A StateSpace that has a Constraint imposed upon it. Underlying space functions are passed to the ambi...">ConstrainedStateSpace</a> encapsulating a projection-based methodology for planning with constraints.  <a href="classompl_1_1base_1_1ProjectedStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1TangentBundleStateSpace.html">TangentBundleStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1ConstrainedStateSpace.html" title="A StateSpace that has a Constraint imposed upon it. Underlying space functions are passed to the ambi...">ConstrainedStateSpace</a> encapsulating a planner-agnostic lazy atlas algorithm for planning on a constraint manifold.  <a href="classompl_1_1base_1_1TangentBundleStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DiscreteStateSampler.html">DiscreteStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space sampler for discrete states.  <a href="classompl_1_1base_1_1DiscreteStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DiscreteStateSpace.html">DiscreteStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A space representing discrete states; i.e. there are a small number of discrete states the system can be in. States are represented as integers [lowerBound, upperBound], where lowerBound and upperBound are inclusive. States do not wrap around; i.e. the distance between state lowerBound and state upperBound is upperBound-lowerBound. The dimension of the space is 1.  <a href="classompl_1_1base_1_1DiscreteStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DubinsStateSpace.html">DubinsStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An SE(2) state space where distance is measured by the length of Dubins curves.  <a href="classompl_1_1base_1_1DubinsStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1DubinsMotionValidator.html">DubinsMotionValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Dubins motion validator that only uses the state validity checker. Motions are checked for validity at a specified resolution.  <a href="classompl_1_1base_1_1DubinsMotionValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorBounds.html">RealVectorBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lower and upper bounds for an R<sup>n</sup> space.  <a href="classompl_1_1base_1_1RealVectorBounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorLinearProjectionEvaluator.html">RealVectorLinearProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for a class computing linear projections (multiplication of a k-by-n matrix to the the R<sup>n</sup> vector state to produce an R<sup>k</sup> projection. The multiplication matrix needs to be supplied as input.  <a href="classompl_1_1base_1_1RealVectorLinearProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorRandomLinearProjectionEvaluator.html">RealVectorRandomLinearProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for a class computing a random linear projections.  <a href="classompl_1_1base_1_1RealVectorRandomLinearProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorOrthogonalProjectionEvaluator.html">RealVectorOrthogonalProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for a class computing orthogonal projections.  <a href="classompl_1_1base_1_1RealVectorOrthogonalProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorIdentityProjectionEvaluator.html">RealVectorIdentityProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the identity projection.  <a href="classompl_1_1base_1_1RealVectorIdentityProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorStateSampler.html">RealVectorStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> sampler for the R<sup>n</sup> state space.  <a href="classompl_1_1base_1_1RealVectorStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html">RealVectorStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state space representing R<sup>n</sup>. The distance function is the L2 norm.  <a href="classompl_1_1base_1_1RealVectorStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ReedsSheppStateSpace.html">ReedsSheppStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An SE(2) state space where distance is measured by the length of Reeds-Shepp curves.  <a href="classompl_1_1base_1_1ReedsSheppStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ReedsSheppMotionValidator.html">ReedsSheppMotionValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Reeds-Shepp motion validator that only uses the state validity checker. Motions are checked for validity at a specified resolution.  <a href="classompl_1_1base_1_1ReedsSheppMotionValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SE2StateSpace.html">SE2StateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state space representing SE(2)  <a href="classompl_1_1base_1_1SE2StateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SE3StateSpace.html">SE3StateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state space representing SE(3)  <a href="classompl_1_1base_1_1SE3StateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SO2StateSampler.html">SO2StateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space sampler for SO(2)  <a href="classompl_1_1base_1_1SO2StateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SO2StateSpace.html">SO2StateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state space representing SO(2). The distance function and interpolation take into account angle wrapping.  <a href="classompl_1_1base_1_1SO2StateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SO3StateSampler.html">SO3StateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space sampler for SO(3), using quaternion representation <br  />
  <a href="classompl_1_1base_1_1SO3StateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SO3StateSpace.html">SO3StateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state space representing SO(3). The internal representation is done with quaternions. The distance between states is the angle between quaternions and interpolation is done with slerp.  <a href="classompl_1_1base_1_1SO3StateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1TimeStateSampler.html">TimeStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space sampler for time.  <a href="classompl_1_1base_1_1TimeStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1TimeStateSpace.html">TimeStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state space representing time. The time can be unbounded, in which case <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#aff534c8e8dff15a5e59b3d5f8b0565ec" title="Bring the state within the bounds of the state space. For unbounded spaces this function can be a no-...">enforceBounds()</a> is a no-op, <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#a2bca408a7dbafe47c97d170315713f38" title="Check if a state is inside the bounding box. For unbounded spaces this function can always return tru...">satisfiesBounds()</a> always returns true, sampling uniform time states always produces time 0 and <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#ac2a803430f9572eb1f584b35f241449a" title="Get the maximum value a call to distance() can return (or an upper bound). For unbounded state spaces...">getMaximumExtent()</a> returns 1. If time is bounded (<a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#a3c51355b0e7e620ba7da19c85cac93ee" title="Set the minimum and maximum time bounds. This will make the state space switch into bounded time mode...">setBounds()</a> has been previously called), the state space behaves as expected. After construction, the state space is unbounded. <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#a34eda726ecc4000eff1e5b521753202b" title="Check if the time is bounded or not.">isBounded()</a> can be used to check if the state space is bounded or not.  <a href="classompl_1_1base_1_1TimeStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1WrapperStateSampler.html">WrapperStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state sampler that wraps around another state sampler.  <a href="classompl_1_1base_1_1WrapperStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1WrapperProjectionEvaluator.html">WrapperProjectionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A projection evaluator that wraps around another projection evaluator.  <a href="classompl_1_1base_1_1WrapperProjectionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1WrapperStateSpace.html">WrapperStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space wrapper that transparently passes state space operations through to the underlying space. Allows augmentation of state spaces with additional information.  <a href="classompl_1_1base_1_1WrapperStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1State.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of an abstract state.  <a href="classompl_1_1base_1_1State.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundState.html">CompoundState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a compound state.  <a href="classompl_1_1base_1_1CompoundState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSampler.html">StateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of a state space sampler.  <a href="classompl_1_1base_1_1StateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSampler.html">CompoundStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a compound state sampler. This is useful to construct samplers for compound states.  <a href="classompl_1_1base_1_1CompoundStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1SubspaceStateSampler.html">SubspaceStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sampler that samples only within a subspace of the space.  <a href="classompl_1_1base_1_1SubspaceStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1SamplerSelector.html">SamplerSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depending on the type of state sampler, we have different allocation routines.  <a href="structompl_1_1base_1_1SamplerSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSamplerArray.html">StateSamplerArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to ease the creation of a set of samplers. This is especially useful for multi-threaded planners.  <a href="classompl_1_1base_1_1StateSamplerArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a space in which planning can be performed. Topology specific sampling, interpolation and distance are defined.  <a href="classompl_1_1base_1_1StateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html">CompoundStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A space to allow the composition of state spaces.  <a href="classompl_1_1base_1_1CompoundStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateStorage.html">StateStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage loading and storing for a set of states of a specified state space.  <a href="classompl_1_1base_1_1StateStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateStorageWithMetadata.html">StateStorageWithMetadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> storage that allows storing state metadata as well.  <a href="classompl_1_1base_1_1StateStorageWithMetadata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1StateValidityCheckerSpecs.html">StateValidityCheckerSpecs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties that a state validity checker may have.  <a href="structompl_1_1base_1_1StateValidityCheckerSpecs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateValidityChecker.html">StateValidityChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition for a class checking the validity of states. The implementation of this class must be thread safe.  <a href="classompl_1_1base_1_1StateValidityChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1AllValidStateValidityChecker.html">AllValidStateValidityChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest state validity checker: all states are valid.  <a href="classompl_1_1base_1_1AllValidStateValidityChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CostConvergenceTerminationCondition.html">CostConvergenceTerminationCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">: A termination condition for stopping an optimizing planner based on cost convergence  <a href="classompl_1_1base_1_1CostConvergenceTerminationCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1IterationTerminationCondition.html">IterationTerminationCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to run a planner for a specific number of iterations. Casts to a PTC for use with <a class="el" href="classompl_1_1base_1_1Planner.html#aea8c56d18a0326b10fd111872ebd674a" title="Function that can solve the motion planning problem. This function can be called multiple times on th...">Planner::solve</a>.  <a href="classompl_1_1base_1_1IterationTerminationCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1TypedSpaceInformation.html">TypedSpaceInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1TypedStateValidityChecker.html">TypedStateValidityChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1ValidStateSampler.html">ValidStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of a state sampler.  <a href="classompl_1_1base_1_1ValidStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MorseEnvironment.html">MorseEnvironment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the MORSE constructs OMPL needs to know about when planning.  <a href="classompl_1_1base_1_1MorseEnvironment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MorseGoal.html">MorseGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a goal class that is more amenable to Python <br  />
  <a href="classompl_1_1base_1_1MorseGoal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MorseProjection.html">MorseProjection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a generic projection for the <a class="el" href="classompl_1_1base_1_1MorseStateSpace.html" title="State space representing MORSE states.">MorseStateSpace</a>, namely, the subspace representing the x and y positions of every rigid body.  <a href="classompl_1_1base_1_1MorseProjection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MorseStateSpace.html">MorseStateSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space representing MORSE states.  <a href="classompl_1_1base_1_1MorseStateSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MorseStateValidityChecker.html">MorseStateValidityChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest state validity checker: all states are valid if they are within bounds.  <a href="classompl_1_1base_1_1MorseStateValidityChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1MorseTerminationCondition.html">MorseTerminationCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a termination condition for the planner that only terminates if the user shuts down the MORSE simulation.  <a href="classompl_1_1base_1_1MorseTerminationCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CForestStateSampler.html">CForestStateSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended state sampler to use with the CForest planning algorithm. It wraps the user-specified state sampler.  <a href="classompl_1_1base_1_1CForestStateSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html">CForestStateSpaceWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> space wrapper to use together with CForest. It adds some functionalities to the regular state spaces necessary to CForest.  <a href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerDataVertexAnnotated.html">PlannerDataVertexAnnotated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An annotated vertex, adding information about its level in the quotient-space hiearchy, the maxlevel of quotientspaces and the component it belongs to.  <a href="classompl_1_1base_1_1PlannerDataVertexAnnotated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a48de5cc2d74ab81ac4d302045ed5f06b"><td class="memItemLeft" align="right" valign="top"><a id="a48de5cc2d74ab81ac4d302045ed5f06b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a48de5cc2d74ab81ac4d302045ed5f06b">GoalSamplingFn</a> = std::function&lt; bool(const <a class="el" href="classompl_1_1base_1_1GoalLazySamples.html">GoalLazySamples</a> *, <a class="el" href="classompl_1_1base_1_1State.html">State</a> *)&gt;</td></tr>
<tr class="memdesc:a48de5cc2d74ab81ac4d302045ed5f06b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classompl_1_1base_1_1Goal.html" title="Abstract definition of goals.">Goal</a> sampling function. Returns false when no further calls should be made to it. Fills its second argument (the state) with the sampled goal state. This function need not be thread safe. <br /></td></tr>
<tr class="separator:a48de5cc2d74ab81ac4d302045ed5f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283e06df73e9f4dd5e6774c19b0b5ed5"><td class="memItemLeft" align="right" valign="top"><a id="a283e06df73e9f4dd5e6774c19b0b5ed5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a283e06df73e9f4dd5e6774c19b0b5ed5">CostToGoHeuristic</a> = std::function&lt; <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>(const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *, const <a class="el" href="classompl_1_1base_1_1Goal.html">Goal</a> *)&gt;</td></tr>
<tr class="memdesc:a283e06df73e9f4dd5e6774c19b0b5ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a function which returns an admissible estimate of the optimal path cost from a given state to a goal. <br /></td></tr>
<tr class="separator:a283e06df73e9f4dd5e6774c19b0b5ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301d8c702c92a85d73832f79cb989ee5"><td class="memItemLeft" align="right" valign="top"><a id="a301d8c702c92a85d73832f79cb989ee5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a301d8c702c92a85d73832f79cb989ee5">PlannerAllocator</a> = std::function&lt; <a class="el" href="classompl_1_1base_1_1PlannerPtr.html">PlannerPtr</a>(const <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a301d8c702c92a85d73832f79cb989ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a function that can allocate a planner. <br /></td></tr>
<tr class="separator:a301d8c702c92a85d73832f79cb989ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c218cde462780a4502dfc561708e903"><td class="memItemLeft" align="right" valign="top"><a id="a5c218cde462780a4502dfc561708e903"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a5c218cde462780a4502dfc561708e903">PlannerTerminationConditionFn</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="memdesc:a5c218cde462780a4502dfc561708e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for functions that decide whether termination conditions have been met for a planner, even if no solution is found. This is usually reaching a time or memory limit. If the function returns true, the planner is signaled to terminate its computation. Otherwise, computation continues while this function returns false, until a solution is found. <br /></td></tr>
<tr class="separator:a5c218cde462780a4502dfc561708e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2654ca90af54f839e5aa8936f1e23351"><td class="memItemLeft" align="right" valign="top"><a id="a2654ca90af54f839e5aa8936f1e23351"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a2654ca90af54f839e5aa8936f1e23351">ReportIntermediateSolutionFn</a> = std::function&lt; void(const <a class="el" href="classompl_1_1base_1_1Planner.html">Planner</a> *, const std::vector&lt; const <a class="el" href="classompl_1_1base_1_1State.html">base::State</a> * &gt; &amp;, const <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>)&gt;</td></tr>
<tr class="memdesc:a2654ca90af54f839e5aa8936f1e23351"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a planner has an intermediate solution (e.g., optimizing planners), a function with this signature can be called to report the states of that solution. <br /></td></tr>
<tr class="separator:a2654ca90af54f839e5aa8936f1e23351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de6e14c387f69a1f6c0ea4e6109464f"><td class="memItemLeft" align="right" valign="top"><a id="a1de6e14c387f69a1f6c0ea4e6109464f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a1de6e14c387f69a1f6c0ea4e6109464f">ScopedStatePtr</a> = std::shared_ptr&lt; <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a1de6e14c387f69a1f6c0ea4e6109464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a ScopedState&lt;&gt; <br /></td></tr>
<tr class="separator:a1de6e14c387f69a1f6c0ea4e6109464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd31d19ef5b789b0bff97bf6e249ebf"><td class="memItemLeft" align="right" valign="top"><a id="a7cd31d19ef5b789b0bff97bf6e249ebf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a7cd31d19ef5b789b0bff97bf6e249ebf">StateValidityCheckerFn</a> = std::function&lt; bool(const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *)&gt;</td></tr>
<tr class="memdesc:a7cd31d19ef5b789b0bff97bf6e249ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no state validity checking class is specified (<a class="el" href="classompl_1_1base_1_1StateValidityChecker.html" title="Abstract definition for a class checking the validity of states. The implementation of this class mus...">StateValidityChecker</a>), a std::function can be specified instead. <br /></td></tr>
<tr class="separator:a7cd31d19ef5b789b0bff97bf6e249ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729f324a0a979bd7087e3d279bbdd77e"><td class="memItemLeft" align="right" valign="top"><a id="a729f324a0a979bd7087e3d279bbdd77e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a729f324a0a979bd7087e3d279bbdd77e">StateSamplerAllocator</a> = std::function&lt; <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>(const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *)&gt;</td></tr>
<tr class="memdesc:a729f324a0a979bd7087e3d279bbdd77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a function that can allocate a state sampler. <br /></td></tr>
<tr class="separator:a729f324a0a979bd7087e3d279bbdd77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8d5c8d351d2337f79cabe4ee1f51dd"><td class="memItemLeft" align="right" valign="top"><a id="aeb8d5c8d351d2337f79cabe4ee1f51dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#aeb8d5c8d351d2337f79cabe4ee1f51dd">GraphStateStorage</a> = <a class="el" href="classompl_1_1base_1_1StateStorageWithMetadata.html">StateStorageWithMetadata</a>&lt; std::vector&lt; std::size_t &gt; &gt;</td></tr>
<tr class="memdesc:aeb8d5c8d351d2337f79cabe4ee1f51dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of states where the metadata is a vector of indices. This is is typically used to store a graph. <br /></td></tr>
<tr class="separator:aeb8d5c8d351d2337f79cabe4ee1f51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394596dbc2dc38328eb7d8bee15874c"><td class="memItemLeft" align="right" valign="top"><a id="a6394596dbc2dc38328eb7d8bee15874c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GraphStateStoragePtr</b> = std::shared_ptr&lt; <a class="el" href="namespaceompl_1_1base.html#aeb8d5c8d351d2337f79cabe4ee1f51dd">GraphStateStorage</a> &gt;</td></tr>
<tr class="separator:a6394596dbc2dc38328eb7d8bee15874c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1d1e8c2e70b9876dd5621027eb19f4"><td class="memItemLeft" align="right" valign="top"><a id="afe1d1e8c2e70b9876dd5621027eb19f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#afe1d1e8c2e70b9876dd5621027eb19f4">ValidStateSamplerAllocator</a> = std::function&lt; <a class="el" href="classompl_1_1base_1_1ValidStateSamplerPtr.html">ValidStateSamplerPtr</a>(const <a class="el" href="classompl_1_1base_1_1SpaceInformation.html">SpaceInformation</a> *)&gt;</td></tr>
<tr class="memdesc:afe1d1e8c2e70b9876dd5621027eb19f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a function that can allocate a valid state sampler. <br /></td></tr>
<tr class="separator:afe1d1e8c2e70b9876dd5621027eb19f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1620a159019faf720c550eeca5723f55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55">GoalType</a> { <br />
&#160;&#160;<a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55a63728e6f4a505262163e918202bd1785">GOAL_ANY</a> = 1
, <a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55a45bf52626bee439d29a04158d867a979">GOAL_REGION</a> = GOAL_ANY + 2
, <a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55a6fb685fa51055688c4e130094225b7f9">GOAL_SAMPLEABLE_REGION</a> = GOAL_REGION + 4
, <a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55a451d783254d6bb398c15495e87bc1b86">GOAL_STATE</a> = GOAL_SAMPLEABLE_REGION + 8
, <br />
&#160;&#160;<a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55a80679771e14cf79b8baf3e5ecae20142">GOAL_STATES</a> = GOAL_SAMPLEABLE_REGION + 16
, <a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55a15dee78752265020cab91cf866fee69d">GOAL_LAZY_SAMPLES</a> = GOAL_STATES + 32
<br />
 }</td></tr>
<tr class="memdesc:a1620a159019faf720c550eeca5723f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of goal.  <a href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55">More...</a><br /></td></tr>
<tr class="separator:a1620a159019faf720c550eeca5723f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66678b1f585228b1da65ed979c98211"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__advancedStateCopy.html#gaa66678b1f585228b1da65ed979c98211">AdvancedStateCopyOperation</a> { <a class="el" href="group__advancedStateCopy.html#ggaa66678b1f585228b1da65ed979c98211a6a78901c9c5abb5764843684670e231d">NO_DATA_COPIED</a> = 0
, <a class="el" href="group__advancedStateCopy.html#ggaa66678b1f585228b1da65ed979c98211a6068072d46749cddb0526c9f2eb9796b">SOME_DATA_COPIED</a> = 1
, <a class="el" href="group__advancedStateCopy.html#ggaa66678b1f585228b1da65ed979c98211a1dde9fa1931003165d3821f133337e69">ALL_DATA_COPIED</a> = 2
 }</td></tr>
<tr class="memdesc:gaa66678b1f585228b1da65ed979c98211"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible outputs for an advanced copy operation.  <a href="group__advancedStateCopy.html#gaa66678b1f585228b1da65ed979c98211">More...</a><br /></td></tr>
<tr class="separator:gaa66678b1f585228b1da65ed979c98211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b022e14fe04a75f81789947353920"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920">StateSpaceType</a> { <br />
&#160;&#160;<a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920a4247bd6859b13c6482caed7f9dd9996d">STATE_SPACE_UNKNOWN</a> = 0
, <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920abb95f16481daa006d055bad7060b8fbb">STATE_SPACE_REAL_VECTOR</a> = 1
, <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920aca07fe8d9ce9fe45ad5d1b2d90c8c1fc">STATE_SPACE_SO2</a> = 2
, <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920ae9ec8f7cf5204246a32a44768d843fb1">STATE_SPACE_SO3</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920a197336a12b06210c42899c5b53c298b1">STATE_SPACE_SE2</a> = 4
, <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920acc8d4a06096c378b5473fe4caf8171f8">STATE_SPACE_SE3</a> = 5
, <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920afc515ecf796d311c9ae7ae879fb63158">STATE_SPACE_TIME</a> = 6
, <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920a56b36a6f5b0a8ae48be0baa7e348def3">STATE_SPACE_DISCRETE</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920aa011308faae02860d3e6fe26be28c167">STATE_SPACE_TYPE_COUNT</a>
<br />
 }</td></tr>
<tr class="memdesc:a056b022e14fe04a75f81789947353920"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a state space.  <a href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920">More...</a><br /></td></tr>
<tr class="separator:a056b022e14fe04a75f81789947353920"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5708f022c6261accef3b9c0fb4d96f90"><td class="memItemLeft" align="right" valign="top"><a id="a5708f022c6261accef3b9c0fb4d96f90"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a5708f022c6261accef3b9c0fb4d96f90">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a> c)</td></tr>
<tr class="memdesc:a5708f022c6261accef3b9c0fb4d96f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for <a class="el" href="classompl_1_1base_1_1Cost.html" title="Definition of a cost value. Can represent the cost of a motion or the cost of a state.">Cost</a>. <br /></td></tr>
<tr class="separator:a5708f022c6261accef3b9c0fb4d96f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009050ed9b663bc4d6d4dbbee94c40b8"><td class="memItemLeft" align="right" valign="top"><a id="a009050ed9b663bc4d6d4dbbee94c40b8"></a>
<a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a009050ed9b663bc4d6d4dbbee94c40b8">goalRegionCostToGo</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="classompl_1_1base_1_1Goal.html">Goal</a> *goal)</td></tr>
<tr class="memdesc:a009050ed9b663bc4d6d4dbbee94c40b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use when the cost-to-go of a state under the optimization objective is equivalent to the goal region's distanceGoal() . This function assumes that all states within the goal region's threshold have a cost-to-go of exactly zero. Note: <em>goal</em> is assumed to be of type <a class="el" href="classompl_1_1base_1_1GoalRegion.html" title="Definition of a goal region.">ompl::base::GoalRegion</a>. <br /></td></tr>
<tr class="separator:a009050ed9b663bc4d6d4dbbee94c40b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac52d1250b648cdc3ae2ae59591f52f"><td class="memItemLeft" align="right" valign="top"><a id="a5ac52d1250b648cdc3ae2ae59591f52f"></a>
<a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a5ac52d1250b648cdc3ae2ae59591f52f">operator+</a> (const <a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a> &amp;a, const <a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a5ac52d1250b648cdc3ae2ae59591f52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two optimization objectives, returns a <a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html" title="This class allows for the definition of multiobjective optimal planning problems. Objectives are adde...">MultiOptimizationObjective</a> that combines the two objectives with both weights equal to 1.0. <br /></td></tr>
<tr class="separator:a5ac52d1250b648cdc3ae2ae59591f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3369908c62475f826046ed5b3e934e"><td class="memItemLeft" align="right" valign="top"><a id="aba3369908c62475f826046ed5b3e934e"></a>
<a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#aba3369908c62475f826046ed5b3e934e">operator*</a> (double weight, const <a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a> &amp;a)</td></tr>
<tr class="memdesc:aba3369908c62475f826046ed5b3e934e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a weighing factor and an optimization objective, returns a <a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html" title="This class allows for the definition of multiobjective optimal planning problems. Objectives are adde...">MultiOptimizationObjective</a> containing only this objective weighted by the given weight. <br /></td></tr>
<tr class="separator:aba3369908c62475f826046ed5b3e934e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27331877d933e19efeb2fe603a69c1a"><td class="memItemLeft" align="right" valign="top"><a id="af27331877d933e19efeb2fe603a69c1a"></a>
<a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#af27331877d933e19efeb2fe603a69c1a">operator*</a> (const <a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">OptimizationObjectivePtr</a> &amp;a, double weight)</td></tr>
<tr class="memdesc:af27331877d933e19efeb2fe603a69c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a weighing factor and an optimization objective, returns a <a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html" title="This class allows for the definition of multiobjective optimal planning problems. Objectives are adde...">MultiOptimizationObjective</a> containing only this objective weighted by the given weight. <br /></td></tr>
<tr class="separator:af27331877d933e19efeb2fe603a69c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec89bfe00ba3673d7488252b4267ed0d"><td class="memItemLeft" align="right" valign="top"><a id="aec89bfe00ba3673d7488252b4267ed0d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#aec89bfe00ba3673d7488252b4267ed0d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structompl_1_1base_1_1PlannerStatus.html">PlannerStatus</a> &amp;status)</td></tr>
<tr class="memdesc:aec89bfe00ba3673d7488252b4267ed0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structompl_1_1base_1_1PlannerStatus.html" title="A class to store the exit status of Planner::solve()">PlannerStatus</a> object. <br /></td></tr>
<tr class="separator:aec89bfe00ba3673d7488252b4267ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffbc7124ed20dc1331a8c6f40a8f05e"><td class="memItemLeft" align="right" valign="top"><a id="a9ffbc7124ed20dc1331a8c6f40a8f05e"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a9ffbc7124ed20dc1331a8c6f40a8f05e">plannerNonTerminatingCondition</a> ()</td></tr>
<tr class="memdesc:a9ffbc7124ed20dc1331a8c6f40a8f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple termination condition that always returns false. The termination condition will never be met. <br /></td></tr>
<tr class="separator:a9ffbc7124ed20dc1331a8c6f40a8f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1125deb13109d3f27b3acab34d79c09c"><td class="memItemLeft" align="right" valign="top"><a id="a1125deb13109d3f27b3acab34d79c09c"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a1125deb13109d3f27b3acab34d79c09c">plannerAlwaysTerminatingCondition</a> ()</td></tr>
<tr class="memdesc:a1125deb13109d3f27b3acab34d79c09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple termination condition that always returns true. The termination condition will always be met. <br /></td></tr>
<tr class="separator:a1125deb13109d3f27b3acab34d79c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743743b4754208eb83ecb3ab20e4df4c"><td class="memItemLeft" align="right" valign="top"><a id="a743743b4754208eb83ecb3ab20e4df4c"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a743743b4754208eb83ecb3ab20e4df4c">plannerOrTerminationCondition</a> (const <a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a> &amp;c1, const <a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a> &amp;c2)</td></tr>
<tr class="memdesc:a743743b4754208eb83ecb3ab20e4df4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two termination conditions into one. If either termination condition returns true, this one will return true as well. <br /></td></tr>
<tr class="separator:a743743b4754208eb83ecb3ab20e4df4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe113eda8e4fb7306a5849f392db50b"><td class="memItemLeft" align="right" valign="top"><a id="a6fe113eda8e4fb7306a5849f392db50b"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a6fe113eda8e4fb7306a5849f392db50b">plannerAndTerminationCondition</a> (const <a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a> &amp;c1, const <a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a> &amp;c2)</td></tr>
<tr class="memdesc:a6fe113eda8e4fb7306a5849f392db50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two termination conditions into one. Both termination conditions need to return true for this one to return true. <br /></td></tr>
<tr class="separator:a6fe113eda8e4fb7306a5849f392db50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26e5f143063be389fba4906d438a381"><td class="memItemLeft" align="right" valign="top"><a id="ae26e5f143063be389fba4906d438a381"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#ae26e5f143063be389fba4906d438a381">timedPlannerTerminationCondition</a> (double duration)</td></tr>
<tr class="memdesc:ae26e5f143063be389fba4906d438a381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a termination condition that will become true <em>duration</em> seconds in the future (wall-time) <br /></td></tr>
<tr class="separator:ae26e5f143063be389fba4906d438a381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8344c024db04a8e51f226bf26825d372"><td class="memItemLeft" align="right" valign="top"><a id="a8344c024db04a8e51f226bf26825d372"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a8344c024db04a8e51f226bf26825d372">timedPlannerTerminationCondition</a> (<a class="el" href="namespaceompl_1_1time.html#ae77961d01352b61e3fcd521ec3e5d59a">time::duration</a> duration)</td></tr>
<tr class="memdesc:a8344c024db04a8e51f226bf26825d372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a termination condition that will become true <em>duration</em> in the future (wall-time) <br /></td></tr>
<tr class="separator:a8344c024db04a8e51f226bf26825d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b50516a130c05ecc0e420dd64d6a81e"><td class="memItemLeft" align="right" valign="top"><a id="a4b50516a130c05ecc0e420dd64d6a81e"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a4b50516a130c05ecc0e420dd64d6a81e">timedPlannerTerminationCondition</a> (double duration, double interval)</td></tr>
<tr class="memdesc:a4b50516a130c05ecc0e420dd64d6a81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a termination condition that will become true <em>duration</em> seconds in the future (wall-time), but is checked in a separate thread, every <em>interval</em> seconds; <em>interval</em> must be less than <em>duration</em>. <br /></td></tr>
<tr class="separator:a4b50516a130c05ecc0e420dd64d6a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71261936b94c44c59a9f26168b30ea1f"><td class="memItemLeft" align="right" valign="top"><a id="a71261936b94c44c59a9f26168b30ea1f"></a>
<a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html">PlannerTerminationCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceompl_1_1base.html#a71261936b94c44c59a9f26168b30ea1f">exactSolnPlannerTerminationCondition</a> (const <a class="el" href="classompl_1_1base_1_1ProblemDefinitionPtr.html">ompl::base::ProblemDefinitionPtr</a> &amp;pdef)</td></tr>
<tr class="memdesc:a71261936b94c44c59a9f26168b30ea1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a termination condition that will become true as soon as the problem definition has an exact solution. <br /></td></tr>
<tr class="separator:a71261936b94c44c59a9f26168b30ea1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e069784d096867466520346576ef68"><td class="memItemLeft" align="right" valign="top"><a id="a97e069784d096867466520346576ef68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OMPL_CLASS_FORWARD</b> (<a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a>)</td></tr>
<tr class="separator:a97e069784d096867466520346576ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9a73e64207a49663c6e3a555262a0d"><td class="memItemLeft" align="right" valign="top"><a id="a8f9a73e64207a49663c6e3a555262a0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OMPL_CLASS_FORWARD</b> (<a class="el" href="classompl_1_1base_1_1InformedSampler.html">InformedSampler</a>)</td></tr>
<tr class="separator:a8f9a73e64207a49663c6e3a555262a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c5b9f661f809288701e7312308c4c4"><td class="memItemLeft" align="right" valign="top"><a id="a54c5b9f661f809288701e7312308c4c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OMPL_CLASS_FORWARD</b> (<a class="el" href="classompl_1_1base_1_1InformedStateSampler.html">InformedStateSampler</a>)</td></tr>
<tr class="separator:a54c5b9f661f809288701e7312308c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6a8dfe3e0d56f11807e7817cf1c8c9"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7e6a8dfe3e0d56f11807e7817cf1c8c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#ga7e6a8dfe3e0d56f11807e7817cf1c8c9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; T &gt; &amp;state)</td></tr>
<tr class="memdesc:ga7e6a8dfe3e0d56f11807e7817cf1c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload stream output operator. Calls <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1f75d03a8b948abc11b5c29239868e4d" title="Print a state to a stream.">ompl::base::StateSpace::printState()</a> <br /></td></tr>
<tr class="separator:ga7e6a8dfe3e0d56f11807e7817cf1c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5f40dc3239b5a4306609f8df5b8240"><td class="memTemplParams" colspan="2">
template&lt;class T , class Y &gt; </td></tr>
<tr class="memitem:ga5e5f40dc3239b5a4306609f8df5b8240"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#ga5e5f40dc3239b5a4306609f8df5b8240">operator&lt;&lt;</a> (<a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; T &gt; &amp;to, const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; Y &gt; &amp;from)</td></tr>
<tr class="memdesc:ga5e5f40dc3239b5a4306609f8df5b8240"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a fancy version of the assignment operator. It is a partial assignment, in some sense. The difference is that if the states are part of compound state spaces, the data is copied from <em>from</em> to <em>to</em> on a component by component basis. <a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> spaces are matched by name. If the state space for <em>to</em> contains any subspace whose name matches any subspace of the state space for <em>from</em>, the corresponding state components are copied. <br /></td></tr>
<tr class="separator:ga5e5f40dc3239b5a4306609f8df5b8240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf35354f70335067bcea8695958f2867"><td class="memTemplParams" colspan="2">
template&lt;class T , class Y &gt; </td></tr>
<tr class="memitem:gaaf35354f70335067bcea8695958f2867"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#gaaf35354f70335067bcea8695958f2867">operator&gt;&gt;</a> (const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; T &gt; &amp;from, <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; Y &gt; &amp;to)</td></tr>
<tr class="memdesc:gaaf35354f70335067bcea8695958f2867"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a fancy version of the assignment operator. It is a partial assignment, in some sense. The difference is that if the states are part of compound state spaces, the data is copied from <em>from</em> to <em>to</em> on a component by component basis. <a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> spaces are matched by name. If the state space for <em>to</em> contains any subspace whose name matches any subspace of the state space for <em>from</em>, the corresponding state components are copied. <br /></td></tr>
<tr class="separator:gaaf35354f70335067bcea8695958f2867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d4bd70ea0237a80013a71dc2bb7daf1"><td class="memTemplParams" colspan="2">template&lt;class T , class Y &gt; </td></tr>
<tr class="memitem:ga5d4bd70ea0237a80013a71dc2bb7daf1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#ga5d4bd70ea0237a80013a71dc2bb7daf1">operator^</a> (const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; T &gt; &amp;a, const <a class="el" href="classompl_1_1base_1_1ScopedState.html">ScopedState</a>&lt; Y &gt; &amp;b)</td></tr>
<tr class="memdesc:ga5d4bd70ea0237a80013a71dc2bb7daf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given state <em>a</em> from state space A and state <em>b</em> from state space B, construct a state from state space A.  <a href="group__stateAndSpaceOperators.html#ga5d4bd70ea0237a80013a71dc2bb7daf1">More...</a><br /></td></tr>
<tr class="separator:ga5d4bd70ea0237a80013a71dc2bb7daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c3eda924eb78902a00170c46400a27"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__advancedStateCopy.html#gaa66678b1f585228b1da65ed979c98211">AdvancedStateCopyOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__advancedStateCopy.html#ga26c3eda924eb78902a00170c46400a27">copyStateData</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;destS, <a class="el" href="classompl_1_1base_1_1State.html">State</a> *dest, const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;sourceS, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source)</td></tr>
<tr class="memdesc:ga26c3eda924eb78902a00170c46400a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from <em>source</em> (state from space <em>sourceS</em>) to <em>dest</em> (state from space <em>destS</em>) on a component by component basis. <a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> spaces are matched by name. If the state space <em>destS</em> contains any subspace whose name matches any subspace of the state space <em>sourceS</em>, the corresponding state components are copied. <br /></td></tr>
<tr class="separator:ga26c3eda924eb78902a00170c46400a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12cc0040b196f116961d6cae8a62f5d0"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__advancedStateCopy.html#gaa66678b1f585228b1da65ed979c98211">AdvancedStateCopyOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__advancedStateCopy.html#ga12cc0040b196f116961d6cae8a62f5d0">copyStateData</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *destS, <a class="el" href="classompl_1_1base_1_1State.html">State</a> *dest, const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *sourceS, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source)</td></tr>
<tr class="memdesc:ga12cc0040b196f116961d6cae8a62f5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from <em>source</em> (state from space <em>sourceS</em>) to <em>dest</em> (state from space <em>destS</em>) on a component by component basis. <a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> spaces are matched by name. If the state space <em>destS</em> contains any subspace whose name matches any subspace of the state space <em>sourceS</em>, the corresponding state components are copied. <br /></td></tr>
<tr class="separator:ga12cc0040b196f116961d6cae8a62f5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3308e05354b6e3e4175edb47d9cc46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__advancedStateCopy.html#gaa66678b1f585228b1da65ed979c98211">AdvancedStateCopyOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__advancedStateCopy.html#gab3308e05354b6e3e4175edb47d9cc46b">copyStateData</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;destS, <a class="el" href="classompl_1_1base_1_1State.html">State</a> *dest, const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;sourceS, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source, const std::vector&lt; std::string &gt; &amp;subspaces)</td></tr>
<tr class="memdesc:gab3308e05354b6e3e4175edb47d9cc46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from <em>source</em> (state from space <em>sourceS</em>) to <em>dest</em> (state from space <em>destS</em>) but only for the subspaces indicated by name in <em>subspaces</em>. This uses <a class="el" href="classompl_1_1base_1_1StateSpace.html#a9585ccf7f931ed36301740c52a0a2d9e" title="Get the list of known substate locations (keys of the map corrspond to names of subspaces)">StateSpace::getSubstateLocationsByName()</a>.  <a href="group__advancedStateCopy.html#gab3308e05354b6e3e4175edb47d9cc46b">More...</a><br /></td></tr>
<tr class="separator:gab3308e05354b6e3e4175edb47d9cc46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1931f1fa53bb85eadfe033a3fc91d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__advancedStateCopy.html#gaa66678b1f585228b1da65ed979c98211">AdvancedStateCopyOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__advancedStateCopy.html#gae1931f1fa53bb85eadfe033a3fc91d4c">copyStateData</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *destS, <a class="el" href="classompl_1_1base_1_1State.html">State</a> *dest, const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *sourceS, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source, const std::vector&lt; std::string &gt; &amp;subspaces)</td></tr>
<tr class="memdesc:gae1931f1fa53bb85eadfe033a3fc91d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from <em>source</em> (state from space <em>sourceS</em>) to <em>dest</em> (state from space <em>destS</em>) but only for the subspaces indicated by name in <em>subspaces</em>. This uses <a class="el" href="classompl_1_1base_1_1StateSpace.html#a9585ccf7f931ed36301740c52a0a2d9e" title="Get the list of known substate locations (keys of the map corrspond to names of subspaces)">StateSpace::getSubstateLocationsByName()</a>.  <a href="group__advancedStateCopy.html#gae1931f1fa53bb85eadfe033a3fc91d4c">More...</a><br /></td></tr>
<tr class="separator:gae1931f1fa53bb85eadfe033a3fc91d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2a068c3ba88614e32425cf4c493261"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#ga1a2a068c3ba88614e32425cf4c493261">operator+</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;a, const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ga1a2a068c3ba88614e32425cf4c493261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a compound state space from two existing state spaces. The components of this compound space are <em>a</em> (or the components of <em>a</em>, if <em>a</em> is compound) and <em>b</em> (or the components of <em>b</em>, if <em>b</em> is compound). <a class="el" href="classompl_1_1base_1_1State.html" title="Definition of an abstract state.">State</a> spaces are identified by name. Duplicates are checked for and added only once. If the compound state space would end up containing solely one component, that component is returned instead. <br /></td></tr>
<tr class="separator:ga1a2a068c3ba88614e32425cf4c493261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849c861f1e209144fbab68a95c479eb8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#ga849c861f1e209144fbab68a95c479eb8">operator-</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;a, const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ga849c861f1e209144fbab68a95c479eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a compound state space that contains subspaces only from <em>a</em>. If <em>a</em> is compound, <em>b</em> (or the components from <em>b</em>, if <em>b</em> is compound) are removed and the remaining components are returned as a compound state space. If the compound space would end up containing solely one component, that component is returned instead. <br /></td></tr>
<tr class="separator:ga849c861f1e209144fbab68a95c479eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b5c9d6ea57481723cf8a9683a4eabc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#gae1b5c9d6ea57481723cf8a9683a4eabc">operator-</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;a, const std::string &amp;name)</td></tr>
<tr class="memdesc:gae1b5c9d6ea57481723cf8a9683a4eabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a compound state space that contains subspaces only from <em>a</em>, except for maybe the one named <em>name</em>. <br /></td></tr>
<tr class="separator:gae1b5c9d6ea57481723cf8a9683a4eabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16229a85742bb392d45ea9fdc49d7434"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stateAndSpaceOperators.html#ga16229a85742bb392d45ea9fdc49d7434">operator*</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;a, const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ga16229a85742bb392d45ea9fdc49d7434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a compound state space that contains subspaces that are in both <em>a</em> and <em>b</em>. <br /></td></tr>
<tr class="separator:ga16229a85742bb392d45ea9fdc49d7434"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae7d74915be95044375c8e5d7cd33f5a8"><td class="memItemLeft" align="right" valign="top"><a id="ae7d74915be95044375c8e5d7cd33f5a8"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>dInf</b> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="separator:ae7d74915be95044375c8e5d7cd33f5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains sampling based planning routines shared by both planning under geometric constraints (geometric) and planning under differential constraints (dynamic) </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1620a159019faf720c550eeca5723f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1620a159019faf720c550eeca5723f55">&#9670;&nbsp;</a></span>GoalType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceompl_1_1base.html#a1620a159019faf720c550eeca5723f55">ompl::base::GoalType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of goal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1620a159019faf720c550eeca5723f55a63728e6f4a505262163e918202bd1785"></a>GOAL_ANY&#160;</td><td class="fielddoc"><p>This bit is set if casting to generic goal regions (<a class="el" href="classompl_1_1base_1_1Goal.html" title="Abstract definition of goals.">ompl::base::Goal</a>) is possible. This bit shold always be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1620a159019faf720c550eeca5723f55a45bf52626bee439d29a04158d867a979"></a>GOAL_REGION&#160;</td><td class="fielddoc"><p>This bit is set if casting to goal regions (<a class="el" href="classompl_1_1base_1_1GoalRegion.html" title="Definition of a goal region.">ompl::base::GoalRegion</a>) is possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1620a159019faf720c550eeca5723f55a6fb685fa51055688c4e130094225b7f9"></a>GOAL_SAMPLEABLE_REGION&#160;</td><td class="fielddoc"><p>This bit is set if casting to sampleable goal regions (<a class="el" href="classompl_1_1base_1_1GoalSampleableRegion.html" title="Abstract definition of a goal region that can be sampled.">ompl::base::GoalSampleableRegion</a>) is possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1620a159019faf720c550eeca5723f55a451d783254d6bb398c15495e87bc1b86"></a>GOAL_STATE&#160;</td><td class="fielddoc"><p>This bit is set if casting to goal state (<a class="el" href="classompl_1_1base_1_1GoalState.html" title="Definition of a goal state.">ompl::base::GoalState</a>) is possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1620a159019faf720c550eeca5723f55a80679771e14cf79b8baf3e5ecae20142"></a>GOAL_STATES&#160;</td><td class="fielddoc"><p>This bit is set if casting to goal states (<a class="el" href="classompl_1_1base_1_1GoalStates.html" title="Definition of a set of goal states.">ompl::base::GoalStates</a>) is possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1620a159019faf720c550eeca5723f55a15dee78752265020cab91cf866fee69d"></a>GOAL_LAZY_SAMPLES&#160;</td><td class="fielddoc"><p>This bit is set if casting to goal states (<a class="el" href="classompl_1_1base_1_1GoalLazySamples.html" title="Definition of a goal region that can be sampled, but the sampling process can be slow....">ompl::base::GoalLazySamples</a>) is possible. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GoalTypes_8h_source.html#l00045">45</a> of file <a class="el" href="GoalTypes_8h_source.html">GoalTypes.h</a>.</p>

</div>
</div>
<a id="a056b022e14fe04a75f81789947353920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056b022e14fe04a75f81789947353920">&#9670;&nbsp;</a></span>StateSpaceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceompl_1_1base.html#a056b022e14fe04a75f81789947353920">ompl::base::StateSpaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a state space. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920a4247bd6859b13c6482caed7f9dd9996d"></a>STATE_SPACE_UNKNOWN&#160;</td><td class="fielddoc"><p>Unset type; this is the default type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920abb95f16481daa006d055bad7060b8fbb"></a>STATE_SPACE_REAL_VECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html" title="A state space representing Rn. The distance function is the L2 norm.">ompl::base::RealVectorStateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920aca07fe8d9ce9fe45ad5d1b2d90c8c1fc"></a>STATE_SPACE_SO2&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1SO2StateSpace.html" title="A state space representing SO(2). The distance function and interpolation take into account angle wra...">ompl::base::SO2StateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920ae9ec8f7cf5204246a32a44768d843fb1"></a>STATE_SPACE_SO3&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1SO3StateSpace.html" title="A state space representing SO(3). The internal representation is done with quaternions....">ompl::base::SO3StateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920a197336a12b06210c42899c5b53c298b1"></a>STATE_SPACE_SE2&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1SE2StateSpace.html" title="A state space representing SE(2)">ompl::base::SE2StateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920acc8d4a06096c378b5473fe4caf8171f8"></a>STATE_SPACE_SE3&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1SE3StateSpace.html" title="A state space representing SE(3)">ompl::base::SE3StateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920afc515ecf796d311c9ae7ae879fb63158"></a>STATE_SPACE_TIME&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1TimeStateSpace.html" title="A state space representing time. The time can be unbounded, in which case enforceBounds() is a no-op,...">ompl::base::TimeStateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920a56b36a6f5b0a8ae48be0baa7e348def3"></a>STATE_SPACE_DISCRETE&#160;</td><td class="fielddoc"><p><a class="el" href="classompl_1_1base_1_1DiscreteStateSpace.html" title="A space representing discrete states; i.e. there are a small number of discrete states the system can...">ompl::base::DiscreteStateSpace</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a056b022e14fe04a75f81789947353920aa011308faae02860d3e6fe26be28c167"></a>STATE_SPACE_TYPE_COUNT&#160;</td><td class="fielddoc"><p>Number of state space types; To add new types, use values that are larger than the count. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="StateSpaceTypes_8h_source.html#l00045">45</a> of file <a class="el" href="StateSpaceTypes_8h_source.html">StateSpaceTypes.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<footer class="footer">
  <div class="container">
  <a href="http://www.kavrakilab.org">Kavraki Lab</a>  &bull;
  <a href="https://www.cs.rice.edu">Department of Computer Science</a> &bull;
  <a href="https://www.rice.edu">Rice University</a><br/>
  Funded in part by the <a href="https://www.nsf.gov">National Science Foundation</a><br/>
  Documentation generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
