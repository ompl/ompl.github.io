<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl/doc/markdown/planners.md Source File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. Șucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.8.14"/>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-powertip/1.2.0/jquery.powertip.min.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li><li><a href="webapp.html">OMPL web app</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="constrainedPlanning.html">Constrained Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux/macOS)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux/macOS)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://github.com/ompl/ompl/issues">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
                  <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ompl/doc/markdown/planners.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Available Planners {#planners}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;All implementations listed below are considered fully functional. Within OMPL planners are divided into two categories:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;- \ref geometric_planners</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;- \ref control_planners</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;To see how to benchmark planners, click [here](benchmark.html).</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;# Geometric planners {#geometric_planners}</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Planners in this category only accounts for the geometric and kinematic constraints of the system. It is assumed that any feasible path can be turned into a dynamically feasible trajectory. Any of these planners can be used to [plan with geometric constraints](constrainedPlanning.html). Planners in this category can be divided into several overlapping subcategories:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;&lt;div class=&quot;plannerlist&quot;&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;- **Multi-query planners**&lt;br&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  These planners build a roadmap of the entire environment that can be used for multiple queries.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  - [Probabilistic Roadmap Method (PRM)](\ref gPRM)&lt;br&gt;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    This is the sampling-based algorithm. Our implementation uses one thread to construct a roadmap while a second thread checks whether a path exists in the roadmap between a start and goal state. OMPL contains a number of variants of PRM:</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    - [LazyPRM](\ref gLazyPRM)&lt;br&gt;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      This planner is similar to regular PRM, but checks the validity of a vertex or edge “lazily,” i.e., only when it is part of a candidate solution path.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    - [PRM*](\ref gPRMstar)&lt;br&gt;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;      While regular PRM attempts to connect states to a fixed number of neighbors, PRM* gradually increases the number of connection attempts as the roadmap grows in a way that provides convergence to the optimal path.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    - [LazyPRM*](\ref gLazyPRMstar)&lt;br&gt;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;      A version of PRM* with lazy state validity checking.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  - [SPArse Roadmap Spanner algorithm (SPARS)](\ref gSPARS)&lt;br&gt;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    SPARS is a planner that provides asymptotic _near_-optimality (a solution that is within a constant factor of the optimal solution) and includes a meaningful stopping criterion. Although (because?) it does not guarantee optimality, its convergence rate tends to be much higher than PRM*.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  - [SPARS2](\ref gSPARStwo)&lt;br&gt;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    SPARS2 is variant of the SPARS algorithm that works through similar mechanics, but uses a different approach to identifying interfaces and computing shortest paths through said interfaces.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;- **Single-query planners**&lt;br&gt;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  These planners typically grow a tree of states connected by valid motions. These planners differ in the heuristics they use to control _where_ and _how_ the tree is expanded. Some tree-based planners grow _two_ trees: one from the start and one from the goal. Such planners will attempt to connect a state in the start tree with another state in the goal tree.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  - [Rapidly-exploring Random Trees (RRT)](\ref gRRT)&lt;br&gt;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    This is one of the first single query planners. The algorithm is easy to understand and easy to implement. Many, many variants of RRT have been proposed. OMPL contains several RRT variants:</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    - [RRT Connect (RRTConnect)](\ref gRRTC)&lt;br&gt;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      This planner is a bidirectional version of RRT (i.e., it grows two trees). It usually outperforms the original RRT algorithm.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    - [RRT*](\ref gRRTstar)&lt;br&gt;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      An asymptotically optimal version of RRT: the algorithm converges on the optimal path as a function of time. This was the first provably asymptotically planner (together with PRM). Since its publication, several other algorithms have appeared that improve on RRT*&#39;s convergence rate, such as [RRT#](\ref gRRTsharp) and [RRTX](\ref gRRTX).</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    - [Lower Bound Tree RRT (LBTRRT)](\ref gLBTRRT)&lt;br&gt;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      LBTRRT is a asymptotically near-optimal version of RRT: it is guaranteed to converge to a solution that is within a constant factor of the optimal solution.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    - [Sparse Stable RRT](\ref gSST)&lt;br&gt;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;      SST is an asymptotically near-optimal incremental version of RRT.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    - [Transition-based RRT (T-RRT)](\ref gTRRT)&lt;br&gt;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      T-RRT does not give any hard optimality guarantees, but tries to find short, low-cost paths.</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    - [Vector Field RRT](\ref gVFRRT)&lt;br&gt;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      VF-RRT is a tree-based motion planner that tries to minimize the so-called upstream cost of a path. The upstream cost is defined by an integral over a user-defined vector field.</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    - [Parallel RRT (pRRT)](\ref gpRRT)&lt;br&gt;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      Many different parallelization schemes have been proposed for sampling-based planners, including RRT. In this implementation, several threads simultaneously add states to the same tree. Once a solution is found, all threads terminate.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    - [Lazy RRT (LazyRRT)](\ref gLazyRRT)&lt;br&gt;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;      This planner performs lazy state validity checking (similar to LazyPRM). It is not experimental, but in our experience it does not seem to outperform other planners by a significant margin on any class of problems.</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  - [Expansive Space Trees (EST)](\ref gEST)&lt;br&gt;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    This planner was published around the same time as RRT. In our experience it is not as sensitive to having a good distance measure, which can be difficult to define for complex high-dimensional state spaces. There are actually three versions of EST: the [original version](\ref gEST) that is close to the first publication, [a bidirectional version](\ref gBiEST), and a [projection-based version](\ref gProjEST). The low-dimensional projection is used to keep track of how the state space has been explored. Most of the time OMPL can automatically determine a reasonable projection. We have implemented a few planners that not necessarily simple variants of EST, but do share the same expansion strategy:</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    - [Single-query Bi-directional Lazy collision checking planner (SBL)](\ref gSBL)&lt;br&gt;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      This planner is essentially a bidirectional version of EST with lazy state validity checking.</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    - [Parallel Single-query Bi-directional Lazy collision checking planner (pSBL)](\ref gpSBL)&lt;br&gt;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      This planner grows the two trees in SBL with multiple threads in parallel.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  - [Kinematic Planning by Interior-Exterior Cell Exploration (KPIECE)](\ref gKPIECE1)&lt;br&gt;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    KPIECE is a tree-based planner that uses a discretization (multiple levels, in general) to guide the exploration of the (continuous) state space. OMPL&#39;s implementation is a simplified one, using a single level of discretization: one grid. The grid is imposed on a _projection_ of the state space. When exploring the space, preference is given to the boundary of</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    that part of the grid that has been explored so far. The boundary is defined to be the set of grid</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    cells that have fewer than 2&lt;i&gt;n&lt;/i&gt; non-diagonal non-empty neighboring grid cells in an</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    _n_-dimensional projection space. There are two variants of KPIECE:</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    - [Bi-directional KPIECE (BKPIECE)](\ref gBKPIECE1)</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    - [Lazy Bi-directional KPIECE (LBKPIECE)](\ref gLBKPIECE1)</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  - [Search Tree with Resolution Independent Density Estimation (STRIDE)](\ref gSTRIDE)&lt;br&gt;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    This planner was inspired by EST. Instead of using a projection, STRIDE uses a [Geometric Near-neighbor Access Tree](\ref ompl::NearestNeighborsGNAT) to estimate sampling density directly in the state space. STRIDE is a useful for high-dimensional systems where the free space cannot easily be captured with a low-dimensional (linear) projection.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  - [Path-Directed Subdivision Trees (PDST)](\ref gPDST)&lt;br&gt;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    PDST is a planner that has entirely removed the dependency on a distance measure, which is useful in cases where a good distance metric is hard to define. PDST maintains a binary space partitioning such that motions are completely contained within one cell of the partition. The density of motions per cell is used to guide expansion of the tree.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  - [Fast Marching Tree algorithm (FMT∗)](\ref gFMT)&lt;br&gt;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    The FMT∗ algorithm performs a “lazy” dynamic programming recursion on a set of probabilistically-drawn samples to grow a tree of paths, which moves outward in cost-to-come space. Unlike all other planners, the numbers of valid samples needs to be chosen beforehand.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  - [Bidirectional Fast Marching Tree algorithm (BFMT∗)](\ref gBFMT)&lt;br&gt;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    Executes two FMT* trees, one from the start and another one from the goal resulting in a faster planner as it explores less space.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;- **Optimizing planners**&lt;br&gt;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  In recent years several sampling-based planning algorithms have been proposed that still provide some optimality guarantees. Typically, an optimal solution is assumed to be shortest path. In OMPL we have a more general framework for expressing the cost of states and paths that allows you to, e.g., maximize the minimum clearance along a path, minimize the mechanical work, or some arbitrary user-defined optimization criterion. See \ref optimalPlanning for more information. Some of the planners below use this general cost framework, but keep in mind that convergence to optimality is **not guaranteed** when optimizing over something other than path length.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  - [PRM*](\ref gPRMstar)&lt;br&gt; An asymptotically optimal version of PRM; _uses the general cost framework._</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  - [LazyPRM*](\ref gLazyPRMstar)&lt;br&gt; Lazy version of PRM*; _uses the general cost framework._</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  - [RRT*](\ref gRRTstar)&lt;br&gt; An asymptotically optimal version of RRT; _uses the general cost framework._</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  - [RRT#](\ref gRRTsharp)&lt;br&gt; A variant of RRT* with an improved convergence rate. _It uses the general cost framework._</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  - [RRTX](\ref gRRTX)&lt;br&gt; A variant of RRT* with an improved convergence rate. _It uses the general cost framework._</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  - [Informed RRT*](\ref gInformedRRTstar)&lt;br&gt; A variant of RRT* that uses heuristics to bound the search for optimal solutions. _It uses the general cost framework._</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  - [Batch Informed Trees (BIT*)](\ref gBITstar)&lt;br&gt; An anytime asymptotically optimal algorithm that uses heuristics to order and bound the search for optimal solutions. _It uses the general cost framework._</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  - [Lower Bound Tree RRT (LBTRRT)](\ref gLBTRRT)&lt;br&gt; An asymptotically near-optimal version of RRT.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  - [Sparse Stable RRT](\ref gSST)&lt;br&gt; SST is an asymptotically near-optimal incremental version of RRT.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  - [Transition-based RRT (T-RRT)](\ref gTRRT)&lt;br&gt; T-RRT does not give any hard optimality guarantees, but tries to find short, low-cost paths. _It uses the general cost framework._</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  - [SPARS](\ref gSPARS)&lt;br&gt; An asymptotically near-optimal roadmap-based planner.</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  - [SPARS2](\ref gSPARStwo)&lt;br&gt; An asymptotically near-optimal roadmap-based planner.</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  - [FMT*](\ref gFMT)&lt;br&gt; An asymptotically optimal tree-based planner.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  - [CForest](\ref gCForest)&lt;br&gt; A meta-planner that runs several instances of asymptotically optimal planners in different threads. When one thread finds a better solution path, the states along the path are passed on to the other threads.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  - [AnytimePathShortening (APS)](\ref gAPS)&lt;br&gt; APS is a generic wrapper around one or more geometric motion planners that repeatedly applies [shortcutting](\ref ompl::geometric::PathSimplifier) and [hybridization](\ref ompl::geometric::PathHybridization) to a set of solution paths. Any number and combination of planners can be specified, each is run in a separate thread.</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;.</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;\attention How OMPL selects a geometric planner&lt;br&gt;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;If you use the ompl::geometric::SimpleSetup class (highly recommended) to define and solve your motion planning problem, then OMPL will automatically select an appropriate planner (unless you have explicitly specified one). If the state space has a default projection (which is going to be the case if you use any of the built-in state spaces), then it will use [LBKPIECE](\ref gLBKPIECE1) if a bidirectional planner can be used and otherwise it will use [KPIECE](\ref gKPIECE1). These planners have been shown to work well consistently across many real-world motion planning problems, which is why these planners are the default choice. In case the state space has no default projection, [RRTConnect](\ref gRRTC) or regular [RRT](\ref gRRT) will be used, depending on whether a bidirectional planner can be used. The notion of a goal is very general in OMPL: it may not even be possible to sample a state that satisfies the goal, in which case OMPL cannot grow a second tree at a goal state.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;&lt;div&gt;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;## Other tools:</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;- [Hill Climbing](\ref HillClimbing)</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;- [Genetic Search](\ref GeneticSearch)</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;# Control-based planners {#control_planners}</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;&lt;div class=&quot;plannerlist&quot;&gt;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;If the system under consideration is subject to differential constraints, then a control-based planner is used. These planners rely on [state propagation](\ref ompl::control::StatePropagator) rather than simple interpolation to generate motions. These planners do not require [a steering function](\ref ompl::control::StatePropagator::steer), but all of them (except KPIECE) will use it if the user implements it. The first two planners below are kinodynamic adaptations of the corresponding geometric planners above.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;- [Rapidly-exploring Random Trees (RRT)](\ref cRRT)</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;- [Sparse Stable RRT](\ref cSST)&lt;br&gt; SST is an asymptotically near-optimal incremental version of RRT.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;- [Expansive Space Trees (EST)](\ref cEST)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;- [Kinodynamic Planning by Interior-Exterior Cell Exploration (KPIECE)](\ref cKPIECE1)&lt;br&gt;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  As the name suggest, the control-based version of KPIECE came first, and the geometric versions were derived from it.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;- [Path-Directed Subdivision Trees (PDST)](\ref cPDST)&lt;br&gt;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  The control-based version of PDST actually came before the geometric version. Given the control-based version it was straightforward to also implement a geometric version.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;- [Syclop, a meta planner that uses other planners at a lower level](\ref cSyclop)&lt;br&gt;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  Syclop is a meta-planner that combines a high-level guide computed over a decomposition of the state space with a low-level planning algorithm. The progress that the low-level planner makes is fed back to the high-level planner which uses this information to update the guide. There are two different versions of Syclop:</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;   - [Syclop using RRT as the low-level planner](\ref cSyclopRRT)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;   - [Syclop using EST as the low-level planner](\ref cSyclopEST)</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;- [Linear Temporal Logical Planner (LTLPlanner)](\ref cLTLPlanner)&lt;br&gt;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  LTLPlanner finds solutions for motion planning problems where the goal is specified by a Linear Temporal Logic (LTL) specification.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;\attention How OMPL selects a control-based planner&lt;br&gt;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;If you use the ompl::control::SimpleSetup class (highly recommended) to define and solve your motion planning problem, then OMPL will automatically select an appropriate planner (unless you have explicitly specified one). If the state space has a default projection (which is going to be the case if you use any of the built-in state spaces), then it will use [KPIECE](\ref cKPIECE1). This planner has been shown to work well consistently across many real-world motion planning problems, which is why it is the default choice. In case the state space has no default projection, [RRT](\ref cRRT) will be used. Note that there are no bidirectional control-based planners, since we do not assume that there is a steering function that can connect two states _exactly_.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;&lt;/div&gt;</div></div><!-- fragment --></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Kavraki Lab</a>  &bull;
    <a href="https://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="https://www.rice.edu">Rice University</a><br/>
    Funded in part by the <a href="https://www.nsf.gov">National Science Foundation</a><br/>
    Documentation generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</body>
</html>
