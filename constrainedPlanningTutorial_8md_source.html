<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl/doc/markdown/constrainedPlanningTutorial.md Source File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.8.14"/>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-powertip/1.2.0/jquery.powertip.min.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li><li><a href="webapp.html">OMPL web app</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="constrainedPlanning.html">Constrained Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
                  <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ompl/doc/markdown/constrainedPlanningTutorial.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Constrained Planning Tutorial {#constrainedPlanningTutorial}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Defining a constrained motion planning problem is easy and very similar to defining an unconstrained planning problem. The primary difference is the need to define a _constraint_, and the use of a _constrained state space_, which wraps around an ambient state space. In this example, we will walk through defining a simple constrained planning problem: a point in \f$\mathbb{R}^3\f$ that is constrained to be on the surface of a sphere, giving a constraint function \f$f(q) = \lVert q \rVert - 1\f$. This is very similar to the problem defined by the demo [ConstrainedPlanningSphere](ConstrainedPlanningSphere_8cpp_source.html).</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;## Defining the Constraint</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;First, let&#39;s define our constraint class. Constraints must inherit from the base class `ompl::base::Constraint`. Primarily, the function `ompl::base::Constraint::function()` must be implemented by any concrete implementation of a constraint. A bare-bones version of the sphere constraint we gave above might look like this:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// Constraints must inherit from the constraint base class. By default, a</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// numerical approximation to the Jacobian of the constraint function is computed</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// using a central finite difference.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;class Sphere : public ob::Constraint</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;public:</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    // ob::Constraint&#39;s constructor takes in two parameters, the dimension of</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    // the ambient state space, and the dimension of the real vector space the</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    // constraint maps into. For our sphere example, as we are planning in R^3, the</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    // dimension of the ambient space is 3, and as our constraint outputs one real</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    // value the second parameter is one (this is also the co-dimension of the</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    // constraint manifold).</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    Sphere() : ob::Constraint(3, 1)</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    {</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    }</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    // Here we define the actual constraint function, which takes in some state &quot;x&quot;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    // (from the ambient space) and sets the values of &quot;out&quot; to the result of the</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    // constraint function. Note that we are implementing `function` which has this</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    // function signature, not the one that takes in ompl::base::State.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    void function(const Eigen::Ref&lt;const Eigen::VectorXd&gt; &amp;x, Eigen::Ref&lt;Eigen::VectorXd&gt; out) const override</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        // The function that defines a sphere is f(q) = || q || - 1, as discussed</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        // above. Eigen makes this easy to express:</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        out[0] = x.norm() - 1;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    }</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;};</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;~~~</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;We now have a constraint function that defines a sphere in \f$\mathbb{R}^3\f$! We can visualize the constraint simply as a sphere in \f$\mathbb{R}^3\f$, shown below.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;&lt;div class=&quot;row&quot;&gt;&lt;img src=&quot;images/sphere.png&quot; class=&quot;col-xs-6 col-xs-offset-3&quot;&gt;&lt;/div&gt;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Now we can use this constraint to define a constrained state space.</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;### Constraint Jacobian</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;However, we can do better. We would like to include an analytical Jacobian for our constraint function, so that planning more efficient. Either we can compute this by hand, or we can use some symbolic solver (e.g., `ConstraintGeneration.py` shows how to do this with [SymPy](http://www.sympy.org/en/index.html)). Either way, we add to our class the function to compute the Jacobian:</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;// Implement the Jacobian of the constraint function. The Jacobian for the</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;// constraint function is an matrix of dimension equal to the co-dimension of the</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;// constraint by the ambient dimension (in this case, 1 by 3). Similar to</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;// `function` above, we implement the `jacobian` method with the following</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;// function signature.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;void Sphere::jacobian(const Eigen::Ref&lt;const Eigen::VectorXd&gt; &amp;x, Eigen::Ref&lt;Eigen::MatrixXd&gt; out) const override</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;{</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    out = x.transpose().normalized();</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;}</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;~~~</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;In general, it is _highly_ recommended that you provide an analytic Jacobian for a constrained planning problem, especially for high-dimensional problems.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;### Projection</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;One of the primary features of `ompl::base::Constraint` is the _projection_ function, `ompl::base::Constraint::project()`.</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;This function takes as input a potential constraint unsatisfying state and maps it onto the constraint manifold, generating a constraint satisfying state.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;By default, `ompl::base::Constraint::project()` implements a Newton&#39;s method which performs well in most circumstances.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;However, it is possible to override this method with your own projection routine.</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;For example, in the case of our sphere, it could simply normalize the state, placing it on the sphere.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;Another example would be to use inverse kinematics for a complex robot manipulator.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;### Constraint Parameters</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;`ompl::base::Constraint` affords a two parameters that affect performance.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;The first is `tolerance`, which can be set with `ompl::base::Constraint::setTolerance()`, or via the constructor.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;Using the constructor, our `Sphere` class could like like this:</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;...</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    // Set ambient and constraint dimension, along with tolerance (1e-3, in this case).</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    Sphere() : ob::Constraint(3, 1, 1e-3)</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;...</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;~~~</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;`tolerance` is used in `ompl::base::Constraint::project()` to determine when a state satisfies the constraints, and in `ompl::base::Constraint::isSatisfied()` for the same purpose.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;For problems that afford lower tolerances (e.g., highly compliant robots), `tolerance` can be lowered.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;Lower `tolerance` values generally simplifies the planning problem, as it is easier to satisfy constraints.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;The second is `maxIterations`, which can be set with `ompl::base::Constraint::setMaxIterations()`.</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;`maxIterations` is used in `ompl::base::Constraint::project()` to limit the number of iterations the projection routine uses, in the case that a satisfying configuration cannot be found.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;It might be necessary to adjust this value for particularly easy or hard constraint functions to satisfy (decreasing and increasing iterations respectively).</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;## Defining the Constrained State Space</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;### Ambient State Space</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;Before we can define a constrained state space, we need to define the ambient state space \f$\mathbb{R}^3\f$.</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;// Create the ambient space state space for the problem.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;auto rvss = std::make_shared&lt;ob::RealVectorStateSpace&gt;(3);</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;// Set bounds on the space.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;ob::RealVectorBounds bounds(3);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;bounds.setLow(-2);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;bounds.setHigh(2);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;rvss-&gt;setBounds(bounds);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;~~~</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;The ambient space is the space over which the constraint is defined, and is used by our constrained state space.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;### Constraint Instance</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;We then need to create an instance of our constraint:</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;// Create our sphere constraint.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;auto constraint = std::make_shared&lt;Sphere&gt;();</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;~~~</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;The constraint instance is used by our constrained state space.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;### Constrained State Space</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;Now that we have both the ambient state space and the constraint, we can define the constrained state space. For this example, we will be using `ompl::base::ProjectedStateSpace`, which implements a projection operator-based methodology for satisfying constraints. However, we could also just as easily use the other constrained state spaces, `ompl::base::AtlasStateSpace` or `ompl::base::TangentBundleStateSpace`, for this problem. We will also be creating a `ompl::base::ConstrainedSpaceInformation`, which is an augmentation of `ompl::base::SpaceInformation` with some small modification to take into account constraints.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;// Combine the ambient space and the constraint into a constrained state space.</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;auto css = std::make_shared&lt;ob::ProjectedStateSpace&gt;(rvss, constraint);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;// Define the constrained space information for this constrained state space.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;auto csi = std::make_shared&lt;ob::ConstrainedSpaceInformation&gt;(css);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;~~~</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;One of the most important things that `ompl::base::ConstrainedSpaceInformation` does is call `ompl::base::ConstrainedStateSpace::setSpaceInformation`, which allows for the manifold traversal to do collision checking in tandem with discrete geodesic computation. Now, we have a constrained state space and space information which we can use for planning.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;## Defining a Problem</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;Let&#39;s define a simple problem to solve for this constrained space: traverse the sphere from the south pole to the north pole, avoiding a simple obstacle near the equator. Defining a problem using the constraint framework is as simple as defining an unconstrained problem, and uses the same set of tools. For example, we will be creating a `ompl::geometric::SimpleSetup` to help with problem definition.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;// Simple Setup</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;auto ss = std::make_shared&lt;og::SimpleSetup&gt;(csi);</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;~~~</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;### State Validity Checker</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;Let&#39;s define our state validity checker, which is a simple narrow band around the equator with a hole on one side:</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;bool obstacle(const ob::State *state)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;{</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    // As ob::ConstrainedStateSpace::StateType inherits from</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    // Eigen::Map&lt;Eigen::VectorXd&gt;, we can grab a reference to it for some easier</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    // state access.</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    const Eigen::Map&lt;Eigen::VectorXd&gt; &amp;x = *state-&gt;as&lt;ob::ConstrainedStateSpace::StateType&gt;();</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    // Alternatively, we could access the underlying real vector state with the</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    // following incantation:</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    //   auto x = state-&gt;as&lt;ob::ConstrainedStateSpace::StateType&gt;()-&gt;getState()-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;();</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    // Note the use of &quot;getState()&quot; on the constrained state. This accesss the</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    // underlying state that was allocated by the ambient state space.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    // Define a narrow band obstacle with a small hole on one side.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    if (-0.1 &lt; x[2] &amp;&amp; x[2] &lt; 0.1)</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        if (-0.05 &lt; x[0] &amp;&amp; x[0] &lt; 0.05)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            return x[1] &lt; 0;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        return false;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    }</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    return true;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;}</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;// Set the state validity checker in simple setup.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;ss-&gt;setStateValidityChecker(obstacle);</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;~~~</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;Below, you can see a representation of this obstacle on our sphere.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;&lt;div class=&quot;row&quot;&gt;&lt;img src=&quot;images/obstacles.png&quot; class=&quot;col-xs-6 col-xs-offset-3&quot;&gt;&lt;/div&gt;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;### Start and Goal</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;Now, let&#39;s also set the start and goal states, the south and north poles of the sphere. Note that for constrained problems, the start and goal states (if using exact states) must satisfy the constraint function. If they do not, then problems will occur.</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;// Start and goal vectors.</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;Eigen::VectorXd sv(3), gv(3);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;sv &lt;&lt; 0, 0, -1;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;gv &lt;&lt; 0, 0,  1;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;// Scoped states that we will add to simple setup.</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;ob::ScopedState&lt;&gt; start(css);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;ob::ScopedState&lt;&gt; goal(css);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;// Copy the values from the vectors into the start and goal states.</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;start-&gt;as&lt;ob::ConstrainedStateSpace::StateType&gt;()-&gt;copy(sv);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;goal-&gt;as&lt;ob::ConstrainedStateSpace::StateType&gt;()-&gt;copy(gv);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;// If we were using an Atlas or TangentBundleStateSpace, we would also have to anchor these states to charts:</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;//   css-&gt;anchorChart(start.get());</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;//   css-&gt;anchorChart(goal.get());</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;// Which gives a starting point for the atlas to grow.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;ss-&gt;setStartAndGoalStates(start, goal);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;~~~</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;### Planner</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;Finally, we can add a planner like normal. Let&#39;s use `ompl::geometric::PRM`, but any other planner in `ompl::geometric` would do.</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;auto pp = std::make_shared&lt;og::PRM&gt;(csi);</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;ss-&gt;setPlanner(pp);</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;~~~</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;## Solving a Problem</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;With everything now in place, we can set everything up to get ready for planning:</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;ss-&gt;setup();</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;~~~</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;Same as how defining a problem is similar for constrained and unconstrained problems, solving a problem is also very similar. Let&#39;s give our planner 5 seconds of time and see what happens:</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;// Solve a problem like normal, for 5 seconds.</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;ob::PlannerStatus stat = ss-&gt;solve(5.);</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;if (stat)</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;{</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    // Path simplification also works when using a constrained state space!</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    ss-&gt;simplifySolution(5.);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    // Get solution path.</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    auto path = ss-&gt;getSolutionPath();</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    // Interpolation also works on constrained state spaces, and is generally required.</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    path.interpolate();</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    // Then do whatever you want with the path, like normal!</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;}</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;else</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    OMPL_WARN(&quot;No solution found!&quot;);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;~~~</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;### Interpolation</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;Note that in general the initial path that you find is not &quot;continuous&quot;.</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;That is, the distance between states in the path (especially after simplification) can be very far apart!</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;If you want a path that has close, intermediate constraint satisfying states, you need to interpolate the path.</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;In the code above, this is achieved with `ompl::geometric::PathGeometric::interpolate()`.</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;# In Summary</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;With all that, we&#39;ve now solved a constrained motion planning problem on a sphere. A resulting motion graph for PRM could look something like this, with the simplified solution path highlighted in yellow:</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;&lt;div class=&quot;row&quot;&gt;&lt;img src=&quot;images/prm.png&quot; class=&quot;col-xs-6 col-xs-offset-3&quot;&gt;&lt;/div&gt;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;Overall, planning with constraints is simple to setup and use. Beyond requiring you to define a constraint function and wrap your ambient space in a constrained state space, OMPL works and feels like normal. You can read more in general about constrained planning on the [main page](constrainedPlanning.html).</div></div><!-- fragment --></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</body>
</html>
