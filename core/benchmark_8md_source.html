<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>doc/markdown/benchmark.md Source File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. Șucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.8.14"/>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-powertip/1.2.0/jquery.powertip.min.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="constrainedPlanning.html">Constrained Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
                  <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/markdown/benchmark.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# How to Benchmark Planners {#benchmark}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;OMPL contains a ompl::Benchmark class that facilitates solving a motion planning problem repeatedly with different parameters, different planners, different samplers, or even differently configured versions of the same planning algorithm. Below, we will describe how you can use this class.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;\if OMPLAPP</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;- \ref benchmark_config</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;\endif</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;- \ref benchmark_code</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;- \ref benchmark_log</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;- \ref benchmark_sample_results</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;- \ref benchmark_logfile_format</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;- \ref benchmark_database</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;\ifnot OMPLAPP</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;For a command line program for rigid body motion planning and basic kinodynamic motion planning, see the [ompl_benchmark](http://ompl.kavrakilab.org/benchmark.html) program in OMPL.app.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;\endif</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;For interactive visualization of benchmark databases, please see [plannerarena.org](http://plannerarena.org).</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;\if OMPLAPP</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;# Create a benchmark configuration file {#benchmark_config}</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;OMPL.app contains a command line program called `ompl_benchmark`, that can read a text based configuration file using an ini style format with key/value pairs. This is the same format that can be read and saved with the OMPL.app GUI. The GUI ignores the settings related to benchmarking. However, it is often convenient to create an initial configuration with the GUI and add the benchmark settings with a text editor. Currently the base functionality of the `ompl_benchmark` program only applies to geometric planning in SE(2) and SE(3) and kinodynamic planning for certain systems, but the program can be extended by the user to other types of planning problems.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;There are a number of _required_ parameters necessary to define the problem. These exist under the “**[problem]**” heading:</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;- __name__: An identifying name for the problem to be solved.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;- __robot__: The path to a mesh file describing the geometry of the robot.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;- __start.[x|y|z|theta], start.axis.[x|y|z]__: Values describing the start state of the robot. In 2D, the orientation is specified with just __start.theta__, while in 3D the axis-angle orientation is used.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;- __goal.[x|y|z|theta], goal.axis.[x|y|z]__: Values describing the goal state of the robot.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;The following parameters are _optional_ under the “**[problem]**” heading:</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;- __world__: The path to a mesh file describing the geometry of the environment. If unspecified, it is assumed that the robot operates in an empty workspace.</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;- __objective__: Some planners in OMPL can optimize paths as a function of various optimization objective. The __objective__ parameter can be set to `length`, `max_min_clearance`, or `mechanical_work`, to minimize path length, maximize minimum clearance along the path, or mechanical work of the path, respectively. If unspecified, it is assumed the objective is `length`.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;- __objective.threshold__: If an objective is specified, you can optionally also specify the __objective.threshold__, which causes optimizing planners to terminate once they find a path with cost better than the specified threshold (a real-valued number). If unspecified, the best possible value is chosen for a threshold (e.g., for path length that would be 0), so that optimizing planners will try to find the shortest possible path.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;- __control__: There a few built-in kinodynamic systems in OMPL.app. The __control__ parameter can be set to `kinematic_car`, `dynamic_car`, `blimp`, and `quadrotor`. If unspecified, rigid-body planning is assumed. Beware that kinodynamic planning is *much* harder than rigid-body planning.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;- __sampler__: This parameter specified the sampler to be used by the planner. The following samplers are available: `uniform`, `gaussian`, `obstacle_based`, `max_clearance`. If unspecified, the uniform sampler is used.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;- __volume.[min|max].[x|y|z]__: It is sometimes necessary to specify the bounds of the workspace. Without any specification, OMPL.app assumes a tight bounding box around the environment (if specified) and the start and goal states, but depending on the environment this may not be a good assumption.</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Parameters relating to benchmarking must be declared under the “**[benchmark]**” heading:</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;- __time_limit__: The amount of time (seconds) for each plan computation.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;- __mem_limit__: The maximum amount of memory (MB) for each planner. Memory measurements are not very accurate, so it is recommended to set this to a very large value.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;- __run_count__: The number of times to repeat the experiment for each planner.</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;- __output__: Output directory where the benchmark log file will be saved. This parameter is optional; by default the log file is saved in the same directory as the configuration file.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;- __save_paths__: This _optional_ parameter can be set to `none`, `all`, or `shortest` to save _no_ solution paths (the default value), _all_ solution paths (including approximate solutions), or the _shortest_ exact solution for each planner, respectively. These paths can then be “played back” in the [OMPL.app GUI](gui.html#gui_paths).</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;The last required element to specify are the planners to benchmark.  These are specified under the “**[planner]**” heading.  The following planners are valid for geometric benchmarking:</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;`kpiece`,  `bkpiece`,  `lbkpiece`,  `est`,  `sbl`,  `prm`,  `lazyprm`,  `lazyprmstar`,  `rrt`,  `rrtconnect`,  `lazyrrt`,  `rrtstar`,  `lbtrrt`,  `trrt`,  `spars`,  `spars2`,  `stride`,  `pdst`,  `fmt`, and  `aps`.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;The following planners are valid for kinodynamic planning (i.e., when the  `control` parameter is set):</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; `kpiece`,  `rrt`,  `est`,  `pdst`,  `sycloprrt`, and  `syclopest`.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;An example of a minimal SE(2) configuration comparing the rrt and est planners is given below:</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    [problem]</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    name=my_benchmark_problem</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    robot=my_robot_mesh.dae</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    start.x=0.0</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    start.y=0.0</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    start.theta=0.0</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    goal.x=1.0</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    goal.y=1.0</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    goal.theta=0.0</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    [benchmark]</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    time_limit=10.0</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    mem_limit=1000.0</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    run_count = 3</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    [planner]</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    est=</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    rrt=</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;Any parameter defined by these planners may also be configured for the benchmark. For example, the geometric::RRT planner defines two parameters, “range” and “goal_bias”, both real valued. The default values can be changed under the “planner” heading in the following manner:</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;- __rrt.range__=50.0</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;- __rrt.goal_bias__=0.10</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;There are many other optional parameters that can be specified or changed. The `ompl_benchmark` executable takes advantage of the ompl::base::ParamSet class, and uses this functionality to set any parameter defined in the file. If a class exposes a parameter, chances are that it is possible to tune it via the config file. OMPL.app provides two example configuration files inside of the benchmark directory, example.cfg and example_complex.cfg showing the configuration of many of these optional parameters.</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;It is possible to create multiple instances of the same planner and configure each differently. This code, for example, creates two instances of `rrtconnect` with different values for its range parameter:</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    rrtconnect=</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    rrtconnect.range=100</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    rrtconnect=</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    rrtconnect.range=200</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;Moreover, the problem settings can be changed between different planner instances.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;Below, some of the problem settings are changed for the second instance of `kpiece`.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    kpiece=</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    kpiece=</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    # increase the size of the projection by a specific factor, in every dimension</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    problem.projection.cellsize_factor = 4.0</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    # specify a different sampler</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    problem.sampler=obstacle_based</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;When using multiple planner instances, a useful parameter is “name”, as it can be used to rename a planner. For example, two instances of geometric::PRM can be created but named differently. Having different names is useful when processing the resulting log data using the [benchmark script](#benchmark_log).</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    prm=</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    problem.sampler=uniform</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    prm.name=uniprm</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    prm=</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    problem.sampler=obstacle_based</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    prm.name=obprm</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;Finally, to execute the benchmark configuration file, simply run the `ompl_benchmark` executable in the OMPL.app bin directory, and supply the path to the config file as the first argument.</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;\endif</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;Writing benchmarking code {#benchmark_code}</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;-------------------------------------------</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;Benchmarking a set of planners on a specified problem using the Benchmark class in your own code is a simple task in OMPL. The steps involved are as follows:</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;- Configure the benchmark problem using ompl::geometric::SimpleSetup or ompl::control::SimpleSetup</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;- Create a ompl::Benchmark object that takes the problem as input</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;- Optionally, specify some parameters for the benchmark object using ompl::Benchmark::addExperimentParameter, which is useful when aggregating benchmark results over parametrized benchmarks.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;- Add one or more planners to the benchmark</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;- Optionally add events to be called before and/or after the execution of a planner</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;- Run the benchmark problem a specified number of times, subject to specified time and memory limits</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;The following code snippet shows you how to do this. We will start with some initial code that you have probably already used:</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;#include &quot;ompl/tools/benchmark/Benchmark.h&quot;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;// A function that matches the ompl::base::PlannerAllocator type.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;// It will be used later to allocate an instance of EST</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;ompl::base::PlannerPtr myConfiguredPlanner(const ompl::base::SpaceInformationPtr &amp;si)</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;{</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    geometric::EST *est = new ompl::geometric::EST(si);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    est-&gt;setRange(100.0);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    return ompl::base::PlannerPtr(est);</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;}</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;// Create a state space for the space we are planning in</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;ompl::geometric::SimpleSetup ss(space);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;// Configure the problem to solve: set start state(s)</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;// and goal representation</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;// Everything must be set up to the point ss.solve()</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;// can be called. Setting up a planner is not needed.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;~~~</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;Benchmarking code starts here:</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;// First we create a benchmark class:</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;ompl::tools::Benchmark b(ss, &quot;my experiment&quot;);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;// Optionally, specify some benchmark parameters (doesn&#39;t change how the benchmark is run)</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;b.addExperimentParameter(&quot;num_dofs&quot;, &quot;INTEGER&quot;, &quot;6&quot;)</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;b.addExperimentParameter(&quot;num_obstacles&quot;, &quot;INTEGER&quot;, &quot;10&quot;)</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;// We add the planners to evaluate.</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;b.addPlanner(base::PlannerPtr(new geometric::KPIECE1(ss.getSpaceInformation())));</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;b.addPlanner(base::PlannerPtr(new geometric::RRT(ss.getSpaceInformation())));</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;b.addPlanner(base::PlannerPtr(new geometric::SBL(ss.getSpaceInformation())));</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;b.addPlanner(base::PlannerPtr(new geometric::LBKPIECE1(ss.getSpaceInformation())));</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;// etc</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;// For planners that we want to configure in specific ways,</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;// the ompl::base::PlannerAllocator should be used:</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;b.addPlannerAllocator(std::bind(&amp;myConfiguredPlanner, std::placeholders::_1));</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;// etc.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;// Now we can benchmark: 5 second time limit for each plan computation,</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;// 100 MB maximum memory usage per plan computation, 50 runs for each planner</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;// and true means that a text-mode progress bar should be displayed while</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;// computation is running.</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;ompl::tools::Benchmark::Request req;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;req.maxTime = 5.0;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;req.maxMem = 100.0;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;req.runCount = 50;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;req.displayProgress = true;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;b.benchmark(req);</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;// This will generate a file of the form ompl_host_time.log</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;b.saveResultsToFile();</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;~~~</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;Adding callbacks for before and after the execution of a run is also possible:</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;// Assume these functions are defined</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;void optionalPreRunEvent(const base::PlannerPtr &amp;planner)</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;{</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    // do whatever configuration we want to the planner,</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    // including changing of problem definition (input states)</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    // via planner-&gt;getProblemDefinition()</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;}</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;void optionalPostRunEvent(const base::PlannerPtr &amp;planner, tools::Benchmark::RunProperties &amp;run)</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;{</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    // do any cleanup, or set values for upcoming run (or upcoming call to the pre-run event).</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    // adding elements to the set of collected run properties is also possible;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    // (the added data will be recorded in the log file)</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    run[&quot;some extra property name INTEGER&quot;] = &quot;some value&quot;;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    // The format of added data is string key, string value pairs,</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    // with the convention that the last word in string key is one of</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    // REAL, INTEGER, BOOLEAN, STRING. (this will be the type of the field</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    // when the log file is processed and saved as a database).</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    // The values are always converted to string.</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;}</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;// After the Benchmark class is defined, the events can be optionally registered:</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;b.setPreRunEvent(std::bind(&amp;optionalPreRunEvent, std::placeholders::_1));</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;b.setPostRunEvent(std::bind(&amp;optionalPostRunEvent, std::placeholders::_1, std::placeholders::_2));</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;~~~</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;# Processing the benchmarking log file {#benchmark_log}</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;Once the C++ code computing the results has been executed, a log file is generated. This contains information about the settings of the planners, the parameters of the problem tested on, etc. To visualize this information, we provide a script that parses the log files:</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    ompl/scripts/ompl_benchmark_statistics.py logfile.log -d mydatabase.db</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;This will generate a SQLite database containing the parsed data. If no database name is specified, the named is assumed to be benchmark.db. Once this database is generated, we can visualize the results. The recommended way is to upload the database to [Planner Arena](http://plannerarena.org) and navigate through the different plots. Planner Arena can also be run locally with the `plannerarena` script (requires R to be installed). Alternatively, you can also produce some basic plots with `ompl_benchmark_statistics.py` like so:</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    ompl/scripts/ompl_benchmark_statistics.py -d mydatabase.db -p boxplot.pdf</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;This will generate a series of plots, one for each of the attributes described below, showing the results for each planner. [Below](#benchmark_sample_results) we have included some sample benchmark results.</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;If you would like to process the data in different ways, you can generate a dump file that you can load in a MySQL database:</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    ompl/scripts/ompl_benchmark_statistics.py -d mydatabase.db -m mydump.sql</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;For more details on how to use the benchmark script, see:</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    scripts/ompl_benchmark_statistics.py --help</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;Collected benchmark data for each experiment:</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;- __name:__ name of experiment (optional)</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;- __totaltime:__ the total duration for conducting the experiment (seconds)</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;- __timelimit:__ the maximum time allowed for every planner execution (seconds)</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;- __memorylimit:__ the maximum memory allowed for every planner execution (MB)</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;- __hostname:__ the name of the host on which the experiment was run</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;- __date:__ the date and time when the experiment was started</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;Collected benchmark data for each planner execution:</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;- __time:__ (real) the amount of time spent planning, in seconds</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;- __memory:__ (real) the amount of memory spent planning, in MB. Note: this may be inaccurate since memory is often freed in a lazy fashion</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;- __solved:__ (boolean) flag indicating whether the planner found a solution. Note: the solution can be approximate</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;- __approximate solution:__ (boolean) flag indicating whether the found solution is approximate (does not reach the goal, but moves towards it)</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;- __solution difference:__ (real) if the solution is approximate, this is the distance from the end-point of the found approximate solution to the actual goal</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;- __solution length:__ (real) the length of the found solution</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;- __solution smoothness:__ (real) the smoothness of the found solution (the closer to 0, the smoother the path is)</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;- __solution clearance:__ (real) the clearance of the found solution (the higher the value, the larger the distance to invalid regions)</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;- __solution segments:__ (integer) the number of segments on the solution path</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;- __correct solution:__ (boolean) flag indicating whether the found solution is correct (a separate check is conducted). This should always be true.</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;- __correct solution strict:__ (boolean) flag indicating whether the found solution is correct when checked at a finer resolution than the planner used when validating motion segments. If this is sometimes false it means that the used state validation resolution is too high (only applies when using ompl::base::DiscreteMotionValidator).</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;- __simplification time:__ (real) the time spend simplifying the solution path, in seconds</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;- __simplified solution length:__ (real) the length of the found solution after simplification</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;- __simplified solution smoothness:__ (real) the smoothness of the found solution after simplification (the closer to 0, the smoother the path is)</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;- __simplified solution clearance:__ (real) the clearance of the found solution after simplification (the higher the value, the larger the distance to invalid regions)</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;- __simplified solution segments:__ (integer) the number of segments on solution path after simplification</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;- __simplified correct solution:__ (boolean) flag indicating whether the found solution is correct after simplification. This should always be true.</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;- __simplified correct solution strict:__ (boolean) flag indicating whether the found solution is correct after simplification, when checked at a finer resolution.</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;- __graph states:__ (integer) the number of states in the constructed graph</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;- __graph motions:__ (integer) the number of edges (motions) in the constructed graph</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;- __valid segment fraction:__ (real) the fraction of segments that turned out to be valid (using ompl::base::MotionValidator) out of all the segments that were checked for validity</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;- more planner-specific properties</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;Planning algorithms can also register callback functions that the Benchmark class will use to measure progress properties at regular intervals during a run of the planning algorithm. Currently only RRT* uses this functionality. The RRT* constructor registers, among others, a function that returns the cost of the best path found so far:</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    addPlannerProgressProperty(&quot;best cost REAL&quot;, std::bind(&amp;RRTstar::getBestCost, this));</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;With the Benchmark class one can thus measure how the cost is decreasing over time. The ompl_benchmark_statistics.py script will automatically generate plots of progress properties as a function of time.</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;# Sample benchmark results {#benchmark_sample_results}</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;Below are sample results for running benchmarks for two example problems: the “cubicles” environment and the “Twistycool” environment. The complete benchmarking program (SE3RigidBodyPlanningBenchmark.cpp), the environment and robot files are included with OMPL.app, so you can rerun the exact same benchmarks on your own machine. See the [gallery](gallery.html#gallery_omplapp) for visualizations of sample solutions to both problems. The results below were run on a recent model Apple MacBook Pro (2.66 GHz Intel Core i7, 8GB of RAM). It is important to note that none of the planner parameters were tuned; all benchmarks were run with default settings. From these results one cannot draw any firm conclusions about which planner is “better” than some other planner.</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;These are the PDF files with plots as generated by the ompl_benchmark_statistics.py script:</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;- [The “cubicles” problem with default settings](images/cubicles.pdf)</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;- [The “Twistycool” problem with default settings](images/Twistycool.pdf)</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;The plots show comparisons between ompl::geometric::RRTConnect, ompl::geometric::RRT, ompl::geometric::BKPIECE1, ompl::geometric::LBKPIECE1, ompl::geometric::KPIECE1, ompl::geometric::SBL, ompl::geometric::EST, and ompl::geometric::PRM. Each planner is run 500 times with a 10 second time limit for the cubicles problem for each sampling strategy, while for the Twistycool problem each planner is run 50 times with a 60 second time limit.</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;For integer and real-valued measurements the script will compute [box plots](http://en.wikipedia.org/wiki/Box_plot). For example, here is the plot for the real-valued attribute __time__ for the cubicles environment:</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;&lt;div class=&quot;row&quot;&gt;&lt;img src=&quot;images/cubicles_time.png&quot; class=&quot;col-md-8 col-sm-10 col-md-offset-2 col-sm-offset-1 img-responsive&quot;&gt;&lt;/div&gt;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;For boolean measurements the script will create bar charts with the percentage of __true__ values. For example, here is the plot for the boolean attribute __solved__ for the Twistycool environment, a much harder problem:</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;&lt;div class=&quot;row&quot;&gt;&lt;img src=&quot;images/Twistycool_solved.png&quot; class=&quot;col-md-8 col-sm-10 col-md-offset-2 col-sm-offset-1 img-responsive&quot;&gt;&lt;/div&gt;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;Whenever measurements are not always available for a particular attribute, the columns for each planner are labeled with the number of runs for which no data was available. For instance, the boolean attribute __correct solution__ is not set if a solution is not found.</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;# The benchmark logfile format {#benchmark_logfile_format}</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;The benchmark log files have a pretty simple structure. Below we have included their syntax in [Extended Backus-Naur Form](https://en.wikipedia.org/wiki/Extended_Backus–Naur_Form). This may be useful for someone interested in extending other planning libraries with similar logging capabilities (which would be helpful in a direct comparison of the performance of planning libraries). Log files in this format can be parsed by ompl_benchmark_statistics.py (see next section).</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;~~~</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;logfile               ::= preamble planners_data;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;preamble              ::= [version] experiment [exp_property_count exp_properties] hostname date setup [cpuinfo]</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                          random_seed time_limit memory_limit [num_runs]</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                          total_time [num_enums enums] num_planners;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;version               ::= library_name &quot; version &quot; version_number EOL;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;experiment            ::= &quot;Experiment &quot; experiment_name EOL;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;exp_property_count    ::= int &quot; experiment properties&quot; EOL;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;exp_properties        ::= exp_property | exp_property exp_properties;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;exp_property          ::= name property_type &quot;=&quot; num EOL;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;hostname              ::= &quot;Running on &quot; host EOL;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;date                  ::= &quot;Starting at &quot; date_string EOL;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;setup                 ::= multi_line_string;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;cpuinfo               ::= multi_line_string;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;multi_line_string     ::= &quot;&lt;&lt;&lt;|&quot; EOL strings &quot;|&gt;&gt;&gt;&quot; EOL;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;strings               ::= string EOL | string EOL strings</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;random_seed           ::= int &quot; is the random seed&quot; EOL;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;time_limit            ::= float &quot; seconds per run&quot; EOL;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;memory_limit          ::= float &quot; MB per run&quot; EOL;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;num_runs              ::= int &quot; runs per planner&quot; EOL;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;total_time            ::= float &quot; seconds spent to collect the data&quot; EOL;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;num_enums             ::= num &quot; enum type&quot; EOL;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;enums                 ::= enum | enum enums;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;enum                  ::= enum_name &quot;|&quot; enum_values EOL;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;enum_values           ::= enum_value | enum_value &quot;|&quot; enum_values;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;num_planners          ::= int &quot; planners&quot; EOL;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;planners_data         ::= planner_data | planner_data planners_data;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;planner_data          ::= planner_name EOL int &quot; common properties&quot; EOL</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                          planner_properties int &quot; properties for each run&quot; EOL</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                          run_properties int &quot; runs&quot; EOL run_measurements</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                          [int &quot;progress properties for each run&quot; EOL</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                          progress_properties int &quot; runs&quot; EOL</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                          progress_measurements] &quot;.&quot; EOL;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;planner_properties    ::= &quot;&quot; | planner_property planner_properties;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;planner_property      ::= property_name &quot; = &quot; property_value EOL;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;run_properties        ::= property | property run_properties;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;progress_properties   ::= property | property progress_properties;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;property              ::= property_name &quot; &quot; property_type EOL;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;property_type         ::= &quot;BOOLEAN&quot; | &quot;INTEGER&quot; | &quot;REAL&quot;;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;run_measurements      ::= run_measurement | run_measurement run_measurements;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;run_measurement       ::= data &quot;; &quot; | data &quot;; &quot; run_measurement;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;data                  ::= num | &quot;inf&quot; | &quot;nan&quot; | &quot;&quot;;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;progress_measurements ::= progress_measurement EOL</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                         | progress_measurement EOL progress_measurements;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;progress_measurement  ::= prog_run_data | prog_run_data &quot;;&quot; progress_measurement;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;prog_run_data         ::= data &quot;,&quot; | data &quot;,&quot; prog_run_data;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;~~~</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;Here, `EOL` denotes a newline character, `int` denotes an integer, `float` denotes a floating point number, `num` denotes an integer or float value and undefined symbols correspond to strings without whitespace characters. The exception is `property_name` which is a string that _can_ have whitespace characters. It is also assumed that if the log file says there is data for _k_ planners that that really is the case (likewise for the number of run measurements and the optional progress measurements).</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;# The benchmark database schema {#benchmark_database}</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;&lt;div class=&quot;col-sm-4 pull-right&quot;&gt;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  &lt;img src=&quot;images/benchmarkdb_schema.png&quot; width=&quot;100%&quot;&gt;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  &lt;br/&gt;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  &lt;b&gt;The benchmark database schema&lt;/b&gt;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;The ompl_benchmark_statistics.py script can produce a series of plots from a database of benchmark results, but in many cases you may want to produce your own custom plots. For this it useful to understand the schema used for the database. There are five tables in a benchmark database:</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;- **experiments**. This table contains the following information:</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  - *id:* an ID used in the `runs` table to denote that a run was part of a given experiment.</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  - *name:* name of the experiment.</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  - *totaltime:* total duration of the experiment in seconds.</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  - *timelimit:* time limit for each individual run in seconds.</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  - *memorylimit:* memory limit for each individual run in MB.</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  - *runcount:* the number of times each planner configuration was run.</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  - *version:* the version of OMPL that was used.</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  - *hostname:* the host name of the machine on which the experiment was performed.</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  - *cpuinfo:* CPU information about the machine on which the experiment was performed.</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  - *date:* the date on which the experiment was performed.</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  - *seed:* the random seed used.</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  - *setup:* a string containing a “print-out” of all the settings of the SimpleSetup object used during benchmarking.</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;- **plannerConfigs**. There are a number of planner types (such as PRM and RRT), but each planner can typically be configured with a number of parameters. A planner configuration refers to a planner type with specific parameter settings. The `plannerConfigs` table contains the following information:</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  - *id:* an ID used in the `runs` table to denote that a given planner configuration was used for a run.</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  - *name:* the name of the configuration. This can be just the planner name, but when using different parameter settings of the same planner it is essential to use more specific names.</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  - *settings:* a string containing a “print-out” of all the settings of the planner.</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;- **enums**: This table contains description of enumerate types that are measured during benchmarking. By default there is only one such such type defined: ompl::base::PlannerStatus. The table contains the following information:</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  - *name:* name of the enumerate type (e.g., “status”).</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  - *value:* numerical value used in the runs</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  - *description:* text description of each value (e.g. “Exact solution,” “Approximate solution,” “Timeout,” etc.)</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;- **runs**. The `runs` table contains information for every run in every experiment. Each run is identified by the following fields:</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  - *id:* ID of the run</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  - *experimentid:* ID of the experiment to which this run belonged.</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  - *plannerid:* ID of the planner configuration used for this run.</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  .</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  In addition, there will be many benchmark statistics. None are *required*, but the OMPL planners all report the properties described above such as time, memory, solution length, simplification time, etc. It is possible that not all planners report the same properties. In that case, planners that do not report such properties will have NULL values in the corresponding fields.</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;- **progress**. Some planners (such as RRT*) can also periodically report properties *during* a run. This can be useful to analyze the convergence or growth rate. The `progress` table contains the following information:</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  - *runid:* the ID of the run for which progress data was tracked.</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  - *time:* the time (in sec.) at which the property was measured.</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  .</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  The actual properties stored depend on the planner, but in the case of RRT* it stores the following additional fields:</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  - *iterations:* the number of iterations.</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  - *collision_checks:* the number of collision checks (or, more precisely, the number state validator calls).</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  - *best_cost:* the cost of the best solution found so far.</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;Using SQL queries one can easily select a subset of the data or compute &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_(SQL)&quot;&gt;joins&lt;/a&gt; of tables.</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;Consider the following snippet of R code:</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;~~~{.splus}</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;library(&quot;ggplot2&quot;)</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;library(&quot;RSQLite&quot;)</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;con &lt;- dbConnect(dbDriver(&quot;SQLite&quot;), &quot;benchmark.db&quot;)</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;# read data</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;runs &lt;- dbGetQuery(con, &quot;SELECT REPLACE(plannerConfigs.name,&#39;geometric_&#39;,&#39;&#39;) AS name, runs.* FROM plannerConfigs INNER JOIN runs ON plannerConfigs.id = runs.plannerid&quot;)</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;progress &lt;- dbGetQuery(con, &quot;SELECT REPLACE(plannerConfigs.name,&#39;geometric_&#39;,&#39;&#39;) AS name, progress.* FROM plannerConfigs INNER JOIN runs INNER JOIN progress ON plannerConfigs.id=runs.plannerid AND runs.id=progress.runid&quot;)</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;# plot some data</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;pdf(&#39;plots.pdf&#39;, width=8, height=6)</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;qplot(name, time, data=runs, geom=c(&quot;jitter&quot;,&quot;boxplot&quot;))</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;qplot(time, best_cost, data=progress, alpha=I(1/2), colour=name, geom=c(&quot;point&quot;, &quot;smooth&quot;))</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;dev.off()</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;dbDisconnect(con)</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;~~~</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;For a small database with 1 experiment (the “cubicles” problem from OMPL.app) and 5 planner configurations we then obtain the following two plots:</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;\htmlonly</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;&lt;div class=&quot;row&quot;&gt;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;&lt;div class=&quot;col-md-6 col-sm-6&quot;&gt;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  &lt;img src=&quot;images/R_time.png&quot; width=&quot;100%&quot;&gt;&lt;br&gt;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;&lt;b&gt;Time to find a solution.&lt;/b&gt; Note that that RRT* does not terminate because it keeps trying to find a more optimal solution.</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;&lt;div class=&quot;col-md-6 col-sm-6&quot;&gt;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  &lt;img src=&quot;images/R_progress.png&quot; width=&quot;100%&quot;&gt;&lt;br&gt;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;&lt;b&gt;Length of shortest path found after a given number of seconds.&lt;/b&gt; Only RRT* currently uses progress properties. Although the variability among individual runs is quite high, one can definitely tell that different parameter settings (for the range in this case) lead to statistically significant different behavior.</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;\endhtmlonly</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;\note Similar code is used for [Planner Arena](http://plannerarena.org), a web site for interactive visualization of benchmark databases. The Planner Arena code is part of the OMPL source. Instructions for running Planner Arena locally can be found [here](plannerarena.html).</div></div><!-- fragment --></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</body>
</html>
