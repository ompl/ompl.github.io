<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.9.3"/>
  <title>ompl::base::PlannerData Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="jquery.js"></script>
  <script src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-expand-md fixed-top navbar-dark">
      <a class="navbar-brand" href="./index.html">OMPL</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
          <li class="nav-item"><a class="nav-link" href="download.html">Download</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="docDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Documentation</a>
            <div class="dropdown-menu" aria-labelledby="docDropdown">
              <a class="dropdown-item" href="https://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a>
              <a class="dropdown-item" href="installation.html">Installation</a>
              <a class="dropdown-item" href="tutorials.html">Tutorials</a>
              <a class="dropdown-item" href="group__demos.html">Demos</a>
              <a class="dropdown-item omplapp" href="gui.html">OMPL.app GUI</a>
              <a class="dropdown-item omplapp" href="webapp.html">OMPL web app</a>
              <a class="dropdown-item" href="python.html">Python Bindings</a>
              <a class="dropdown-item" href="planners.html">Available Planners</a>
              <a class="dropdown-item" href="plannerTerminationConditions.html">Planner Termination Conditions</a>
              <a class="dropdown-item" href="benchmark.html">Benchmarking Planners</a>
              <a class="dropdown-item" href="spaces.html">Available State Spaces</a>
              <a class="dropdown-item" href="optimalPlanning.html">Optimal Planning</a>
              <a class="dropdown-item" href="constrainedPlanning.html">Constrained Planning</a>
              <a class="dropdown-item" href="multiLevelPlanning.html">Multilevel Planning</a>
              <a class="dropdown-item" href="FAQ.html">FAQ</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">External links</div>
              <a class="dropdown-item" href="http://moveit.ros.org">MoveIt</a>
              <a class="dropdown-item" href="http://plannerarena.org">Planner Arena</a>
              <a class="dropdown-item" href="https://moveit.ros.org//moveit!/ros/2013/05/07/icra-motion-planning-tutorial.html">ICRA 2013 Tutorial</a>
              <a class="dropdown-item" href="http://kavrakilab.org/iros2011/">IROS 2011 Tutorial</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="gallery.html">Gallery</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="codeDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Code</a>
            <div class="dropdown-menu" aria-labelledby="codeDropdown">
              <a class="dropdown-item" href="api_overview.html">API Overview</a>
              <a class="dropdown-item" href="annotated.html">Classes</a>
              <a class="dropdown-item" href="files.html">Files</a>
              <a class="dropdown-item" href="styleGuide.html">Style Guide</a>
              <a class="dropdown-item" href="integration.html">Use OMPL within Other Systems</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">Repositories</div>
              <a class="dropdown-item" href="https://github.com/ompl/ompl">ompl on GitHub</a>
              <a class="dropdown-item" href="https://github.com/ompl/omplapp">omplapp on GitHub</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">Continuous Integration</div>
              <a class="dropdown-item" href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux/macOS)</a>
              <a class="dropdown-item" href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux/macOS)</a>
              <a class="dropdown-item" href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a>
              <a class="dropdown-item" href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://github.com/ompl/ompl/issues">Issues</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="communityDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Community</a>
            <div class="dropdown-menu" aria-labelledby="communityDropdown">
              <a class="dropdown-item" href="support.html">Get Support</a>
              <a class="dropdown-item" href="developers.html">Developers/Contributors</a>
              <a class="dropdown-item" href="contrib.html">Submit a Contribution</a>
              <a class="dropdown-item" href="education.html">Education</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="aboutDropdown" role="button"  data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">About</a>
            <div class="dropdown-menu" aria-labelledby="aboutDropdown">
              <a class="dropdown-item" href="license.html">License</a>
              <a class="dropdown-item" href="citations.html">Citations</a>
              <a class="dropdown-item" href="acknowledgements.html">Acknowledgments</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://ompl.kavrakilab.org/blog.html">Blog</a></li>
        </ul>
                <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </div>
    </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceompl.html">ompl</a></li><li class="navelem"><a class="el" href="namespaceompl_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classompl_1_1base_1_1PlannerData-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ompl::base::PlannerData Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Object containing planner generated vertex and edge data. It is assumed that all vertices are unique, and only a single directed edge connects two vertices.  
 <a href="classompl_1_1base_1_1PlannerData.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="base_2PlannerData_8h_source.html">ompl/base/PlannerData.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ompl::base::PlannerData:</div>
<div class="dyncontent">
<div class="center"><img src="classompl_1_1base_1_1PlannerData__inherit__graph.png" border="0" usemap="#aompl_1_1base_1_1PlannerData_inherit__map" alt="Inheritance graph"/></div>
<map name="aompl_1_1base_1_1PlannerData_inherit__map" id="aompl_1_1base_1_1PlannerData_inherit__map">
<area shape="rect" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,..." alt="" coords="11,5,177,32"/>
<area shape="rect" href="classompl_1_1control_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,..." alt="" coords="5,80,183,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for the Boost.Graph representation of the <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>. This class inherits from a boost::adjacency_list <a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html" title="Wrapper class for the Boost.Graph representation of the PlannerData. This class inherits from a boost...">Graph</a> structure.  <a href="classompl_1_1base_1_1PlannerData_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a678d3e4e9646fe7e1de008d5a1cf128c"><td class="memItemLeft" align="right" valign="top"><a id="a678d3e4e9646fe7e1de008d5a1cf128c" name="a678d3e4e9646fe7e1de008d5a1cf128c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PlannerData</b> (const <a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;)=delete</td></tr>
<tr class="separator:a678d3e4e9646fe7e1de008d5a1cf128c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00c84de2b464a03df8c5f676f2219cc"><td class="memItemLeft" align="right" valign="top"><a id="af00c84de2b464a03df8c5f676f2219cc" name="af00c84de2b464a03df8c5f676f2219cc"></a>
<a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;)=delete</td></tr>
<tr class="separator:af00c84de2b464a03df8c5f676f2219cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086299be02adc8ae0438c111e2f3ae01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a086299be02adc8ae0438c111e2f3ae01">PlannerData</a> (<a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a> si)</td></tr>
<tr class="memdesc:a086299be02adc8ae0438c111e2f3ae01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Accepts a <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html" title="A shared pointer wrapper for ompl::base::SpaceInformation.">SpaceInformationPtr</a> for the space planned in.  <a href="classompl_1_1base_1_1PlannerData.html#a086299be02adc8ae0438c111e2f3ae01">More...</a><br /></td></tr>
<tr class="separator:a086299be02adc8ae0438c111e2f3ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaae435c61fbc1f4c894da0140830e68"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aeaae435c61fbc1f4c894da0140830e68">~PlannerData</a> ()</td></tr>
<tr class="memdesc:aeaae435c61fbc1f4c894da0140830e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classompl_1_1base_1_1PlannerData.html#aeaae435c61fbc1f4c894da0140830e68">More...</a><br /></td></tr>
<tr class="separator:aeaae435c61fbc1f4c894da0140830e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bb330cab0346857dd1a40fb059f71c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a25bb330cab0346857dd1a40fb059f71c">getSpaceInformation</a> () const</td></tr>
<tr class="memdesc:a25bb330cab0346857dd1a40fb059f71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the instance of <a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">SpaceInformation</a> used in this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>.  <a href="classompl_1_1base_1_1PlannerData.html#a25bb330cab0346857dd1a40fb059f71c">More...</a><br /></td></tr>
<tr class="separator:a25bb330cab0346857dd1a40fb059f71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac361b543229e46d4dfb6d954a814fc0e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac361b543229e46d4dfb6d954a814fc0e">hasControls</a> () const</td></tr>
<tr class="memdesc:ac361b543229e46d4dfb6d954a814fc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether any information about controls (<a class="el" href="classompl_1_1control_1_1Control.html" title="Definition of an abstract control.">ompl::control::Control</a>) is stored in this instance.  <a href="classompl_1_1base_1_1PlannerData.html#ac361b543229e46d4dfb6d954a814fc0e">More...</a><br /></td></tr>
<tr class="separator:ac361b543229e46d4dfb6d954a814fc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData construction</div></td></tr>
<tr class="memitem:ac61c5ab5cfd6a66a58e03b1731c1e454"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac61c5ab5cfd6a66a58e03b1731c1e454">addVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;st)</td></tr>
<tr class="memdesc:ac61c5ab5cfd6a66a58e03b1731c1e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vertex to the graph data. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex.  <a href="classompl_1_1base_1_1PlannerData.html#ac61c5ab5cfd6a66a58e03b1731c1e454">More...</a><br /></td></tr>
<tr class="separator:ac61c5ab5cfd6a66a58e03b1731c1e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eea84456784452486aa0065af391f47"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a2eea84456784452486aa0065af391f47">addStartVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v)</td></tr>
<tr class="memdesc:a2eea84456784452486aa0065af391f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex.  <a href="classompl_1_1base_1_1PlannerData.html#a2eea84456784452486aa0065af391f47">More...</a><br /></td></tr>
<tr class="separator:a2eea84456784452486aa0065af391f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3604cb85b0402b09b319c5f1df02b12e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a3604cb85b0402b09b319c5f1df02b12e">addGoalVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v)</td></tr>
<tr class="memdesc:a3604cb85b0402b09b319c5f1df02b12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex.  <a href="classompl_1_1base_1_1PlannerData.html#a3604cb85b0402b09b319c5f1df02b12e">More...</a><br /></td></tr>
<tr class="separator:a3604cb85b0402b09b319c5f1df02b12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ebd34b6da9efd9ec7647155f9173c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a48ebd34b6da9efd9ec7647155f9173c9">markStartState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *st)</td></tr>
<tr class="memdesc:a48ebd34b6da9efd9ec7647155f9173c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given state as a start vertex. If the given state does not exist in a vertex, false is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a48ebd34b6da9efd9ec7647155f9173c9">More...</a><br /></td></tr>
<tr class="separator:a48ebd34b6da9efd9ec7647155f9173c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7772ac307d153831c0e7ecfc4fb1c18b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7772ac307d153831c0e7ecfc4fb1c18b">markGoalState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *st)</td></tr>
<tr class="memdesc:a7772ac307d153831c0e7ecfc4fb1c18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given state as a goal vertex. If the given state does not exist in a vertex, false is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a7772ac307d153831c0e7ecfc4fb1c18b">More...</a><br /></td></tr>
<tr class="separator:a7772ac307d153831c0e7ecfc4fb1c18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0b7c124dcac4f07c5f6d0ab51386a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a2b0b7c124dcac4f07c5f6d0ab51386a6">tagState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *st, int tag)</td></tr>
<tr class="memdesc:a2b0b7c124dcac4f07c5f6d0ab51386a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the integer tag associated with the given state. If the given state does not exist in a vertex, false is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a2b0b7c124dcac4f07c5f6d0ab51386a6">More...</a><br /></td></tr>
<tr class="separator:a2b0b7c124dcac4f07c5f6d0ab51386a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a2c3ad28a32136c74ad9f841727f01"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a75a2c3ad28a32136c74ad9f841727f01">removeVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;st)</td></tr>
<tr class="memdesc:a75a2c3ad28a32136c74ad9f841727f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the vertex associated with the given data. If the vertex does not exist, false is returned. This method has O(n) complexity in the number of vertices.  <a href="classompl_1_1base_1_1PlannerData.html#a75a2c3ad28a32136c74ad9f841727f01">More...</a><br /></td></tr>
<tr class="separator:a75a2c3ad28a32136c74ad9f841727f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313c0b88697387feebff969c307193c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7313c0b88697387feebff969c307193c">removeVertex</a> (unsigned int vIndex)</td></tr>
<tr class="memdesc:a7313c0b88697387feebff969c307193c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the vertex with the given index. If the index is out of range, false is returned. This method has O(n) complexity in the number of vertices.  <a href="classompl_1_1base_1_1PlannerData.html#a7313c0b88697387feebff969c307193c">More...</a><br /></td></tr>
<tr class="separator:a7313c0b88697387feebff969c307193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c21494a8c7db500ef1a66bbbb1aa7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac09c21494a8c7db500ef1a66bbbb1aa7">addEdge</a> (unsigned int v1, unsigned int v2, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;edge=<a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>(), <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a> weight=<a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>(1.0))</td></tr>
<tr class="memdesc:ac09c21494a8c7db500ef1a66bbbb1aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge between the given vertex indexes. An optional edge structure and weight can be supplied. Success is returned.  <a href="classompl_1_1base_1_1PlannerData.html#ac09c21494a8c7db500ef1a66bbbb1aa7">More...</a><br /></td></tr>
<tr class="separator:ac09c21494a8c7db500ef1a66bbbb1aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2685cb2025517bdc0ee1ba94b9aff49"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ad2685cb2025517bdc0ee1ba94b9aff49">addEdge</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v1, const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v2, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;edge=<a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>(), <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a> weight=<a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>(1.0))</td></tr>
<tr class="memdesc:ad2685cb2025517bdc0ee1ba94b9aff49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge between the given vertex indexes. The vertices are added to the data if they are not already in the structure. An optional edge structure and weight can also be supplied. Success is returned.  <a href="classompl_1_1base_1_1PlannerData.html#ad2685cb2025517bdc0ee1ba94b9aff49">More...</a><br /></td></tr>
<tr class="separator:ad2685cb2025517bdc0ee1ba94b9aff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ab62a502c3f80ae2663150e79bcea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a991ab62a502c3f80ae2663150e79bcea">removeEdge</a> (unsigned int v1, unsigned int v2)</td></tr>
<tr class="memdesc:a991ab62a502c3f80ae2663150e79bcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge between vertex indexes <em>v1</em> and <em>v2</em>. Success is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a991ab62a502c3f80ae2663150e79bcea">More...</a><br /></td></tr>
<tr class="separator:a991ab62a502c3f80ae2663150e79bcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda397cf585cc647d1e9b212b6092b0e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#afda397cf585cc647d1e9b212b6092b0e">removeEdge</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v1, const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v2)</td></tr>
<tr class="memdesc:afda397cf585cc647d1e9b212b6092b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge between the vertices associated with the given vertex data. Success is returned.  <a href="classompl_1_1base_1_1PlannerData.html#afda397cf585cc647d1e9b212b6092b0e">More...</a><br /></td></tr>
<tr class="separator:afda397cf585cc647d1e9b212b6092b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7378bbca3f1006b70976292266277eb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7378bbca3f1006b70976292266277eb9">clear</a> ()</td></tr>
<tr class="memdesc:a7378bbca3f1006b70976292266277eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the entire data structure.  <a href="classompl_1_1base_1_1PlannerData.html#a7378bbca3f1006b70976292266277eb9">More...</a><br /></td></tr>
<tr class="separator:a7378bbca3f1006b70976292266277eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01506ec2ff32596dcb1bd9dfa2f8e1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#af01506ec2ff32596dcb1bd9dfa2f8e1d">decoupleFromPlanner</a> ()</td></tr>
<tr class="memdesc:af01506ec2ff32596dcb1bd9dfa2f8e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of the states contained in the vertices of this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> structure so that when the planner that created this instance goes out of scope, all data remains intact.  <a href="classompl_1_1base_1_1PlannerData.html#af01506ec2ff32596dcb1bd9dfa2f8e1d">More...</a><br /></td></tr>
<tr class="separator:af01506ec2ff32596dcb1bd9dfa2f8e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData Properties</div></td></tr>
<tr class="memitem:a383876c22dd92deeed0a536c10f7ecd4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a383876c22dd92deeed0a536c10f7ecd4">numEdges</a> () const</td></tr>
<tr class="memdesc:a383876c22dd92deeed0a536c10f7ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of edges in this structure.  <a href="classompl_1_1base_1_1PlannerData.html#a383876c22dd92deeed0a536c10f7ecd4">More...</a><br /></td></tr>
<tr class="separator:a383876c22dd92deeed0a536c10f7ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877a673801134168cba0581b277cae79"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a877a673801134168cba0581b277cae79">numVertices</a> () const</td></tr>
<tr class="memdesc:a877a673801134168cba0581b277cae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of vertices in this structure.  <a href="classompl_1_1base_1_1PlannerData.html#a877a673801134168cba0581b277cae79">More...</a><br /></td></tr>
<tr class="separator:a877a673801134168cba0581b277cae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c83a71e59cc10492b96c52990124d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a9b7c83a71e59cc10492b96c52990124d">numStartVertices</a> () const</td></tr>
<tr class="memdesc:a9b7c83a71e59cc10492b96c52990124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of start vertices.  <a href="classompl_1_1base_1_1PlannerData.html#a9b7c83a71e59cc10492b96c52990124d">More...</a><br /></td></tr>
<tr class="separator:a9b7c83a71e59cc10492b96c52990124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1145957cc29ef8e8328b8f31b9216a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#acc1145957cc29ef8e8328b8f31b9216a">numGoalVertices</a> () const</td></tr>
<tr class="memdesc:acc1145957cc29ef8e8328b8f31b9216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of goal vertices.  <a href="classompl_1_1base_1_1PlannerData.html#acc1145957cc29ef8e8328b8f31b9216a">More...</a><br /></td></tr>
<tr class="separator:acc1145957cc29ef8e8328b8f31b9216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData vertex lookup</div></td></tr>
<tr class="memitem:acad3f862d6764941928dd3d69efa9a9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#acad3f862d6764941928dd3d69efa9a9c">vertexExists</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v) const</td></tr>
<tr class="memdesc:acad3f862d6764941928dd3d69efa9a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a vertex exists with the given vertex data.  <a href="classompl_1_1base_1_1PlannerData.html#acad3f862d6764941928dd3d69efa9a9c">More...</a><br /></td></tr>
<tr class="separator:acad3f862d6764941928dd3d69efa9a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebe83e30a20d7d79e26f18bf228e8bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#abebe83e30a20d7d79e26f18bf228e8bb">getVertex</a> (unsigned int index) const</td></tr>
<tr class="memdesc:abebe83e30a20d7d79e26f18bf228e8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the vertex object with the given index. If this vertex does not exist, NO_VERTEX is returned.  <a href="classompl_1_1base_1_1PlannerData.html#abebe83e30a20d7d79e26f18bf228e8bb">More...</a><br /></td></tr>
<tr class="separator:abebe83e30a20d7d79e26f18bf228e8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1f2a259a8861ee5a88e51cc52f69e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7e1f2a259a8861ee5a88e51cc52f69e5">getVertex</a> (unsigned int index)</td></tr>
<tr class="memdesc:a7e1f2a259a8861ee5a88e51cc52f69e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the vertex object with the given index. If this vertex does not exist, NO_VERTEX is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a7e1f2a259a8861ee5a88e51cc52f69e5">More...</a><br /></td></tr>
<tr class="separator:a7e1f2a259a8861ee5a88e51cc52f69e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e140727e79440c47c275a52bfd0604"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab2e140727e79440c47c275a52bfd0604">getStartVertex</a> (unsigned int i) const</td></tr>
<tr class="memdesc:ab2e140727e79440c47c275a52bfd0604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith start vertex object. If <em>i</em> is greater than the number of start vertices, NO_VERTEX is returned.  <a href="classompl_1_1base_1_1PlannerData.html#ab2e140727e79440c47c275a52bfd0604">More...</a><br /></td></tr>
<tr class="separator:ab2e140727e79440c47c275a52bfd0604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01edd29349d34cd7ca62384cecf7e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ae01edd29349d34cd7ca62384cecf7e7d">getStartVertex</a> (unsigned int i)</td></tr>
<tr class="memdesc:ae01edd29349d34cd7ca62384cecf7e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith start vertex object. If <em>i</em> is greater than the number of start vertices, NO_VERTEX is returned.  <a href="classompl_1_1base_1_1PlannerData.html#ae01edd29349d34cd7ca62384cecf7e7d">More...</a><br /></td></tr>
<tr class="separator:ae01edd29349d34cd7ca62384cecf7e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc67731741c9990a749307fd558161c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#acc67731741c9990a749307fd558161c1">getGoalVertex</a> (unsigned int i) const</td></tr>
<tr class="memdesc:acc67731741c9990a749307fd558161c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith goal vertex object. If <em>i</em> is greater than the number of goal vertices, NO_VERTEX is returned.  <a href="classompl_1_1base_1_1PlannerData.html#acc67731741c9990a749307fd558161c1">More...</a><br /></td></tr>
<tr class="separator:acc67731741c9990a749307fd558161c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0740003f5170235f3133162db36f1f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0740003f5170235f3133162db36f1f23">getGoalVertex</a> (unsigned int i)</td></tr>
<tr class="memdesc:a0740003f5170235f3133162db36f1f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith goal vertex object. If <em>i</em> is greater than the number of goal vertices, NO_VERTEX is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a0740003f5170235f3133162db36f1f23">More...</a><br /></td></tr>
<tr class="separator:a0740003f5170235f3133162db36f1f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcd8fb4d13be0c272ccf538f5372f39"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a1fcd8fb4d13be0c272ccf538f5372f39">getStartIndex</a> (unsigned int i) const</td></tr>
<tr class="memdesc:a1fcd8fb4d13be0c272ccf538f5372f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the ith start state. INVALID_INDEX is returned if <em>i</em> is out of range. Indexes are volatile and may change after adding/removing a vertex.  <a href="classompl_1_1base_1_1PlannerData.html#a1fcd8fb4d13be0c272ccf538f5372f39">More...</a><br /></td></tr>
<tr class="separator:a1fcd8fb4d13be0c272ccf538f5372f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba488b5f384fa3dedd07dc7b974a14d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#abba488b5f384fa3dedd07dc7b974a14d">getGoalIndex</a> (unsigned int i) const</td></tr>
<tr class="memdesc:abba488b5f384fa3dedd07dc7b974a14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the ith goal state. INVALID_INDEX is returned if <em>i</em> is out of range Indexes are volatile and may change after adding/removing a vertex.  <a href="classompl_1_1base_1_1PlannerData.html#abba488b5f384fa3dedd07dc7b974a14d">More...</a><br /></td></tr>
<tr class="separator:abba488b5f384fa3dedd07dc7b974a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9fe3b3b96c759bcae567743d404471"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#adc9fe3b3b96c759bcae567743d404471">isStartVertex</a> (unsigned int index) const</td></tr>
<tr class="memdesc:adc9fe3b3b96c759bcae567743d404471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given vertex index is marked as a start vertex.  <a href="classompl_1_1base_1_1PlannerData.html#adc9fe3b3b96c759bcae567743d404471">More...</a><br /></td></tr>
<tr class="separator:adc9fe3b3b96c759bcae567743d404471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ba153dc627b6d44c691b49a5f99c9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a14ba153dc627b6d44c691b49a5f99c9b">isGoalVertex</a> (unsigned int index) const</td></tr>
<tr class="memdesc:a14ba153dc627b6d44c691b49a5f99c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given vertex index is marked as a goal vertex.  <a href="classompl_1_1base_1_1PlannerData.html#a14ba153dc627b6d44c691b49a5f99c9b">More...</a><br /></td></tr>
<tr class="separator:a14ba153dc627b6d44c691b49a5f99c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06792592713e6463c4b9814f2a715b4c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a06792592713e6463c4b9814f2a715b4c">vertexIndex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v) const</td></tr>
<tr class="memdesc:a06792592713e6463c4b9814f2a715b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index for the vertex associated with the given data. INVALID_INDEX is returned if this vertex does not exist. Indexes are volatile and may change after adding/removing a vertex.  <a href="classompl_1_1base_1_1PlannerData.html#a06792592713e6463c4b9814f2a715b4c">More...</a><br /></td></tr>
<tr class="separator:a06792592713e6463c4b9814f2a715b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData edge lookup</div></td></tr>
<tr class="memitem:a0b9ec6cbf900b5c08c3a744c119181d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0b9ec6cbf900b5c08c3a744c119181d8">edgeExists</a> (unsigned int v1, unsigned int v2) const</td></tr>
<tr class="memdesc:a0b9ec6cbf900b5c08c3a744c119181d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an edge between vertex index <em>v1</em> and index <em>v2</em> exists.  <a href="classompl_1_1base_1_1PlannerData.html#a0b9ec6cbf900b5c08c3a744c119181d8">More...</a><br /></td></tr>
<tr class="separator:a0b9ec6cbf900b5c08c3a744c119181d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1702251b05069848409efade85a3605"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab1702251b05069848409efade85a3605">getEdge</a> (unsigned int v1, unsigned int v2) const</td></tr>
<tr class="memdesc:ab1702251b05069848409efade85a3605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the edge object connecting vertices with indexes <em>v1</em> and <em>v2</em>. If this edge does not exist, NO_EDGE is returned.  <a href="classompl_1_1base_1_1PlannerData.html#ab1702251b05069848409efade85a3605">More...</a><br /></td></tr>
<tr class="separator:ab1702251b05069848409efade85a3605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dd016470505a10e245a570e1979de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a42dd016470505a10e245a570e1979de3">getEdge</a> (unsigned int v1, unsigned int v2)</td></tr>
<tr class="memdesc:a42dd016470505a10e245a570e1979de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the edge object connecting vertices with indexes <em>v1</em> and <em>v2</em>. If this edge does not exist, NO_EDGE is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a42dd016470505a10e245a570e1979de3">More...</a><br /></td></tr>
<tr class="separator:a42dd016470505a10e245a570e1979de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa459ac8581242046b24c9ee17d7b5c34"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aa459ac8581242046b24c9ee17d7b5c34">getEdges</a> (unsigned int v, std::vector&lt; unsigned int &gt; &amp;edgeList) const</td></tr>
<tr class="memdesc:aa459ac8581242046b24c9ee17d7b5c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the vertex indexes directly connected to vertex with index <em>v</em> (outgoing edges). The number of outgoing edges from <em>v</em> is returned.  <a href="classompl_1_1base_1_1PlannerData.html#aa459ac8581242046b24c9ee17d7b5c34">More...</a><br /></td></tr>
<tr class="separator:aa459ac8581242046b24c9ee17d7b5c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43aabe7eb9caad37ea82d63e6f7ca78b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a43aabe7eb9caad37ea82d63e6f7ca78b">getEdges</a> (unsigned int v, std::map&lt; unsigned int, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> * &gt; &amp;edgeMap) const</td></tr>
<tr class="memdesc:a43aabe7eb9caad37ea82d63e6f7ca78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of outgoing edges from vertex with index <em>v</em>. Key = vertex index, value = edge structure. The number of outgoing edges from <em>v</em> is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a43aabe7eb9caad37ea82d63e6f7ca78b">More...</a><br /></td></tr>
<tr class="separator:a43aabe7eb9caad37ea82d63e6f7ca78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81695127ac273368325eb61bd2b9b2ca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a81695127ac273368325eb61bd2b9b2ca">getIncomingEdges</a> (unsigned int v, std::vector&lt; unsigned int &gt; &amp;edgeList) const</td></tr>
<tr class="memdesc:a81695127ac273368325eb61bd2b9b2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of vertices with outgoing edges to the vertex with index <em>v</em>. The number of edges connecting to <em>v</em> is returned.  <a href="classompl_1_1base_1_1PlannerData.html#a81695127ac273368325eb61bd2b9b2ca">More...</a><br /></td></tr>
<tr class="separator:a81695127ac273368325eb61bd2b9b2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6863b24149cfe78dba15630e02c99"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#af8c6863b24149cfe78dba15630e02c99">getIncomingEdges</a> (unsigned int v, std::map&lt; unsigned int, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> * &gt; &amp;edgeMap) const</td></tr>
<tr class="memdesc:af8c6863b24149cfe78dba15630e02c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of incoming edges to the vertex with index <em>v</em> (i.e. if there is an edge from w to v, w and the edge structure will be in the map.) Key = vertex index, value = edge structure. The number of incoming edges to <em>v</em> is returned.  <a href="classompl_1_1base_1_1PlannerData.html#af8c6863b24149cfe78dba15630e02c99">More...</a><br /></td></tr>
<tr class="separator:af8c6863b24149cfe78dba15630e02c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0457d193b3297e8e90ee28bbe651d07e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0457d193b3297e8e90ee28bbe651d07e">getEdgeWeight</a> (unsigned int v1, unsigned int v2, <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a> *weight) const</td></tr>
<tr class="memdesc:a0457d193b3297e8e90ee28bbe651d07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight of the edge between the given vertex indices. If there exists an edge between <em>v1</em> and \v2, the edge weight is placed in the out-variable <em>weight</em>. Otherwise, this function returns false.  <a href="classompl_1_1base_1_1PlannerData.html#a0457d193b3297e8e90ee28bbe651d07e">More...</a><br /></td></tr>
<tr class="separator:a0457d193b3297e8e90ee28bbe651d07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0989a6e1614d76a1f94fb54d67341f5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0989a6e1614d76a1f94fb54d67341f5d">setEdgeWeight</a> (unsigned int v1, unsigned int v2, <a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a> weight)</td></tr>
<tr class="memdesc:a0989a6e1614d76a1f94fb54d67341f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weight of the edge between the given vertex indices. If an edge between v1 and v2 does not exist, this function returns false.  <a href="classompl_1_1base_1_1PlannerData.html#a0989a6e1614d76a1f94fb54d67341f5d">More...</a><br /></td></tr>
<tr class="separator:a0989a6e1614d76a1f94fb54d67341f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46a3a30292549f151136489c0d7041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#abf46a3a30292549f151136489c0d7041">computeEdgeWeights</a> (const <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a> &amp;opt)</td></tr>
<tr class="memdesc:abf46a3a30292549f151136489c0d7041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weight for all edges given the <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html" title="Abstract definition of optimization objectives.">OptimizationObjective</a> <em>opt</em>.  <a href="classompl_1_1base_1_1PlannerData.html#abf46a3a30292549f151136489c0d7041">More...</a><br /></td></tr>
<tr class="separator:abf46a3a30292549f151136489c0d7041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238a60c0e598a6e60c9be24f12e044f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a238a60c0e598a6e60c9be24f12e044f4">computeEdgeWeights</a> ()</td></tr>
<tr class="memdesc:a238a60c0e598a6e60c9be24f12e044f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all edge weights using state space distance (i.e. <a class="el" href="classompl_1_1base_1_1PlannerData.html#a25bb330cab0346857dd1a40fb059f71c" title="Return the instance of SpaceInformation used in this PlannerData.">getSpaceInformation()</a>-&gt;distance())  <a href="classompl_1_1base_1_1PlannerData.html#a238a60c0e598a6e60c9be24f12e044f4">More...</a><br /></td></tr>
<tr class="separator:a238a60c0e598a6e60c9be24f12e044f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output methods</div></td></tr>
<tr class="memitem:a184ebe75a4afc833b790b0f0ac276227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a184ebe75a4afc833b790b0f0ac276227">printGraphviz</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a184ebe75a4afc833b790b0f0ac276227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a Graphviz dot file of this structure to the given stream.  <a href="classompl_1_1base_1_1PlannerData.html#a184ebe75a4afc833b790b0f0ac276227">More...</a><br /></td></tr>
<tr class="separator:a184ebe75a4afc833b790b0f0ac276227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9fd81c96cf255b77dabeedefff23b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#acf9fd81c96cf255b77dabeedefff23b3">printGraphML</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:acf9fd81c96cf255b77dabeedefff23b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a GraphML file of this structure to the given stream.  <a href="classompl_1_1base_1_1PlannerData.html#acf9fd81c96cf255b77dabeedefff23b3">More...</a><br /></td></tr>
<tr class="separator:acf9fd81c96cf255b77dabeedefff23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1784a0fba1b49dc51ce1d308420d686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab1784a0fba1b49dc51ce1d308420d686">printPLY</a> (std::ostream &amp;out, bool asIs=false) const</td></tr>
<tr class="memdesc:ab1784a0fba1b49dc51ce1d308420d686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a mesh of the planner graph to a stream. Insert additional vertices if <em>asIs</em> == true.  <a href="classompl_1_1base_1_1PlannerData.html#ab1784a0fba1b49dc51ce1d308420d686">More...</a><br /></td></tr>
<tr class="separator:ab1784a0fba1b49dc51ce1d308420d686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced graph extraction</div></td></tr>
<tr class="memitem:aa79c3e5ed946f760d452047ef41fca6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aa79c3e5ed946f760d452047ef41fca6d">extractMinimumSpanningTree</a> (unsigned int v, const <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a> &amp;opt, <a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;mst) const</td></tr>
<tr class="memdesc:aa79c3e5ed946f760d452047ef41fca6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the minimum spanning tree of the data rooted at the vertex with index <em>v</em>. The minimum spanning tree is saved into <em>mst</em>. O(|E| log |V|) complexity.  <a href="classompl_1_1base_1_1PlannerData.html#aa79c3e5ed946f760d452047ef41fca6d">More...</a><br /></td></tr>
<tr class="separator:aa79c3e5ed946f760d452047ef41fca6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c220368ae824265498941b9f1cc3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac3c220368ae824265498941b9f1cc3ee">extractReachable</a> (unsigned int v, <a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;data) const</td></tr>
<tr class="memdesc:ac3c220368ae824265498941b9f1cc3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the subset of <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> reachable from the vertex with index v. For tree structures, this will be the sub-tree rooted at v. The reachable set is saved into <em>data</em>.  <a href="classompl_1_1base_1_1PlannerData.html#ac3c220368ae824265498941b9f1cc3ee">More...</a><br /></td></tr>
<tr class="separator:ac3c220368ae824265498941b9f1cc3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b599476b089cdd6170e661a89c67c83"><td class="memItemLeft" align="right" valign="top">StateStoragePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a3b599476b089cdd6170e661a89c67c83">extractStateStorage</a> () const</td></tr>
<tr class="memdesc:a3b599476b089cdd6170e661a89c67c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a <a class="el" href="namespaceompl_1_1base.html#aeb8d5c8d351d2337f79cabe4ee1f51dd" title="Storage of states where the metadata is a vector of indices. This is is typically used to store a gra...">ompl::base::GraphStateStorage</a> object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>. Memory for states is copied (the resulting <a class="el" href="classompl_1_1base_1_1StateStorage.html" title="Manage loading and storing for a set of states of a specified state space.">ompl::base::StateStorage</a> is independent from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>)  <a href="classompl_1_1base_1_1PlannerData.html#a3b599476b089cdd6170e661a89c67c83">More...</a><br /></td></tr>
<tr class="separator:a3b599476b089cdd6170e661a89c67c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919452f1e347b68e9331d726c85b1dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a919452f1e347b68e9331d726c85b1dad">toBoostGraph</a> ()</td></tr>
<tr class="memdesc:a919452f1e347b68e9331d726c85b1dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>.  <a href="classompl_1_1base_1_1PlannerData.html#a919452f1e347b68e9331d726c85b1dad">More...</a><br /></td></tr>
<tr class="separator:a919452f1e347b68e9331d726c85b1dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1475f191be353c1f8f983ae60fc470"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7d1475f191be353c1f8f983ae60fc470">toBoostGraph</a> () const</td></tr>
<tr class="memdesc:a7d1475f191be353c1f8f983ae60fc470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>.  <a href="classompl_1_1base_1_1PlannerData.html#a7d1475f191be353c1f8f983ae60fc470">More...</a><br /></td></tr>
<tr class="separator:a7d1475f191be353c1f8f983ae60fc470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aca9e2da9d9a46e42c516fc8b926ab65c"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aca9e2da9d9a46e42c516fc8b926ab65c">properties</a></td></tr>
<tr class="memdesc:aca9e2da9d9a46e42c516fc8b926ab65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any extra properties (key-value pairs) the planner can set.  <a href="classompl_1_1base_1_1PlannerData.html#aca9e2da9d9a46e42c516fc8b926ab65c">More...</a><br /></td></tr>
<tr class="separator:aca9e2da9d9a46e42c516fc8b926ab65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5e9068cf84bb1c378eb2ec0823e086d2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a5e9068cf84bb1c378eb2ec0823e086d2">NO_EDGE</a> = <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">ompl::base::PlannerDataEdge</a>()</td></tr>
<tr class="memdesc:a5e9068cf84bb1c378eb2ec0823e086d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation for a non-existant edge.  <a href="classompl_1_1base_1_1PlannerData.html#a5e9068cf84bb1c378eb2ec0823e086d2">More...</a><br /></td></tr>
<tr class="separator:a5e9068cf84bb1c378eb2ec0823e086d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b2294e37eb1b5468d70c04055f64c8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a53b2294e37eb1b5468d70c04055f64c8">NO_VERTEX</a> = <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(nullptr)</td></tr>
<tr class="memdesc:a53b2294e37eb1b5468d70c04055f64c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation for a non-existant vertex.  <a href="classompl_1_1base_1_1PlannerData.html#a53b2294e37eb1b5468d70c04055f64c8">More...</a><br /></td></tr>
<tr class="separator:a53b2294e37eb1b5468d70c04055f64c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b09299d9980783a8147e280562d5a7"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab2b09299d9980783a8147e280562d5a7">INVALID_INDEX</a> = std::numeric_limits&lt;unsigned int&gt;::max()</td></tr>
<tr class="memdesc:ab2b09299d9980783a8147e280562d5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an invalid vertex index.  <a href="classompl_1_1base_1_1PlannerData.html#ab2b09299d9980783a8147e280562d5a7">More...</a><br /></td></tr>
<tr class="separator:ab2b09299d9980783a8147e280562d5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1fa46fe71b0b364d1a424bb9797d8abc"><td class="memItemLeft" align="right" valign="top">std::map&lt; const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a1fa46fe71b0b364d1a424bb9797d8abc">stateIndexMap_</a></td></tr>
<tr class="memdesc:a1fa46fe71b0b364d1a424bb9797d8abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping of states to vertex indexes. For fast lookup of vertex index.  <a href="classompl_1_1base_1_1PlannerData.html#a1fa46fe71b0b364d1a424bb9797d8abc">More...</a><br /></td></tr>
<tr class="separator:a1fa46fe71b0b364d1a424bb9797d8abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96459e98ddbbe4882a4c2ca64738d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a5b96459e98ddbbe4882a4c2ca64738d8">startVertexIndices_</a></td></tr>
<tr class="memdesc:a5b96459e98ddbbe4882a4c2ca64738d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable listing of the vertices marked as start states. Stored in sorted order.  <a href="classompl_1_1base_1_1PlannerData.html#a5b96459e98ddbbe4882a4c2ca64738d8">More...</a><br /></td></tr>
<tr class="separator:a5b96459e98ddbbe4882a4c2ca64738d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1793ebfefa6fbaeaf6dda5431f58be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#abf1793ebfefa6fbaeaf6dda5431f58be">goalVertexIndices_</a></td></tr>
<tr class="memdesc:abf1793ebfefa6fbaeaf6dda5431f58be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable listing of the vertices marked as goal states. Stored in sorted order.  <a href="classompl_1_1base_1_1PlannerData.html#abf1793ebfefa6fbaeaf6dda5431f58be">More...</a><br /></td></tr>
<tr class="separator:abf1793ebfefa6fbaeaf6dda5431f58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b265d3a5780cda11ba7d068953c74af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a9b265d3a5780cda11ba7d068953c74af">si_</a></td></tr>
<tr class="memdesc:a9b265d3a5780cda11ba7d068953c74af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The space information instance for this data.  <a href="classompl_1_1base_1_1PlannerData.html#a9b265d3a5780cda11ba7d068953c74af">More...</a><br /></td></tr>
<tr class="separator:a9b265d3a5780cda11ba7d068953c74af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e967b1ae291397cc4c3ea4da7c56a2"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classompl_1_1base_1_1State.html">State</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a89e967b1ae291397cc4c3ea4da7c56a2">decoupledStates_</a></td></tr>
<tr class="memdesc:a89e967b1ae291397cc4c3ea4da7c56a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of states that are allocated during the decoupleFromPlanner method. These states are freed by <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> in the destructor.  <a href="classompl_1_1base_1_1PlannerData.html#a89e967b1ae291397cc4c3ea4da7c56a2">More...</a><br /></td></tr>
<tr class="separator:a89e967b1ae291397cc4c3ea4da7c56a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Object containing planner generated vertex and edge data. It is assumed that all vertices are unique, and only a single directed edge connects two vertices. </p>
<dl class="section note"><dt>Note</dt><dd>The storage for states this class maintains belongs to the planner instance that filled the data (by default; see <a class="el" href="classompl_1_1base_1_1PlannerData.html#af01506ec2ff32596dcb1bd9dfa2f8e1d" title="Creates a deep copy of the states contained in the vertices of this PlannerData structure so that whe...">PlannerData::decoupleFromPlanner()</a>) </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00174">174</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a086299be02adc8ae0438c111e2f3ae01" name="a086299be02adc8ae0438c111e2f3ae01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086299be02adc8ae0438c111e2f3ae01">&#9670;&nbsp;</a></span>PlannerData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ompl::base::PlannerData::PlannerData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a>&#160;</td>
          <td class="paramname"><em>si</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. Accepts a <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html" title="A shared pointer wrapper for ompl::base::SpaceInformation.">SpaceInformationPtr</a> for the space planned in. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00058">58</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="aeaae435c61fbc1f4c894da0140830e68" name="aeaae435c61fbc1f4c894da0140830e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaae435c61fbc1f4c894da0140830e68">&#9670;&nbsp;</a></span>~PlannerData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ompl::base::PlannerData::~PlannerData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#ae3d3a44f14bacb30bc00d41d0980baf5">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00063">63</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad2685cb2025517bdc0ee1ba94b9aff49" name="ad2685cb2025517bdc0ee1ba94b9aff49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2685cb2025517bdc0ee1ba94b9aff49">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em> = <code><a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>(1.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directed edge between the given vertex indexes. The vertices are added to the data if they are not already in the structure. An optional edge structure and weight can also be supplied. Success is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00456">456</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ac09c21494a8c7db500ef1a66bbbb1aa7" name="ac09c21494a8c7db500ef1a66bbbb1aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09c21494a8c7db500ef1a66bbbb1aa7">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::addEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em> = <code><a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>(1.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directed edge between the given vertex indexes. An optional edge structure and weight can be supplied. Success is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00432">432</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a3604cb85b0402b09b319c5f1df02b12e" name="a3604cb85b0402b09b319c5f1df02b12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3604cb85b0402b09b319c5f1df02b12e">&#9670;&nbsp;</a></span>addGoalVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::addGoalVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00422">422</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a2eea84456784452486aa0065af391f47" name="a2eea84456784452486aa0065af391f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eea84456784452486aa0065af391f47">&#9670;&nbsp;</a></span>addStartVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::addStartVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00413">413</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ac61c5ab5cfd6a66a58e03b1731c1e454" name="ac61c5ab5cfd6a66a58e03b1731c1e454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61c5ab5cfd6a66a58e03b1731c1e454">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::addVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given vertex to the graph data. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00391">391</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a7378bbca3f1006b70976292266277eb9" name="a7378bbca3f1006b70976292266277eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7378bbca3f1006b70976292266277eb9">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the entire data structure. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#a66ad68fc2c8262138d6b244be474fa3d">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00074">74</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a238a60c0e598a6e60c9be24f12e044f4" name="a238a60c0e598a6e60c9be24f12e044f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238a60c0e598a6e60c9be24f12e044f4">&#9670;&nbsp;</a></span>computeEdgeWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::computeEdgeWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all edge weights using state space distance (i.e. <a class="el" href="classompl_1_1base_1_1PlannerData.html#a25bb330cab0346857dd1a40fb059f71c" title="Return the instance of SpaceInformation used in this PlannerData.">getSpaceInformation()</a>-&gt;distance()) </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00630">630</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="abf46a3a30292549f151136489c0d7041" name="abf46a3a30292549f151136489c0d7041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf46a3a30292549f151136489c0d7041">&#9670;&nbsp;</a></span>computeEdgeWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::computeEdgeWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weight for all edges given the <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html" title="Abstract definition of optimization objectives.">OptimizationObjective</a> <em>opt</em>. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00614">614</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="af01506ec2ff32596dcb1bd9dfa2f8e1d" name="af01506ec2ff32596dcb1bd9dfa2f8e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01506ec2ff32596dcb1bd9dfa2f8e1d">&#9670;&nbsp;</a></span>decoupleFromPlanner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::decoupleFromPlanner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of the states contained in the vertices of this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> structure so that when the planner that created this instance goes out of scope, all data remains intact. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Shallow state pointers inside of the <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html" title="Base class for a vertex in the PlannerData structure. All derived classes must implement the clone an...">PlannerDataVertex</a> objects already in this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> will be replaced with clones which are scoped to this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> object. A subsequent call to this method is necessary after any other vertices are added to ensure that this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> instance is fully decoupled. </dd></dl>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#a64de419d8be128ba2e71c71b79a6517a">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00080">80</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a0b9ec6cbf900b5c08c3a744c119181d8" name="a0b9ec6cbf900b5c08c3a744c119181d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9ec6cbf900b5c08c3a744c119181d8">&#9670;&nbsp;</a></span>edgeExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::edgeExists </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an edge between vertex index <em>v1</em> and index <em>v2</em> exists. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00188">188</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="aa79c3e5ed946f760d452047ef41fca6d" name="aa79c3e5ed946f760d452047ef41fca6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79c3e5ed946f760d452047ef41fca6d">&#9670;&nbsp;</a></span>extractMinimumSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::extractMinimumSpanningTree </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1PlannerData.html">base::PlannerData</a> &amp;&#160;</td>
          <td class="paramname"><em>mst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the minimum spanning tree of the data rooted at the vertex with index <em>v</em>. The minimum spanning tree is saved into <em>mst</em>. O(|E| log |V|) complexity. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00638">638</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ac3c220368ae824265498941b9f1cc3ee" name="ac3c220368ae824265498941b9f1cc3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c220368ae824265498941b9f1cc3ee">&#9670;&nbsp;</a></span>extractReachable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::extractReachable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1PlannerData.html">base::PlannerData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the subset of <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> reachable from the vertex with index v. For tree structures, this will be the sub-tree rooted at v. The reachable set is saved into <em>data</em>. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00685">685</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a3b599476b089cdd6170e661a89c67c83" name="a3b599476b089cdd6170e661a89c67c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b599476b089cdd6170e661a89c67c83">&#9670;&nbsp;</a></span>extractStateStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ompl::base::StateStoragePtr ompl::base::PlannerData::extractStateStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a <a class="el" href="namespaceompl_1_1base.html#aeb8d5c8d351d2337f79cabe4ee1f51dd" title="Storage of states where the metadata is a vector of indices. This is is typically used to store a gra...">ompl::base::GraphStateStorage</a> object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>. Memory for states is copied (the resulting <a class="el" href="classompl_1_1base_1_1StateStorage.html" title="Manage loading and storing for a set of states of a specified state space.">ompl::base::StateStorage</a> is independent from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>) </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00716">716</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a42dd016470505a10e245a570e1979de3" name="a42dd016470505a10e245a570e1979de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42dd016470505a10e245a570e1979de3">&#9670;&nbsp;</a></span>getEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">ompl::base::PlannerDataEdge</a> &amp; ompl::base::PlannerData::getEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the edge object connecting vertices with indexes <em>v1</em> and <em>v2</em>. If this edge does not exist, NO_EDGE is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00245">245</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ab1702251b05069848409efade85a3605" name="ab1702251b05069848409efade85a3605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1702251b05069848409efade85a3605">&#9670;&nbsp;</a></span>getEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">ompl::base::PlannerDataEdge</a> &amp; ompl::base::PlannerData::getEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the edge object connecting vertices with indexes <em>v1</em> and <em>v2</em>. If this edge does not exist, NO_EDGE is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00230">230</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a43aabe7eb9caad37ea82d63e6f7ca78b" name="a43aabe7eb9caad37ea82d63e6f7ca78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43aabe7eb9caad37ea82d63e6f7ca78b">&#9670;&nbsp;</a></span>getEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::getEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned int, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of outgoing edges from vertex with index <em>v</em>. Key = vertex index, value = edge structure. The number of outgoing edges from <em>v</em> is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00117">117</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="aa459ac8581242046b24c9ee17d7b5c34" name="aa459ac8581242046b24c9ee17d7b5c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa459ac8581242046b24c9ee17d7b5c34">&#9670;&nbsp;</a></span>getEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::getEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of the vertex indexes directly connected to vertex with index <em>v</em> (outgoing edges). The number of outgoing edges from <em>v</em> is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00104">104</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a0457d193b3297e8e90ee28bbe651d07e" name="a0457d193b3297e8e90ee28bbe651d07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0457d193b3297e8e90ee28bbe651d07e">&#9670;&nbsp;</a></span>getEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a> *&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weight of the edge between the given vertex indices. If there exists an edge between <em>v1</em> and \v2, the edge weight is placed in the out-variable <em>weight</em>. Otherwise, this function returns false. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00157">157</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="abba488b5f384fa3dedd07dc7b974a14d" name="abba488b5f384fa3dedd07dc7b974a14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba488b5f384fa3dedd07dc7b974a14d">&#9670;&nbsp;</a></span>getGoalIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::getGoalIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the ith goal state. INVALID_INDEX is returned if <em>i</em> is out of range Indexes are volatile and may change after adding/removing a vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00341">341</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a0740003f5170235f3133162db36f1f23" name="a0740003f5170235f3133162db36f1f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0740003f5170235f3133162db36f1f23">&#9670;&nbsp;</a></span>getGoalVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> &amp; ompl::base::PlannerData::getGoalVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the ith goal vertex object. If <em>i</em> is greater than the number of goal vertices, NO_VERTEX is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00383">383</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="acc67731741c9990a749307fd558161c1" name="acc67731741c9990a749307fd558161c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc67731741c9990a749307fd558161c1">&#9670;&nbsp;</a></span>getGoalVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> &amp; ompl::base::PlannerData::getGoalVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the ith goal vertex object. If <em>i</em> is greater than the number of goal vertices, NO_VERTEX is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00375">375</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="af8c6863b24149cfe78dba15630e02c99" name="af8c6863b24149cfe78dba15630e02c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c6863b24149cfe78dba15630e02c99">&#9670;&nbsp;</a></span>getIncomingEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::getIncomingEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned int, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of incoming edges to the vertex with index <em>v</em> (i.e. if there is an edge from w to v, w and the edge structure will be in the map.) Key = vertex index, value = edge structure. The number of incoming edges to <em>v</em> is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00143">143</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a81695127ac273368325eb61bd2b9b2ca" name="a81695127ac273368325eb61bd2b9b2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81695127ac273368325eb61bd2b9b2ca">&#9670;&nbsp;</a></span>getIncomingEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::getIncomingEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of vertices with outgoing edges to the vertex with index <em>v</em>. The number of edges connecting to <em>v</em> is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00131">131</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a25bb330cab0346857dd1a40fb059f71c" name="a25bb330cab0346857dd1a40fb059f71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bb330cab0346857dd1a40fb059f71c">&#9670;&nbsp;</a></span>getSpaceInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">ompl::base::SpaceInformationPtr</a> &amp; ompl::base::PlannerData::getSpaceInformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the instance of <a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">SpaceInformation</a> used in this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00757">757</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a1fcd8fb4d13be0c272ccf538f5372f39" name="a1fcd8fb4d13be0c272ccf538f5372f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcd8fb4d13be0c272ccf538f5372f39">&#9670;&nbsp;</a></span>getStartIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::getStartIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the ith start state. INVALID_INDEX is returned if <em>i</em> is out of range. Indexes are volatile and may change after adding/removing a vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00333">333</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ae01edd29349d34cd7ca62384cecf7e7d" name="ae01edd29349d34cd7ca62384cecf7e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01edd29349d34cd7ca62384cecf7e7d">&#9670;&nbsp;</a></span>getStartVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> &amp; ompl::base::PlannerData::getStartVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the ith start vertex object. If <em>i</em> is greater than the number of start vertices, NO_VERTEX is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00367">367</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ab2e140727e79440c47c275a52bfd0604" name="ab2e140727e79440c47c275a52bfd0604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e140727e79440c47c275a52bfd0604">&#9670;&nbsp;</a></span>getStartVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> &amp; ompl::base::PlannerData::getStartVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the ith start vertex object. If <em>i</em> is greater than the number of start vertices, NO_VERTEX is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00359">359</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a7e1f2a259a8861ee5a88e51cc52f69e5" name="a7e1f2a259a8861ee5a88e51cc52f69e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1f2a259a8861ee5a88e51cc52f69e5">&#9670;&nbsp;</a></span>getVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> &amp; ompl::base::PlannerData::getVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the vertex object with the given index. If this vertex does not exist, NO_VERTEX is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00221">221</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="abebe83e30a20d7d79e26f18bf228e8bb" name="abebe83e30a20d7d79e26f18bf228e8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebe83e30a20d7d79e26f18bf228e8bb">&#9670;&nbsp;</a></span>getVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> &amp; ompl::base::PlannerData::getVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to the vertex object with the given index. If this vertex does not exist, NO_VERTEX is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00212">212</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ac361b543229e46d4dfb6d954a814fc0e" name="ac361b543229e46d4dfb6d954a814fc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac361b543229e46d4dfb6d954a814fc0e">&#9670;&nbsp;</a></span>hasControls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::hasControls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate whether any information about controls (<a class="el" href="classompl_1_1control_1_1Control.html" title="Definition of an abstract control.">ompl::control::Control</a>) is stored in this instance. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#aa00f38b78ba54efb088a52195da095c7">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00784">784</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a14ba153dc627b6d44c691b49a5f99c9b" name="a14ba153dc627b6d44c691b49a5f99c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ba153dc627b6d44c691b49a5f99c9b">&#9670;&nbsp;</a></span>isGoalVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::isGoalVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given vertex index is marked as a goal vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00354">354</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="adc9fe3b3b96c759bcae567743d404471" name="adc9fe3b3b96c759bcae567743d404471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9fe3b3b96c759bcae567743d404471">&#9670;&nbsp;</a></span>isStartVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::isStartVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given vertex index is marked as a start vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00349">349</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a7772ac307d153831c0e7ecfc4fb1c18b" name="a7772ac307d153831c0e7ecfc4fb1c18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7772ac307d153831c0e7ecfc4fb1c18b">&#9670;&nbsp;</a></span>markGoalState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::markGoalState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the given state as a goal vertex. If the given state does not exist in a vertex, false is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00597">597</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a48ebd34b6da9efd9ec7647155f9173c9" name="a48ebd34b6da9efd9ec7647155f9173c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ebd34b6da9efd9ec7647155f9173c9">&#9670;&nbsp;</a></span>markStartState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::markStartState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the given state as a start vertex. If the given state does not exist in a vertex, false is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00580">580</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a383876c22dd92deeed0a536c10f7ecd4" name="a383876c22dd92deeed0a536c10f7ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383876c22dd92deeed0a536c10f7ecd4">&#9670;&nbsp;</a></span>numEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::numEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of edges in this structure. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00207">207</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="acc1145957cc29ef8e8328b8f31b9216a" name="acc1145957cc29ef8e8328b8f31b9216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1145957cc29ef8e8328b8f31b9216a">&#9670;&nbsp;</a></span>numGoalVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::numGoalVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of goal vertices. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00328">328</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a9b7c83a71e59cc10492b96c52990124d" name="a9b7c83a71e59cc10492b96c52990124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c83a71e59cc10492b96c52990124d">&#9670;&nbsp;</a></span>numStartVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::numStartVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of start vertices. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00323">323</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a877a673801134168cba0581b277cae79" name="a877a673801134168cba0581b277cae79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877a673801134168cba0581b277cae79">&#9670;&nbsp;</a></span>numVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::numVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of vertices in this structure. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00202">202</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="acf9fd81c96cf255b77dabeedefff23b3" name="acf9fd81c96cf255b77dabeedefff23b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9fd81c96cf255b77dabeedefff23b3">&#9670;&nbsp;</a></span>printGraphML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::printGraphML </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a GraphML file of this structure to the given stream. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00284">284</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a184ebe75a4afc833b790b0f0ac276227" name="a184ebe75a4afc833b790b0f0ac276227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184ebe75a4afc833b790b0f0ac276227">&#9670;&nbsp;</a></span>printGraphviz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::printGraphviz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a Graphviz dot file of this structure to the given stream. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00260">260</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="ab1784a0fba1b49dc51ce1d308420d686" name="ab1784a0fba1b49dc51ce1d308420d686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1784a0fba1b49dc51ce1d308420d686">&#9670;&nbsp;</a></span>printPLY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::printPLY </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asIs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a mesh of the planner graph to a stream. Insert additional vertices if <em>asIs</em> == true. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00789">789</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="afda397cf585cc647d1e9b212b6092b0e" name="afda397cf585cc647d1e9b212b6092b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda397cf585cc647d1e9b212b6092b0e">&#9670;&nbsp;</a></span>removeEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::removeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the edge between the vertices associated with the given vertex data. Success is returned. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#a55dae1f3862e41126d4f65152cc69ae3">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00557">557</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a991ab62a502c3f80ae2663150e79bcea" name="a991ab62a502c3f80ae2663150e79bcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991ab62a502c3f80ae2663150e79bcea">&#9670;&nbsp;</a></span>removeEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::removeEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the edge between vertex indexes <em>v1</em> and <em>v2</em>. Success is returned. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#af40219f4a5d04634eef4929156d6d017">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00540">540</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a75a2c3ad28a32136c74ad9f841727f01" name="a75a2c3ad28a32136c74ad9f841727f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a2c3ad28a32136c74ad9f841727f01">&#9670;&nbsp;</a></span>removeVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::removeVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the vertex associated with the given data. If the vertex does not exist, false is returned. This method has O(n) complexity in the number of vertices. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#a2c2aa89498dcca737a667c3c41a496bd">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00473">473</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a7313c0b88697387feebff969c307193c" name="a7313c0b88697387feebff969c307193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7313c0b88697387feebff969c307193c">&#9670;&nbsp;</a></span>removeVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::removeVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the vertex with the given index. If the index is out of range, false is returned. This method has O(n) complexity in the number of vertices. </p>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#abcdd694bec6eda9f2e884541c6388d5a">ompl::control::PlannerData</a>.</p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00481">481</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a0989a6e1614d76a1f94fb54d67341f5d" name="a0989a6e1614d76a1f94fb54d67341f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0989a6e1614d76a1f94fb54d67341f5d">&#9670;&nbsp;</a></span>setEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::setEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1Cost.html">Cost</a>&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weight of the edge between the given vertex indices. If an edge between v1 and v2 does not exist, this function returns false. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00173">173</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a2b0b7c124dcac4f07c5f6d0ab51386a6" name="a2b0b7c124dcac4f07c5f6d0ab51386a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0b7c124dcac4f07c5f6d0ab51386a6">&#9670;&nbsp;</a></span>tagState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::tagState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the integer tag associated with the given state. If the given state does not exist in a vertex, false is returned. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00569">569</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a919452f1e347b68e9331d726c85b1dad" name="a919452f1e347b68e9331d726c85b1dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919452f1e347b68e9331d726c85b1dad">&#9670;&nbsp;</a></span>toBoostGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">ompl::base::PlannerData::Graph</a> &amp; ompl::base::PlannerData::toBoostGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use of this method requires inclusion of <a class="el" href="PlannerDataGraph_8h_source.html">PlannerDataGraph.h</a> The object returned can be used safely for all read-only purposes in Boost. Adding or removing vertices and edges should be performed by using the respective method in <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> to ensure proper memory management. Manipulating the graph directly will result in undefined behavior with this class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00744">744</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a7d1475f191be353c1f8f983ae60fc470" name="a7d1475f191be353c1f8f983ae60fc470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1475f191be353c1f8f983ae60fc470">&#9670;&nbsp;</a></span>toBoostGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">ompl::base::PlannerData::Graph</a> &amp; ompl::base::PlannerData::toBoostGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use of this method requires inclusion of <a class="el" href="PlannerDataGraph_8h_source.html">PlannerDataGraph.h</a> The object returned can be used safely for all read-only purposes in Boost. Adding or removing vertices and edges should be performed by using the respective method in <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> to ensure proper memory management. Manipulating the graph directly will result in undefined behavior with this class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00750">750</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="acad3f862d6764941928dd3d69efa9a9c" name="acad3f862d6764941928dd3d69efa9a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad3f862d6764941928dd3d69efa9a9c">&#9670;&nbsp;</a></span>vertexExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::PlannerData::vertexExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a vertex exists with the given vertex data. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00197">197</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a id="a06792592713e6463c4b9814f2a715b4c" name="a06792592713e6463c4b9814f2a715b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06792592713e6463c4b9814f2a715b4c">&#9670;&nbsp;</a></span>vertexIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ompl::base::PlannerData::vertexIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index for the vertex associated with the given data. INVALID_INDEX is returned if this vertex does not exist. Indexes are volatile and may change after adding/removing a vertex. </p>

<p class="definition">Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00315">315</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a89e967b1ae291397cc4c3ea4da7c56a2" name="a89e967b1ae291397cc4c3ea4da7c56a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e967b1ae291397cc4c3ea4da7c56a2">&#9670;&nbsp;</a></span>decoupledStates_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classompl_1_1base_1_1State.html">State</a> *&gt; ompl::base::PlannerData::decoupledStates_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of states that are allocated during the decoupleFromPlanner method. These states are freed by <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique,...">PlannerData</a> in the destructor. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00424">424</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="abf1793ebfefa6fbaeaf6dda5431f58be" name="abf1793ebfefa6fbaeaf6dda5431f58be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1793ebfefa6fbaeaf6dda5431f58be">&#9670;&nbsp;</a></span>goalVertexIndices_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; ompl::base::PlannerData::goalVertexIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutable listing of the vertices marked as goal states. Stored in sorted order. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00418">418</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="ab2b09299d9980783a8147e280562d5a7" name="ab2b09299d9980783a8147e280562d5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b09299d9980783a8147e280562d5a7">&#9670;&nbsp;</a></span>INVALID_INDEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int ompl::base::PlannerData::INVALID_INDEX = std::numeric_limits&lt;unsigned int&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Representation of an invalid vertex index. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00184">184</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="a5e9068cf84bb1c378eb2ec0823e086d2" name="a5e9068cf84bb1c378eb2ec0823e086d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9068cf84bb1c378eb2ec0823e086d2">&#9670;&nbsp;</a></span>NO_EDGE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">ompl::base::PlannerDataEdge</a> ompl::base::PlannerData::NO_EDGE = <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">ompl::base::PlannerDataEdge</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Representation for a non-existant edge. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00180">180</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="a53b2294e37eb1b5468d70c04055f64c8" name="a53b2294e37eb1b5468d70c04055f64c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b2294e37eb1b5468d70c04055f64c8">&#9670;&nbsp;</a></span>NO_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a> ompl::base::PlannerData::NO_VERTEX = <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(nullptr)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Representation for a non-existant vertex. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00182">182</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="aca9e2da9d9a46e42c516fc8b926ab65c" name="aca9e2da9d9a46e42c516fc8b926ab65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9e2da9d9a46e42c516fc8b926ab65c">&#9670;&nbsp;</a></span>properties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; ompl::base::PlannerData::properties</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Any extra properties (key-value pairs) the planner can set. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00410">410</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="a9b265d3a5780cda11ba7d068953c74af" name="a9b265d3a5780cda11ba7d068953c74af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b265d3a5780cda11ba7d068953c74af">&#9670;&nbsp;</a></span>si_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a> ompl::base::PlannerData::si_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The space information instance for this data. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00421">421</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="a5b96459e98ddbbe4882a4c2ca64738d8" name="a5b96459e98ddbbe4882a4c2ca64738d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b96459e98ddbbe4882a4c2ca64738d8">&#9670;&nbsp;</a></span>startVertexIndices_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; ompl::base::PlannerData::startVertexIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutable listing of the vertices marked as start states. Stored in sorted order. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00416">416</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<a id="a1fa46fe71b0b364d1a424bb9797d8abc" name="a1fa46fe71b0b364d1a424bb9797d8abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa46fe71b0b364d1a424bb9797d8abc">&#9670;&nbsp;</a></span>stateIndexMap_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *, unsigned int&gt; ompl::base::PlannerData::stateIndexMap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mapping of states to vertex indexes. For fast lookup of vertex index. </p>

<p class="definition">Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00414">414</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ompl/base/<a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a></li>
<li>ompl/base/src/<a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<footer class="footer">
  <div class="container">
  <a href="http://www.kavrakilab.org">Kavraki Lab</a>  &bull;
  <a href="https://www.cs.rice.edu">Department of Computer Science</a> &bull;
  <a href="https://www.rice.edu">Rice University</a><br/>
  Funded in part by the <a href="https://www.nsf.gov">National Science Foundation</a><br/>
  Documentation generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.3
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
