<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl/geometric/planners/bitstar/datastructures/src/ImplicitGraph.cpp Source File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <link href="css/tabs.css" rel="stylesheet">
  <link href="css/doxygen.css" rel="stylesheet">
  <link href="css/search.css" rel="stylesheet">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="css/ompl.css" rel="stylesheet">
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="search/searchdata.js"></script>
  <script src="search/search.js"></script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
          <!-- Doxygen API search box -->
          <div id="searchli">
            <div id="MSearchBox" class="MSearchBoxInactive">
              <span class="left">
                <img id="MSearchSelect" src="search/mag_sel.png"
                onmouseover="return searchBox.OnSearchSelectShow()"
                onmouseout="return searchBox.OnSearchSelectHide()"
                alt=""/>
                <input type="text" id="MSearchField" value="Search API" accesskey="S"
                onfocus="searchBox.OnSearchFieldFocus(true)"
                onblur="searchBox.OnSearchFieldFocus(false)"
                onkeyup="searchBox.OnSearchFieldChange(event)"/>
              </span><span class="right">
                <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
              </span>
            </div>
          </div>
        </ul>
      </div>
    </div>
  </nav>
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"
  onmouseover="return searchBox.OnSearchSelectShow()"
  onmouseout="return searchBox.OnSearchSelectHide()"
  onkeydown="return searchBox.OnSearchSelectKey(event)">
  <a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="" frameborder="0"name="MSearchResults" id="MSearchResults"></iframe>
  </div>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7ddd700113690eeaea096b2573463168.html">ompl</a></li><li class="navelem"><a class="el" href="dir_0512a794d4930509c35fb9cbf1454831.html">geometric</a></li><li class="navelem"><a class="el" href="dir_44765481f178f9778aa2d346590a211f.html">planners</a></li><li class="navelem"><a class="el" href="dir_d1669b500842859f515d85a9417fe393.html">bitstar</a></li><li class="navelem"><a class="el" href="dir_e2db6f8edced8a9bc56dadbbdb8095ee.html">datastructures</a></li><li class="navelem"><a class="el" href="dir_f688f333d8b21cc58c336da06f1eff31.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ImplicitGraph.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*********************************************************************</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">* Software License Agreement (BSD License)</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">*  Copyright (c) 2014, University of Toronto</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">*  All rights reserved.</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">*  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">*  modification, are permitted provided that the following conditions</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">*  are met:</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">*   * Redistributions of source code must retain the above copyright</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">*     notice, this list of conditions and the following disclaimer.</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">*   * Redistributions in binary form must reproduce the above</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">*     copyright notice, this list of conditions and the following</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">*     disclaimer in the documentation and/or other materials provided</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">*     with the distribution.</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">*   * Neither the name of the University of Toronto nor the names of its</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">*     contributors may be used to endorse or promote products derived</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">*     from this software without specific prior written permission.</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">*  POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">*********************************************************************/</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">/* Authors: Jonathan Gammell */</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// My definition:</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &quot;ompl/geometric/planners/bitstar/datastructures/ImplicitGraph.h&quot;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// STL/Boost:</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">// For std::move</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">// For smart pointers</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">// For, you know, math</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">// For boost math constants</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="preprocessor">#include &lt;boost/math/constants/constants.hpp&gt;</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">// OMPL:</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">// For OMPL_INFORM et al.</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Console_8h.html">ompl/util/Console.h</a>&quot;</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">// For exceptions:</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#include &quot;ompl/util/Exception.h&quot;</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">// For SelfConfig</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="preprocessor">#include &quot;ompl/tools/config/SelfConfig.h&quot;</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// For RNG</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="preprocessor">#include &quot;ompl/util/RandomNumbers.h&quot;</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">// For geometric equations like unitNBallMeasure</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="preprocessor">#include &quot;ompl/util/GeometricEquations.h&quot;</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">// BIT*:</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">// The vertex class:</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="preprocessor">#include &quot;ompl/geometric/planners/bitstar/datastructures/Vertex.h&quot;</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">// The cost-helper class:</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="preprocessor">#include &quot;ompl/geometric/planners/bitstar/datastructures/CostHelper.h&quot;</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">// The search queue class</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor">#include &quot;ompl/geometric/planners/bitstar/datastructures/SearchQueue.h&quot;</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceompl.html">ompl</a></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;{</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keyword">namespace </span>geometric</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="comment">// Public functions:</span></div><div class="line"><a name="l00076"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae0300a64779d063a3db9c1752a1145f8">   76</a></span>&#160;        <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae0300a64779d063a3db9c1752a1145f8">BITstar::ImplicitGraph::ImplicitGraph</a>(<a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1972ba4a3a68f77ffa2c3319a69dce49">NameFunc</a> nameFunc)</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;          : nameFunc_(<a class="code" href="namespacestd.html">std</a>::move(nameFunc))</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a63d6bb1d8f59740872e0fb1a1124ace5">   81</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a63d6bb1d8f59740872e0fb1a1124ace5">BITstar::ImplicitGraph::setup</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1SpaceInformationPtr.html">ompl::base::SpaceInformationPtr</a> &amp;si,</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                                           <span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1ProblemDefinitionPtr.html">ompl::base::ProblemDefinitionPtr</a> &amp;pdef,</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                                           <span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a7f00cb9addc9d74b7189aec381f038fa">CostHelperPtr</a> &amp;costHelper, <span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a5a3eb7712e427445aecf215e4e7f95fa">SearchQueuePtr</a> &amp;searchQueue,</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                                           <span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1Planner.html">ompl::base::Planner</a> *plannerPtr, <a class="code" href="classompl_1_1base_1_1PlannerInputStates.html">ompl::base::PlannerInputStates</a> &amp;pis)</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="comment">// Store that I am setup so that any debug-level tests will pass. This requires assuring that this function</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="comment">// is ordered properly.</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            isSetup_ = <span class="keyword">true</span>;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="comment">// Store arguments</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            si_ = si;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            pdef_ = pdef;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            costHelpPtr_ = costHelper;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            queuePtr_ = searchQueue;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="comment">// Configure the nearest-neighbour constructs.</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="comment">// Only allocate if they are empty (as they can be set to a specific version by a call to</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="comment">// setNearestNeighbors)</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <span class="keywordflow">if</span> (!static_cast&lt;bool&gt;(freeStateNN_))</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                freeStateNN_.reset(ompl::tools::SelfConfig::getDefaultNearestNeighbors&lt;VertexPtr&gt;(plannerPtr));</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            }</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="comment">// No else, already allocated (by a call to setNearestNeighbors())</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            <span class="keywordflow">if</span> (!static_cast&lt;bool&gt;(vertexNN_))</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                vertexNN_.reset(ompl::tools::SelfConfig::getDefaultNearestNeighbors&lt;VertexPtr&gt;(plannerPtr));</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="comment">// No else, already allocated (by a call to setNearestNeighbors())</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="comment">// Configure:</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <a class="code" href="classompl_1_1NearestNeighbors.html#a69692a816af54715de7afdf0ff15141c">NearestNeighbors&lt;VertexPtr&gt;::DistanceFunction</a> distfun(</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                [<span class="keyword">this</span>](<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;b)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a818cc69141d235fafba96f739bcba011">distanceFunction</a>(a, b);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                });</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            freeStateNN_-&gt;setDistanceFunction(distfun);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            vertexNN_-&gt;setDistanceFunction(distfun);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            <span class="comment">// Set the min, max and sampled cost to the proper objective-based values:</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            minCost_ = costHelpPtr_-&gt;infiniteCost();</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            maxCost_ = costHelpPtr_-&gt;infiniteCost();</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            costSampled_ = costHelpPtr_-&gt;infiniteCost();</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            <span class="comment">// Add any start and goals vertices that exist to the queue, but do NOT wait for any more goals:</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae274427299a7fb5b40d3633adb8c3f0f">updateStartAndGoalStates</a>(pis, <a class="code" href="namespaceompl_1_1base.html#a1125deb13109d3f27b3acab34d79c09c">ompl::base::plannerAlwaysTerminatingCondition</a>());</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            <span class="comment">// Get the measure of the problem</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            approximationMeasure_ = si_-&gt;getSpaceMeasure();</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="comment">// Does the problem have finite boundaries?</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            <span class="keywordflow">if</span> (!std::isfinite(approximationMeasure_))</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            {</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="comment">// It does not, so let&#39;s estimate a measure of the planning problem.</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                <span class="comment">// A not horrible place to start would be hypercube proportional to the distance between the start and</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                <span class="comment">// goal. It&#39;s not *great*, but at least it sort of captures the order-of-magnitude of the problem.</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                <span class="comment">// First, some asserts.</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                <span class="comment">// Check that JIT sampling is on, which is required for infinite problems</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                <span class="keywordflow">if</span> (!useJustInTimeSampling_)</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                    <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;For unbounded planning problems, just-in-time sampling must be enabled &quot;</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                                          <span class="stringliteral">&quot;before calling setup.&quot;</span>);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                <span class="comment">// No else</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <span class="comment">// Check that we have a start and goal</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                <span class="keywordflow">if</span> (startVertices_.empty() || goalVertices_.empty())</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                    <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;For unbounded planning problems, at least one start and one goal must exist &quot;</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                                          <span class="stringliteral">&quot;before calling setup.&quot;</span>);</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                }</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                <span class="comment">// No else</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                <span class="comment">// Variables</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                <span class="comment">// The maximum distance between start and goal:</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                <span class="keywordtype">double</span> maxDist = 0.0;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                <span class="comment">// The scale on the maximum distance, i.e. the width of the hypercube is equal to this value times the</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                <span class="comment">// distance between start and goal.</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                <span class="comment">// This number is completely made up.</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                <span class="keywordtype">double</span> distScale = 2.0;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="comment">// Find the max distance</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;startVertex : startVertices_)</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                {</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;goalVertex : goalVertices_)</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                    {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                        maxDist = std::max(maxDist, si_-&gt;distance(startVertex-&gt;stateConst(), goalVertex-&gt;stateConst()));</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                    }</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                <span class="comment">// Calculate an estimate of the problem measure by (hyper)cubing the max distance</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                approximationMeasure_ = std::pow(distScale * maxDist, si_-&gt;getStateDimension());</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="comment">// No else, finite problem dimension</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="comment">// Finally initialize the nearestNeighbour terms:</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="comment">// Calculate the k-nearest constant</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            k_rgg_ = this-&gt;minimumRggK();</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="comment">// Make the initial k all vertices:</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            k_ = startVertices_.size() + goalVertices_.size();</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="comment">// Make the initial r infinity</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            r_ = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a131fbf7c6940f668b1b90269048dc5e9">  188</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a131fbf7c6940f668b1b90269048dc5e9">BITstar::ImplicitGraph::clear</a>()</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="comment">// Reset everything to the state of construction OTHER than planner name and settings/parameters</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="comment">// Keep this in the order of the constructors for easy verification:</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="comment">// Mark as cleared</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            isSetup_ = <span class="keyword">false</span>;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            <span class="comment">// Pointers given at setup</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            si_.reset();</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            pdef_.reset();</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            costHelpPtr_.reset();</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            queuePtr_.reset();</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            <span class="comment">// Sampling</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            rng_ = <a class="code" href="classompl_1_1RNG.html">ompl::RNG</a>();</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            sampler_.reset();</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="comment">// Containers</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            startVertices_.clear();</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            goalVertices_.clear();</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            prunedStartVertices_.clear();</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            prunedGoalVertices_.clear();</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            newSamples_.clear();</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            recycledSamples_.clear();</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            <span class="comment">// The set of samples</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(freeStateNN_))</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                freeStateNN_-&gt;clear();</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                freeStateNN_.reset();</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            <span class="comment">// No else, not allocated</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="comment">// The set of vertices</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(vertexNN_))</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                vertexNN_-&gt;clear();</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                vertexNN_.reset();</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            }</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="comment">// The various calculations and tracked values, same as in the header</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            samplesInThisBatch_ = 0u;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            numUniformStates_ = 0u;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            r_ = 0.0;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            k_rgg_ = 0.0;  <span class="comment">// This is a double for better rounding later</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            k_ = 0u;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            approximationMeasure_ = 0.0;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            minCost_ = <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>(std::numeric_limits&lt;double&gt;::infinity());</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            maxCost_ = <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>(std::numeric_limits&lt;double&gt;::infinity());</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            costSampled_ = <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>(std::numeric_limits&lt;double&gt;::infinity());</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            hasExactSolution_ = <span class="keyword">false</span>;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            closestVertexToGoal_.reset();</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            closestDistToGoal_ = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="comment">// The planner property trackers:</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            numSamples_ = 0u;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;            numVertices_ = 0u;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            numFreeStatesPruned_ = 0u;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            numVerticesDisconnected_ = 0u;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;            numNearestNeighbours_ = 0u;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            numStateCollisionChecks_ = 0u;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="comment">// The various convenience pointers:</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="comment">// DO NOT reset the parameters:</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="comment">// rewireFactor_</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            <span class="comment">// useKNearest_</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="comment">// useJustInTimeSampling_</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="comment">// dropSamplesOnPrune_</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="comment">// findApprox_</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a818cc69141d235fafba96f739bcba011">  261</a></span>&#160;        <span class="keywordtype">double</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a818cc69141d235fafba96f739bcba011">BITstar::ImplicitGraph::distanceFunction</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;b)<span class="keyword"> const</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(a-&gt;stateConst()) == <span class="keyword">false</span>)</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            {</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;a-&gt;state is unallocated&quot;</span>);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            }</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(b-&gt;stateConst()) == <span class="keyword">false</span>)</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            {</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;b-&gt;state is unallocated&quot;</span>);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            <span class="comment">// Using RRTstar as an example, this order gives us the distance FROM the queried state TO the other</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            <span class="comment">// neighbours in the structure.</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            <span class="comment">// The distance function between two states</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            <span class="keywordflow">return</span> si_-&gt;distance(b-&gt;stateConst(), a-&gt;stateConst());</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        }</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a20da13a2f166cc1c0662e0e05084dda9">  282</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a20da13a2f166cc1c0662e0e05084dda9">BITstar::ImplicitGraph::nearestSamples</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;vertex, <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">VertexPtrVector</a> *neighbourSamples)</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="comment">// Make sure sampling has happened first:</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            this-&gt;updateSamples(vertex);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="comment">// Increment our counter:</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            ++numNearestNeighbours_;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keywordflow">if</span> (useKNearest_)</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            {</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                freeStateNN_-&gt;nearestK(vertex, k_, *neighbourSamples);</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            }</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                freeStateNN_-&gt;nearestR(vertex, r_, *neighbourSamples);</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            }</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        }</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac290acafb390befb2ef1a7bec439f994">  302</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac290acafb390befb2ef1a7bec439f994">BITstar::ImplicitGraph::nearestVertices</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;vertex, <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">VertexPtrVector</a> *neighbourVertices)</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="comment">// Increment our counter:</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            ++numNearestNeighbours_;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            <span class="keywordflow">if</span> (useKNearest_)</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            {</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                vertexNN_-&gt;nearestK(vertex, k_, *neighbourVertices);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            {</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                vertexNN_-&gt;nearestR(vertex, r_, *neighbourVertices);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            }</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        }</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a773c3c291205b290893f0e5ca9e21d54">  319</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a773c3c291205b290893f0e5ca9e21d54">BITstar::ImplicitGraph::getGraphAsPlannerData</a>(<a class="code" href="classompl_1_1base_1_1PlannerData.html">ompl::base::PlannerData</a> &amp;data)<span class="keyword"> const</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            <span class="comment">// Add samples</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(freeStateNN_))</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            {</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                <span class="comment">// Variables:</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <span class="comment">// The vector of unused samples:</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">VertexPtrVector</a> samples;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                <span class="comment">// Get the vector of samples</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                freeStateNN_-&gt;list(samples);</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                <span class="comment">// Iterate through it turning each into a disconnected vertex</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;freeSample : samples)</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                    <span class="comment">// No, add as a regular vertex:</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                    data.<a class="code" href="classompl_1_1base_1_1PlannerData.html#ac61c5ab5cfd6a66a58e03b1731c1e454">addVertex</a>(<a class="code" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(freeSample-&gt;stateConst()));</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                }</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            }</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            <span class="comment">// No else.</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="comment">// Add vertices</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(vertexNN_))</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            {</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                <span class="comment">// Variables:</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                <span class="comment">// The vector of vertices in the graph:</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">VertexPtrVector</a> vertices;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                <span class="comment">// Get the vector of vertices</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                vertexNN_-&gt;list(vertices);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                <span class="comment">// Iterate through it turning each into a vertex with an edge:</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vertex : vertices)</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                {</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                    <span class="comment">// Is the vertex the start?</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                    <span class="keywordflow">if</span> (vertex-&gt;isRoot())</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                    {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                        <span class="comment">// Yes, add as a start vertex:</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                        data.<a class="code" href="classompl_1_1base_1_1PlannerData.html#a2eea84456784452486aa0065af391f47">addStartVertex</a>(<a class="code" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(vertex-&gt;stateConst()));</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                    }</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                    {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                        <span class="comment">// No, add as a regular vertex:</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                        data.<a class="code" href="classompl_1_1base_1_1PlannerData.html#ac61c5ab5cfd6a66a58e03b1731c1e454">addVertex</a>(<a class="code" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(vertex-&gt;stateConst()));</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                        <span class="comment">// And as an incoming edge</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                        data.<a class="code" href="classompl_1_1base_1_1PlannerData.html#ac09c21494a8c7db500ef1a66bbbb1aa7">addEdge</a>(<a class="code" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(vertex-&gt;getParentConst()-&gt;stateConst()),</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                     <a class="code" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(vertex-&gt;stateConst()));</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                    }</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                }</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;            }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;            <span class="comment">// No else.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        }</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac97c8060b25fc19cac38107ae13d6e33">  375</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac97c8060b25fc19cac38107ae13d6e33">BITstar::ImplicitGraph::hasSolution</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> &amp;solnCost)</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        {</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            <span class="comment">// We have a solution!</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            hasExactSolution_ = <span class="keyword">true</span>;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            <span class="comment">// Store it&#39;s cost as the maximum we&#39;d ever want to sample</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            maxCost_ = solnCost;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;            <span class="comment">// Clear the approximate solution</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            closestDistToGoal_ = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            closestVertexToGoal_.reset();</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        }</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div><div class="line"><a name="l00390"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae274427299a7fb5b40d3633adb8c3f0f">  390</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae274427299a7fb5b40d3633adb8c3f0f">BITstar::ImplicitGraph::updateStartAndGoalStates</a>(<a class="code" href="classompl_1_1base_1_1PlannerInputStates.html">ompl::base::PlannerInputStates</a> &amp;pis,</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                                                              <span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1PlannerTerminationCondition.html">base::PlannerTerminationCondition</a> &amp;ptc)</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            <span class="comment">// Variable</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            <span class="comment">// Whether we&#39;ve added a start or goal:</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="keywordtype">bool</span> addedGoal = <span class="keyword">false</span>;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            <span class="keywordtype">bool</span> addedStart = <span class="keyword">false</span>;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            <span class="comment">// Whether we have to rebuid the queue, i.e.. whether we&#39;ve called updateStartAndGoalStates before</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            <span class="keywordtype">bool</span> rebuildQueue = <span class="keyword">false</span>;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            <span class="comment">/*</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">            Add the new starts and goals to the vectors of said vertices. Do goals first, as they are only added as</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">            samples. We do this as nested conditions so we always call nextGoal(ptc) at least once (regardless of</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">            whether there are moreGoalStates or not) in case we have been given a non trivial PTC that wants us to wait,</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">            but do *not* call it again if there are no more goals (as in the nontrivial PTC case, doing so would cause</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">            us to wait out the ptc and never try to solve anything)</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;            <span class="keywordflow">do</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            {</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                <span class="comment">// A new goal pointer, if there are none, it will be a nullptr.</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                <span class="comment">// We will wait for the duration of PTC for a new goal to appear.</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                <span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ompl::base::State</a> *newGoal = pis.<a class="code" href="classompl_1_1base_1_1PlannerInputStates.html#ae8ea1c2fd3e0e92dbc289a79dd597c98">nextGoal</a>(ptc);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                <span class="comment">// Check if it&#39;s valid</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(newGoal))</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                {</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                    <span class="comment">// It is valid and we are adding a goal, we will need to rebuild the queue if any starts have</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                    <span class="comment">// previously been added as their (and any descendents&#39;) heuristic cost-to-go may change:</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                    rebuildQueue = (!startVertices_.empty());</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                    <span class="comment">// Allocate the vertex pointer</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                    goalVertices_.push_back(std::make_shared&lt;Vertex&gt;(si_, costHelpPtr_-&gt;getOptObj()));</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                    <span class="comment">// Copy the value into the state</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                    si_-&gt;copyState(goalVertices_.back()-&gt;state(), newGoal);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                    <span class="comment">// And add this goal to the set of samples:</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                    this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">addSample</a>(goalVertices_.back());</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                    <span class="comment">// Mark that we&#39;ve added:</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                    addedGoal = <span class="keyword">true</span>;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                }</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="comment">// No else, there was no goal.</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            } <span class="keywordflow">while</span> (pis.<a class="code" href="classompl_1_1base_1_1PlannerInputStates.html#adfcf64da095fd8953611e739ac40af99">haveMoreGoalStates</a>());</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="comment">// And then do the for starts. We do this last as the starts are added to the queue, which uses a cost-to-go</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            <span class="comment">// heuristic in it&#39;s ordering, and for that we want all the goals updated.</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;            <span class="comment">// As there is no way to wait for new *start* states, this loop can be cleaner</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="comment">// There is no need to rebuild the queue when we add start vertices, as the queue is ordered on current</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            <span class="comment">// cost-to-come, and adding a start doesn&#39;t change that.</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            <span class="keywordflow">while</span> (pis.<a class="code" href="classompl_1_1base_1_1PlannerInputStates.html#a3af0f27cc94711e6055d0221aa4f9c42">haveMoreStartStates</a>())</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            {</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                <span class="comment">// A new start pointer</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                <span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ompl::base::State</a> *newStart = pis.<a class="code" href="classompl_1_1base_1_1PlannerInputStates.html#a42a3a7bdbbe09caf937e57785ee97d51">nextStart</a>();</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                <span class="comment">// Allocate the vertex pointer:</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                startVertices_.push_back(std::make_shared&lt;Vertex&gt;(si_, costHelpPtr_-&gt;getOptObj(), <span class="keyword">true</span>));</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                <span class="comment">// Copy the value into the state:</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                si_-&gt;copyState(startVertices_.back()-&gt;state(), newStart);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                <span class="comment">// Add this start vertex to the queue. It is not a sample, so skip that step:</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                queuePtr_-&gt;enqueueVertex(startVertices_.back(), <span class="keyword">false</span>);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                <span class="comment">// Mark that we&#39;ve added:</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                addedStart = <span class="keyword">true</span>;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            }</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            <span class="comment">// Now, if we added a new start and have previously pruned goals, we may want to readd them.</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            <span class="keywordflow">if</span> (addedStart &amp;&amp; !prunedGoalVertices_.empty())</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            {</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                <span class="comment">// An iterator to the vector of pruned goals</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                <span class="keyword">auto</span> prunedGoalIter = prunedGoalVertices_.begin();</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                <span class="comment">// The end point of the vector to consider. We will delete by swapping elements to the end, moving this</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                <span class="comment">// iterator towards the start, and then erasing once at the end.</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                <span class="keyword">auto</span> prunedGoalEnd = prunedGoalVertices_.end();</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                <span class="comment">// Consider each one</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                <span class="keywordflow">while</span> (prunedGoalIter != prunedGoalEnd)</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                {</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                    <span class="comment">// Mark as unpruned</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                    (*prunedGoalIter)-&gt;markUnpruned();</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                    <span class="comment">// Check if it should be readded (i.e., would it be pruned *now*?)</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                    <span class="keywordflow">if</span> (queuePtr_-&gt;vertexPruneCondition(*prunedGoalIter))</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;                    {</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                        <span class="comment">// It would be pruned, so remark as pruned</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                        (*prunedGoalIter)-&gt;markPruned();</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                        <span class="comment">// and move onto the next:</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                        ++prunedGoalIter;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                    }</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                    {</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                        <span class="comment">// It would not be pruned now, so readd it!</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                        <span class="comment">// Add back to the vector:</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                        goalVertices_.push_back(*prunedGoalIter);</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                        <span class="comment">// Add as a sample</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                        this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">addSample</a>(*prunedGoalIter);</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                        <span class="comment">// Mark what we&#39;ve added:</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                        addedGoal = <span class="keyword">true</span>;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                        <span class="comment">// Remove this goal from the vector of pruned vertices.</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                        <span class="comment">// Swap it to the element before our *new* end</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                        <span class="keywordflow">if</span> (prunedGoalIter != (prunedGoalEnd - 1))</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                        {</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                            std::swap(*prunedGoalIter, *(prunedGoalEnd - 1));</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                        }</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                        <span class="comment">// Move the end forward by one, marking it to be deleted</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                        --prunedGoalEnd;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                        <span class="comment">// Leave the iterator where it is, as we need to recheck this element that we pulled from the</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                        <span class="comment">// back</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                        <span class="comment">// Just like the other new goals, we will need to rebuild the queue if any starts have</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                        <span class="comment">// previously been added. Which was a condition to be here in the first place</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                        rebuildQueue = <span class="keyword">true</span>;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                    }</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                }</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                <span class="comment">// Erase any elements moved to the &quot;new end&quot; of the vector</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                <span class="keywordflow">if</span> (prunedGoalEnd != prunedGoalVertices_.end())</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                {</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                    prunedGoalVertices_.erase(prunedGoalEnd, prunedGoalVertices_.end());</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                }</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                <span class="comment">// No else, nothing to delete</span></div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            }</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            <span class="comment">// Similarly, if we added a goal and have previously pruned starts, we will have to do the same on those</span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keywordflow">if</span> (addedGoal &amp;&amp; !prunedStartVertices_.empty())</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            {</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                <span class="comment">// An iterator to the vector of pruned starts</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                <span class="keyword">auto</span> prunedStartIter = prunedStartVertices_.begin();</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                <span class="comment">// The end point of the vector to consider. We will delete by swapping elements to the end, moving this</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                <span class="comment">// iterator towards the start, and then erasing once at the end.</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                <span class="keyword">auto</span> prunedStartEnd = prunedStartVertices_.end();</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                <span class="comment">// Consider each one</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                <span class="keywordflow">while</span> (prunedStartIter != prunedStartEnd)</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                {</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                    <span class="comment">// Mark as unpruned</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                    (*prunedStartIter)-&gt;markUnpruned();</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                    <span class="comment">// Check if it should be readded (i.e., would it be pruned *now*?)</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                    <span class="keywordflow">if</span> (queuePtr_-&gt;vertexPruneCondition(*prunedStartIter))</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                    {</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                        <span class="comment">// It would be pruned, so remark as pruned</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                        (*prunedStartIter)-&gt;markPruned();</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                        <span class="comment">// and move onto the next:</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                        ++prunedStartIter;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                    }</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                    {</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                        <span class="comment">// It would not be pruned, readd it!</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                        <span class="comment">// Add it back to the vector</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                        startVertices_.push_back(*prunedStartIter);</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                        <span class="comment">// Add this start vertex to the queue. It is not a sample, so skip that step:</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                        queuePtr_-&gt;enqueueVertex(*prunedStartIter, <span class="keyword">false</span>);</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                        <span class="comment">// Mark what we&#39;ve added:</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                        addedStart = <span class="keyword">true</span>;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                        <span class="comment">// Remove this start from the vector of pruned vertices.</span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                        <span class="comment">// Swap it to the element before our *new* end</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;                        <span class="keywordflow">if</span> (prunedStartIter != (prunedStartEnd - 1))</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                        {</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                            std::swap(*prunedStartIter, *(prunedStartEnd - 1));</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                        }</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                        <span class="comment">// Move the end forward by one, marking it to be deleted</span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                        --prunedStartEnd;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                        <span class="comment">// Leave the iterator where it is, as we need to recheck this element that we pulled from the</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                        <span class="comment">// back</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                    }</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                }</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                <span class="comment">// Erase any elements moved to the &quot;new end&quot; of the vector</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                <span class="keywordflow">if</span> (prunedStartEnd != prunedStartVertices_.end())</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                {</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                    prunedStartVertices_.erase(prunedStartEnd, prunedStartVertices_.end());</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                }</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                <span class="comment">// No else, nothing to delete</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            }</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;            <span class="comment">// If we&#39;ve added anything, we have some updating to do.</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            <span class="keywordflow">if</span> (addedGoal || addedStart)</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;            {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                <span class="comment">// Update the minimum cost</span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;startVertex : startVertices_)</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                {</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                    <span class="comment">// Take the better of the min cost so far and the cost-to-go from this start</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                    minCost_ = costHelpPtr_-&gt;betterCost(minCost_, costHelpPtr_-&gt;costToGoHeuristic(startVertex));</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                }</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                <span class="comment">// If we have at least one start and goal, allocate a sampler</span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                <span class="keywordflow">if</span> (!startVertices_.empty() &amp;&amp; !goalVertices_.empty())</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                {</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                    <span class="comment">// There is a start and goal, allocate</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                    sampler_ = costHelpPtr_-&gt;getOptObj()-&gt;allocInformedStateSampler(</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                        pdef_, std::numeric_limits&lt;unsigned int&gt;::max());</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                }</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                <span class="comment">// No else, this will get allocated when we get the updated start/goal.</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                <span class="comment">// Was there an existing queue that needs to be rebuilt?</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                <span class="keywordflow">if</span> (rebuildQueue)</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                {</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                    <span class="comment">// There was, inform</span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                    <a class="code" href="group__logging.html#ga04bc36d1b8c57ad7e13a8a48451a3a05">OMPL_INFORM</a>(<span class="stringliteral">&quot;%s: Added new starts and/or goals to the problem. Rebuilding the queue.&quot;</span>,</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                nameFunc_().c_str());</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                    <span class="comment">// Flag the queue as unsorted downstream from every existing start.</span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;startVertex : startVertices_)</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                    {</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                        queuePtr_-&gt;markVertexUnsorted(startVertex);</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                    }</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                    <span class="comment">// Resort the queue.</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                    queuePtr_-&gt;resort();</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                }</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                <span class="comment">// No else</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                <span class="comment">// Iterate through the existing vertices and find the current best approximate solution (if enabled)</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                <span class="keywordflow">if</span> (!hasExactSolution_ &amp;&amp; findApprox_)</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                {</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                    this-&gt;findVertexClosestToGoal();</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                }</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;            }</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;            <span class="comment">// No else, why were we called?</span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;            <span class="comment">// Make sure that if we have a goal, we also have a start, since there&#39;s no way to wait for more *starts*</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;            <span class="keywordflow">if</span> (!goalVertices_.empty() &amp;&amp; startVertices_.empty())</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            {</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                <a class="code" href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a>(<span class="stringliteral">&quot;%s (ImplicitGraph): The problem has a goal but not a start. Since PlannerInputStates &quot;</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                          <span class="stringliteral">&quot;provides no method to &quot;</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;                          <span class="stringliteral">&quot;wait for a _start_ state, BIT* will probably not work at all.&quot;</span>,</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                          nameFunc_().c_str());</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;            }</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            <span class="comment">// No else</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        }</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a0b7c5f309bccfc1ca452cd65feb781b1">  642</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a0b7c5f309bccfc1ca452cd65feb781b1">BITstar::ImplicitGraph::addNewSamples</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;numSamples)</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        {</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            <span class="comment">// Set the cost sampled to the minimum</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            costSampled_ = minCost_;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            <span class="comment">// Store the number of samples being used in this batch</span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;            samplesInThisBatch_ = numSamples;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;            <span class="comment">// Update the nearest-neighbour terms for the number of samples we *will* have.</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            this-&gt;updateNearestTerms();</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            <span class="comment">// Relabel all the previous samples as old</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;freeSample : newSamples_)</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            {</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                <span class="comment">// If the sample still exists, mark as old. It can get pruned during a resort.</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                <span class="keywordflow">if</span> (!freeSample-&gt;isPruned())</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                {</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                    freeSample-&gt;markOld();</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                }</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                <span class="comment">// No else, this sample has been pruned and will shortly disappear</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;            }</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;            <span class="comment">// Reuse the recycled samples as new samples</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;sample : recycledSamples_)</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;            {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">addSample</a>(sample);</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;            }</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;            <span class="comment">// These recycled samples are our only new samples</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            newSamples_ = recycledSamples_;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            <span class="comment">// And there are no longer and recycled samples</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            recycledSamples_.clear();</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            <span class="comment">// We don&#39;t add *new* samples until the next time &quot;nearSamples&quot; is called. This is to support JIT sampling.</span></div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        }</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac52b0587ca4de60f74428ac658ed02b3">  681</a></span>&#160;        std::pair&lt;unsigned int, unsigned int&gt; <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac52b0587ca4de60f74428ac658ed02b3">BITstar::ImplicitGraph::prune</a>(<span class="keywordtype">double</span> prunedMeasure)</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        {</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            <span class="keywordflow">if</span> (hasExactSolution_ == <span class="keyword">false</span>)</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            {</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;A graph cannot be pruned until a solution is found&quot;</span>);</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;            }</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;            <span class="comment">// Variable</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            std::pair&lt;unsigned int, unsigned int&gt; numPruned(0u, 0u);</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            <span class="comment">// Store the measure of the problem I&#39;m approximating</span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;            approximationMeasure_ = prunedMeasure;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;            <span class="comment">// Prune the starts/goals</span></div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;            numPruned = numPruned + this-&gt;pruneStartsGoals();</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;            <span class="comment">// Prune the samples</span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            numPruned.second = numPruned.second + this-&gt;pruneSamples();</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;            <span class="keywordflow">return</span> numPruned;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        }</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;</div><div class="line"><a name="l00707"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">  707</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">BITstar::ImplicitGraph::addSample</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;newSample)</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        {</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;            <span class="comment">// NO COUNTER. generated samples are counted at the sampler.</span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;            <span class="comment">// Mark as new</span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            newSample-&gt;markNew();</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;            <span class="comment">// Add to the vector of new samples</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;            newSamples_.push_back(newSample);</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;            <span class="comment">// Add to the NN structure:</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;            freeStateNN_-&gt;add(newSample);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        }</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div><div class="line"><a name="l00723"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aada296d39c8722d30ad4fa308a318b93">  723</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aada296d39c8722d30ad4fa308a318b93">BITstar::ImplicitGraph::removeSample</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;oldSample)</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        {</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;            <span class="comment">// Variable:</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;            <span class="comment">// Create a copy of the vertex pointer so we don&#39;t delete it out from under ourselves.</span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> sampleToDelete(oldSample);</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            <span class="comment">// Increment our counter</span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            ++numFreeStatesPruned_;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;            <span class="comment">// Remove from the set of samples</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            freeStateNN_-&gt;remove(sampleToDelete);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            <span class="comment">// Mark the sample as pruned</span></div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            sampleToDelete-&gt;markPruned();</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        }</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div><div class="line"><a name="l00741"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a53f2774eba2cd3a953026726c92b9fc3">  741</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a53f2774eba2cd3a953026726c92b9fc3">BITstar::ImplicitGraph::addVertex</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;newVertex, <span class="keywordtype">bool</span> removeFromFree)</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        {</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <span class="comment">// Make sure it&#39;s connected first, so that the queue gets updated properly.</span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;            <span class="comment">// This is a day of debugging I&#39;ll never get back</span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;            <span class="keywordflow">if</span> (newVertex-&gt;isInTree() == <span class="keyword">false</span>)</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;            {</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;Vertices must be connected to the graph before adding&quot;</span>);</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            }</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;            <span class="comment">// Increment the number of vertices added:</span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            ++numVertices_;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;            <span class="comment">// Remove the vertex from the set of samples (if it even existed)</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            <span class="keywordflow">if</span> (removeFromFree)</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            {</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                freeStateNN_-&gt;remove(newVertex);</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;            }</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;            <span class="comment">// No else</span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="comment">// Add to the NN structure:</span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;            vertexNN_-&gt;add(newVertex);</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;            <span class="comment">// Update the nearest vertex to the goal (if tracking)</span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;            <span class="keywordflow">if</span> (!hasExactSolution_ &amp;&amp; findApprox_)</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;            {</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                this-&gt;testClosestToGoal(newVertex);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;            }</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        }</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;</div><div class="line"><a name="l00774"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9e9ac3d6a6ae20cf086f2539e6b41a44">  774</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9e9ac3d6a6ae20cf086f2539e6b41a44">BITstar::ImplicitGraph::removeVertex</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;oldVertex, <span class="keywordtype">bool</span> moveToFree)</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;        {</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;            this-&gt;confirmSetup();</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;            <span class="comment">// Variable:</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            <span class="comment">// A copy of the vertex pointer to be removed so we can&#39;t delete it out from under ourselves (occurs when</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;            <span class="comment">// this function is given an element of the maintained set as the argument)</span></div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;            <a class="code" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> vertexToDelete(oldVertex);</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;            <span class="comment">// Increment our counter</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;            ++numVerticesDisconnected_;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;            <span class="comment">// Remove from the nearest-neighbour structure</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;            vertexNN_-&gt;remove(vertexToDelete);</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;            <span class="comment">// Add back as sample, if that would be beneficial</span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;            <span class="keywordflow">if</span> (moveToFree &amp;&amp; !queuePtr_-&gt;samplePruneCondition(vertexToDelete))</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;            {</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                <span class="comment">// Yes, the vertex is still useful as a sample. Track as recycled so they are reused as samples in the</span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                <span class="comment">// next batch.</span></div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                recycledSamples_.push_back(vertexToDelete);</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;                <span class="comment">// Return that the vertex was recycled</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                <span class="keywordflow">return</span> 0u;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            }</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;            {</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                <span class="comment">// No, the vertex is not useful anymore. Mark as pruned. This functions as a lock to prevent accessing</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                <span class="comment">// anything about the vertex.</span></div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                vertexToDelete-&gt;markPruned();</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                <span class="comment">// Return that the vertex was completely pruned</span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                <span class="keywordflow">return</span> 1u;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;            }</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;        }</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;        <span class="comment">// Private functions:</span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;        <span class="keywordtype">void</span> BITstar::ImplicitGraph::updateSamples(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;vertex)</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;        {</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;            <span class="comment">// Variable</span></div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;            <span class="comment">// The required cost to contain the neighbourhood of this vertex:</span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> costReqd = this-&gt;neighbourhoodCost(vertex);</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;            <span class="comment">// Check if we need to generate new samples inorder to completely cover the neighbourhood of the vertex</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;            <span class="keywordflow">if</span> (costHelpPtr_-&gt;isCostBetterThan(costSampled_, costReqd))</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            {</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                <span class="comment">// The total number of samples we wish to have.</span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalReqdSamples;</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                <span class="comment">// Get the measure of what we&#39;re sampling</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;                <span class="keywordflow">if</span> (useJustInTimeSampling_)</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;                {</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;                    <span class="comment">// Variables</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                    <span class="comment">// The sample density for this slice of the problem.</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                    <span class="keywordtype">double</span> sampleDensity;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                    <span class="comment">// The resulting number of samples needed for this slice as a *double*</span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                    <span class="keywordtype">double</span> dblNum;</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                    <span class="comment">// Calculate the sample density given the number of samples per batch and the measure of this batch</span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                    <span class="comment">// by assuming that this batch will fill the same measure as the previous</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;                    sampleDensity = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(samplesInThisBatch_) / approximationMeasure_;</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;                    <span class="comment">// Convert that into the number of samples needed for this slice.</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                    dblNum = sampleDensity * sampler_-&gt;getInformedMeasure(costSampled_, costReqd);</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                    <span class="comment">// The integer of the double are definitely sampled</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                    totalReqdSamples = numSamples_ + <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(dblNum);</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                    <span class="comment">// And the fractional part represents the probability of one more sample. I like being pedantic.</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                    <span class="keywordflow">if</span> (rng_.<a class="code" href="classompl_1_1RNG.html#af9450941c808fc53f30173c364bbfd25">uniform01</a>() &lt;= (dblNum - <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(totalReqdSamples)))</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                    {</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                        <span class="comment">// One more please</span></div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                        ++totalReqdSamples;</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                    }</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                    <span class="comment">// No else.</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                }</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                {</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                    <span class="comment">// We&#39;re generating all our samples in one batch. Do it to it.</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                    totalReqdSamples = numSamples_ + samplesInThisBatch_;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                }</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                <span class="comment">// Actually generate the new samples</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                <span class="keywordflow">while</span> (numSamples_ &lt; totalReqdSamples)</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                {</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;                    <span class="comment">// Variable</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                    <span class="comment">// The new state:</span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                    <span class="keyword">auto</span> newState = std::make_shared&lt;Vertex&gt;(si_, costHelpPtr_-&gt;getOptObj());</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                    <span class="comment">// Sample in the interval [costSampled_, costReqd):</span></div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                    sampler_-&gt;sampleUniform(newState-&gt;state(), costSampled_, costReqd);</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;                    <span class="comment">// If the state is collision free, add it to the set of free states</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                    ++numStateCollisionChecks_;</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                    <span class="keywordflow">if</span> (si_-&gt;isValid(newState-&gt;stateConst()))</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                    {</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                        <span class="comment">// Add the new state as a sample</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                        this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">addSample</a>(newState);</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                        <span class="comment">// Update the number of uniformly distributed states</span></div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                        ++numUniformStates_;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;                        <span class="comment">// Update the number of sample</span></div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;                        ++numSamples_;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;                    }</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;                    <span class="comment">// No else</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;                }</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                <span class="comment">// Mark that we&#39;ve sampled all cost spaces (This is in preparation for JIT sampling)</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;                costSampled_ = costReqd;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;            }</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;            <span class="comment">// No else, the samples are up to date</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;        }</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        <span class="keywordtype">void</span> BITstar::ImplicitGraph::findVertexClosestToGoal()</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;        {</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;            <span class="keywordflow">if</span> (static_cast&lt;bool&gt;(vertexNN_))</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;            {</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;                <span class="comment">// The vertices in the graph</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;                <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">VertexPtrVector</a> vertices;</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                <span class="comment">// Get the vector of vertices</span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                vertexNN_-&gt;list(vertices);</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;                <span class="comment">// Iterate through them testing which is the closest to the goal.</span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vertex : vertices)</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                {</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;                    this-&gt;testClosestToGoal(vertex);</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;                }</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;            }</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;            <span class="comment">// No else, I do nothing.</span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;        }</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        std::pair&lt;unsigned int, unsigned int&gt; BITstar::ImplicitGraph::pruneStartsGoals()</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;        {</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;            <span class="comment">// Variable</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;            <span class="comment">// The number of starts/goals disconnected from the tree/pruned</span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            std::pair&lt;unsigned int, unsigned int&gt; numPruned(0u, 0u);</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;            <span class="comment">// Are there superfluous starts to prune?</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;            <span class="keywordflow">if</span> (startVertices_.size() &gt; 1u)</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;                <span class="comment">// Yes, Iterate through the vector</span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;                <span class="comment">// The iterator to the start:</span></div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                <span class="keyword">auto</span> startIter = startVertices_.begin();</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;                <span class="comment">// The end point of the vector to consider. We will delete by swapping elements to the end, moving this</span></div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                <span class="comment">// iterator towards the start, and then erasing once at the end.</span></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                <span class="keyword">auto</span> startEnd = startVertices_.end();</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                <span class="comment">// Run until at the end:</span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;                <span class="keywordflow">while</span> (startIter != startEnd)</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;                {</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                    <span class="comment">// Check if this start has met the criteria to be pruned</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                    <span class="keywordflow">if</span> (queuePtr_-&gt;vertexPruneCondition(*startIter))</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;                    {</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;                        <span class="comment">// It has, remove the start vertex DO NOT consider it as a sample. It is marked as a root node,</span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;                        <span class="comment">// so having it as a sample would cause all kinds of problems, also it shouldn&#39;t be possible for</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;                        <span class="comment">// it to ever be useful as a sample anyway, unless there is a very weird cost function in play.</span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                        numPruned.second = numPruned.second + this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9e9ac3d6a6ae20cf086f2539e6b41a44">removeVertex</a>(*startIter, <span class="keyword">false</span>);</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                        <span class="comment">// Count as a disconnected vertex</span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;                        ++numPruned.first;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;                        <span class="comment">// Remove it from the queue</span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                        queuePtr_-&gt;unqueueVertex(*startIter);</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                        <span class="comment">// Store the start vertex in the pruned vector, in case it later needs to be readded:</span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                        prunedStartVertices_.push_back(*startIter);</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;                        <span class="comment">// Remove this start from the vector.</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;                        <span class="comment">// Swap it to the element before our *new* end</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;                        <span class="keywordflow">if</span> (startIter != (startEnd - 1))</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;                        {</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                            std::swap(*startIter, *(startEnd - 1));</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                        }</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                        <span class="comment">// Move the end forward by one, marking it to be deleted</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                        --startEnd;</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                        <span class="comment">// Leave the iterator where it is, as we need to recheck this element that we pulled from the</span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                        <span class="comment">// back</span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                    }</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                    {</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                        <span class="comment">// Still valid, move to the next one:</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                        ++startIter;</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                    }</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;                }</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;                <span class="comment">// Erase any elements moved to the &quot;new end&quot; of the vector</span></div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;                <span class="keywordflow">if</span> (startEnd != startVertices_.end())</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;                {</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;                    startVertices_.erase(startEnd, startVertices_.end());</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                }</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                <span class="comment">// No else, nothing to delete</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;            }</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;            <span class="comment">// No else, can&#39;t prune 1 start.</span></div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;            <span class="comment">// Are there superfluous goals to prune?</span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;            <span class="keywordflow">if</span> (goalVertices_.size() &gt; 1u)</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;            {</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;                <span class="comment">// Yes, Iterate through the vector</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;                <span class="comment">// Variable</span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                <span class="comment">// The iterator to the start:</span></div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                <span class="keyword">auto</span> goalIter = goalVertices_.begin();</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;                <span class="comment">// The end point of the vector to consider. We will delete by swapping elements to the end, moving this</span></div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;                <span class="comment">// iterator towards the start, and then erasing once at the end.</span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                <span class="keyword">auto</span> goalEnd = goalVertices_.end();</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                <span class="comment">// Run until at the end:</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;                <span class="keywordflow">while</span> (goalIter != goalEnd)</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                {</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                    <span class="comment">// Check if this start has met the criteria to be pruned</span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                    <span class="keywordflow">if</span> (queuePtr_-&gt;vertexPruneCondition(*goalIter))</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                    {</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                        <span class="comment">// It has, remove the goal vertex completely</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;                        <span class="comment">// Check if this vertex is in the tree</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;                        <span class="keywordflow">if</span> ((*goalIter)-&gt;isInTree())</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;                        {</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                            <span class="comment">// It is, remove it from the queue</span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                            queuePtr_-&gt;unqueueVertex(*goalIter);</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                            <span class="comment">// and as a vertex, allowing it to move to the set of samples.</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                            numPruned.second = numPruned.second + this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9e9ac3d6a6ae20cf086f2539e6b41a44">removeVertex</a>(*goalIter, <span class="keyword">true</span>);</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;                            <span class="comment">// Count it as a disconnected vertex</span></div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;                            ++numPruned.first;</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;                        }</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;                        <span class="keywordflow">else</span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                        {</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;                            <span class="comment">// It is not, so just it like a sample</span></div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;                            this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aada296d39c8722d30ad4fa308a318b93">removeSample</a>(*goalIter);</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;                            <span class="comment">// Count a pruned sample</span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;                            ++numPruned.second;</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                        }</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;                        <span class="comment">// Store the start vertex in the pruned vector, in case it later needs to be readded:</span></div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;                        prunedGoalVertices_.push_back(*goalIter);</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                        <span class="comment">// Remove this goal from the vector.</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                        <span class="comment">// Swap it to the element before our *new* end</span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                        <span class="keywordflow">if</span> (goalIter != (goalEnd - 1))</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                        {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;                            std::swap(*goalIter, *(goalEnd - 1));</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;                        }</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;                        <span class="comment">// Move the end forward by one, marking it to be deleted</span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;                        --goalEnd;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;                        <span class="comment">// Leave the iterator where it is, as we need to recheck this element that we pulled from the</span></div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;                        <span class="comment">// back</span></div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                    }</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                    {</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                        <span class="comment">// The goal is still valid, get the next</span></div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                        ++goalIter;</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                    }</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;                }</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;                <span class="comment">// Erase any elements moved to the &quot;new end&quot; of the vector</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                <span class="keywordflow">if</span> (goalEnd != goalVertices_.end())</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                {</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                    goalVertices_.erase(goalEnd, goalVertices_.end());</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;                }</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;                <span class="comment">// No else, nothing to delete</span></div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;            }</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;            <span class="comment">// No else, can&#39;t prune 1 goal.</span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;            <span class="comment">// We don&#39;t need to update our approximate solution (if we&#39;re providing one) as we will only prune once a</span></div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;            <span class="comment">// solution exists.</span></div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;            <span class="comment">// Return the amount of work done</span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;            <span class="keywordflow">return</span> numPruned;</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;        }</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BITstar::ImplicitGraph::pruneSamples()</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;        {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;            <span class="comment">// Variable:</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;            <span class="comment">// The number of samples pruned in this pass:</span></div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPruned = 0u;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;            <span class="comment">// Are we dropping samples anytime we prune?</span></div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;            <span class="keywordflow">if</span> (dropSamplesOnPrune_)</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;            {</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;                <span class="comment">// We are, store the number pruned</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;                numPruned = freeStateNN_-&gt;size();</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;                <span class="comment">// and the number of uniform samples</span></div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;                numUniformStates_ = 0u;</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;                <span class="comment">// Then remove all of the samples</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;                freeStateNN_-&gt;clear();</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;                <span class="comment">// and increasing our global counter</span></div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;                numFreeStatesPruned_ = numFreeStatesPruned_ + numPruned;</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;            }</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;            {</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;                <span class="comment">// Variable:</span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;                <span class="comment">// The vector of samples:</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;                <a class="code" href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">VertexPtrVector</a> samples;</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;                <span class="comment">// Get the vector of samples</span></div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;                freeStateNN_-&gt;list(samples);</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;                <span class="comment">// Iterate through the vector and remove any samples that should not be in the queue</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;freeSample : samples)</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;                {</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;                    <span class="comment">// Check if this state should be pruned:</span></div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                    <span class="keywordflow">if</span> (queuePtr_-&gt;samplePruneCondition(freeSample))</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;                    {</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;                        <span class="comment">// Yes, remove it</span></div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;                        this-&gt;<a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aada296d39c8722d30ad4fa308a318b93">removeSample</a>(freeSample);</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;                        <span class="comment">// and increment the counter</span></div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;                        ++numPruned;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;                    }</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;                    <span class="comment">// No else, keep.</span></div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;                }</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;            }</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;            <span class="keywordflow">return</span> numPruned;</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        }</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;        <span class="keywordtype">void</span> BITstar::ImplicitGraph::testClosestToGoal(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;newVertex)</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;        {</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;            <span class="comment">// Variable</span></div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;            <span class="comment">// The distance from this vertex to the goal:</span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;            <span class="keywordtype">double</span> distFromGoal;</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;            <span class="comment">// Find the shortest distance between the given vertex and a goal</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;            pdef_-&gt;getGoal()-&gt;isSatisfied(newVertex-&gt;stateConst(), &amp;distFromGoal);</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;            <span class="comment">// Compare to the current best approximate solution</span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;            <span class="keywordflow">if</span> (distFromGoal &lt; closestDistToGoal_)</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;            {</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;                <span class="comment">// Better, update the approximate solution</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;                closestVertexToGoal_ = newVertex;</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;                closestDistToGoal_ = distFromGoal;</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;            }</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;            <span class="comment">// No else, don&#39;t update if worse</span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;        }</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;        <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> BITstar::ImplicitGraph::neighbourhoodCost(<span class="keyword">const</span> <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;vertex)<span class="keyword"> const</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;            <span class="comment">// Are we using JIT sampling?</span></div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;            <span class="keywordflow">if</span> (useJustInTimeSampling_)</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;            {</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;                <span class="comment">// We are, return the maximum heuristic cost that represents a sample in the neighbourhood of the given</span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;                <span class="comment">// vertex.</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;                <span class="comment">// There is no point generating samples worse the best solution (maxCost_) even if those samples are in</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;                <span class="comment">// this vertex&#39;s neighbourhood.</span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;                <span class="keywordflow">return</span> costHelpPtr_-&gt;betterCost(</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;                    maxCost_, costHelpPtr_-&gt;combineCosts(costHelpPtr_-&gt;lowerBoundHeuristicVertex(vertex),</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;                                                         <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>(2.0 * r_)));</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;            }</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;            <span class="comment">// We are not, return the maximum cost we&#39;d ever want to sample</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;            <span class="keywordflow">return</span> maxCost_;</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;        }</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;        <span class="keywordtype">void</span> BITstar::ImplicitGraph::updateNearestTerms()</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;        {</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;            <span class="comment">// Variables:</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;            <span class="comment">// The number of uniformly distributed states:</span></div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;            <span class="comment">// Calculate N, are we dropping samples?</span></div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;            <span class="keywordflow">if</span> (dropSamplesOnPrune_)</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;            {</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;                <span class="comment">// We are, so we&#39;ve been tracking the number of uniform states, just use that</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;                N = numUniformStates_;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;            }</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;            {</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;                <span class="comment">// We are not, so then all vertices and samples are uniform, use that</span></div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;                N = vertexNN_-&gt;size() + freeStateNN_-&gt;size();</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;            }</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;            <span class="comment">// If this is the first batch, we will be calculating the connection limits from only the starts and goals</span></div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;            <span class="comment">// for an RGG with m samples. That will be a complex graph. In this case, let us calculate the connection</span></div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;            <span class="comment">// limits considering the samples about to be generated. Doing so is equivalent to setting an upper-bound on</span></div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;            <span class="comment">// the radius, which RRT* does with it&#39;s min(maxEdgeLength, RGG-radius).</span></div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;            <span class="keywordflow">if</span> (N == (startVertices_.size() + goalVertices_.size()))</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;            {</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;                N = N + samplesInThisBatch_;</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;            }</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;            <span class="comment">// Now update the appropriate term</span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;            <span class="keywordflow">if</span> (useKNearest_)</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;            {</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;                k_ = this-&gt;calculateK(N);</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;            }</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;            {</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                r_ = this-&gt;calculateR(N);</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;            }</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;        }</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;        <span class="keywordtype">double</span> BITstar::ImplicitGraph::calculateR(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N)<span class="keyword"> const</span></div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;            <span class="comment">// Variables</span></div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;            <span class="comment">// The dimension cast as a double for readibility;</span></div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;            <span class="keyword">auto</span> dimDbl = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(si_-&gt;getStateDimension());</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;            <span class="comment">// The size of the graph</span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;            <span class="keyword">auto</span> cardDbl = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(N);</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;            <span class="comment">// Calculate the term and return</span></div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;            <span class="keywordflow">return</span> rewireFactor_ * this-&gt;minimumRggR() * std::pow(<a class="code" href="namespaceompl_1_1msg.html#affe7852f27c06f98af7eb2579f1e5350">std::log</a>(cardDbl) / cardDbl, 1 / dimDbl);</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;        }</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BITstar::ImplicitGraph::calculateK(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N)<span class="keyword"> const</span></div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;            <span class="comment">// Calculate the term and return</span></div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;            <span class="keywordflow">return</span> std::ceil(rewireFactor_ * k_rgg_ * <a class="code" href="namespaceompl_1_1msg.html#affe7852f27c06f98af7eb2579f1e5350">std::log</a>(static_cast&lt;double&gt;(N)));</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;        }</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;        <span class="keywordtype">double</span> BITstar::ImplicitGraph::minimumRggR()<span class="keyword"> const</span></div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;            <span class="comment">// Variables</span></div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;            <span class="comment">// The dimension cast as a double for readibility;</span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;            <span class="keyword">auto</span> dimDbl = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(si_-&gt;getStateDimension());</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;            <span class="comment">// Calculate the term and return</span></div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;            <span class="keywordflow">return</span> 2.0 *</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;                   std::pow((1.0 + 1.0 / dimDbl) * (approximationMeasure_ / <a class="code" href="namespaceompl.html#ac07d992fd77292786e9cdc9a0cadaeb0">unitNBallMeasure</a>(si_-&gt;getStateDimension())),</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;                            1.0 / dimDbl);  <span class="comment">// RRG radius (biggest for unit-volume problem)</span></div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;            <span class="comment">/*</span></div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="comment">            return std::pow(2.0 * (1.0 + 1.0 / dimDbl) * (approximationMeasure_ /</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;<span class="comment">            unitNBallMeasure(si_-&gt;getStateDimension())), 1.0 / dimDbl); //RRT* radius (smaller for unit-volume problem)</span></div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;<span class="comment">            return 2.0 * std::pow((1.0 / dimDbl) * (approximationMeasure_ / unitNBallMeasure(si_-&gt;getStateDimension())),</span></div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;<span class="comment">            1.0 / dimDbl); //FMT* radius (smallest for R2, equiv to RRT* for R3 and then middle for higher d. All</span></div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;<span class="comment">            unit-volume)</span></div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;<span class="comment">            */</span></div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;        }</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;        <span class="keywordtype">double</span> BITstar::ImplicitGraph::minimumRggK()<span class="keyword"> const</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;            <span class="comment">// Variables</span></div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;            <span class="comment">// The dimension cast as a double for readibility;</span></div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;            <span class="keyword">auto</span> dimDbl = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(si_-&gt;getStateDimension());</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;            <span class="comment">// Calculate the term and return</span></div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;            <span class="keywordflow">return</span> boost::math::constants::e&lt;double&gt;() +</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;                   (boost::math::constants::e&lt;double&gt;() / dimDbl);  <span class="comment">// RRG k-nearest</span></div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;        }</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;        <span class="keywordtype">void</span> BITstar::ImplicitGraph::confirmSetup()<span class="keyword"> const</span></div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;            <span class="keywordflow">if</span> (isSetup_ == <span class="keyword">false</span>)</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;            {</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;BITstar::ImplicitGraph was used before it was setup.&quot;</span>);</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;            }</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;        }</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;        <span class="comment">// Boring sets/gets (Public):</span></div><div class="line"><a name="l01242"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a46074e6a6f225fd1596cf5df29c5c10e"> 1242</a></span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a46074e6a6f225fd1596cf5df29c5c10e">BITstar::ImplicitGraph::hasAGoal</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;            <span class="keywordflow">return</span> (!goalVertices_.empty());</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;        }</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;</div><div class="line"><a name="l01247"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a44e05d68d7c67f33b55b9b3a30024508"> 1247</a></span>&#160;        BITstar::VertexPtrVector::const_iterator <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a44e05d68d7c67f33b55b9b3a30024508">BITstar::ImplicitGraph::startVerticesBeginConst</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;            <span class="keywordflow">return</span> startVertices_.cbegin();</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;        }</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;</div><div class="line"><a name="l01252"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aae3192ccb278d9e5b86f790c708f0ec5"> 1252</a></span>&#160;        BITstar::VertexPtrVector::const_iterator <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aae3192ccb278d9e5b86f790c708f0ec5">BITstar::ImplicitGraph::startVerticesEndConst</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;            <span class="keywordflow">return</span> startVertices_.cend();</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;        }</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;</div><div class="line"><a name="l01257"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aa60d9cc83616fbefa8888b625015821e"> 1257</a></span>&#160;        BITstar::VertexPtrVector::const_iterator <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aa60d9cc83616fbefa8888b625015821e">BITstar::ImplicitGraph::goalVerticesBeginConst</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;            <span class="keywordflow">return</span> goalVertices_.cbegin();</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;        }</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;</div><div class="line"><a name="l01262"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#af0876737708c6003e5c9587c3d6116f9"> 1262</a></span>&#160;        BITstar::VertexPtrVector::const_iterator <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#af0876737708c6003e5c9587c3d6116f9">BITstar::ImplicitGraph::goalVerticesEndConst</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;            <span class="keywordflow">return</span> goalVertices_.cend();</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;        }</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;</div><div class="line"><a name="l01267"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a83be6b9a2d27eefc72bcc3b83ae6d75f"> 1267</a></span>&#160;        <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a83be6b9a2d27eefc72bcc3b83ae6d75f">BITstar::ImplicitGraph::minCost</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;            <span class="keywordflow">return</span> minCost_;</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;        }</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;</div><div class="line"><a name="l01272"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a37f48910d8abfcf844aadf25a0399b5a"> 1272</a></span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a37f48910d8abfcf844aadf25a0399b5a">BITstar::ImplicitGraph::hasInformedMeasure</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;            <span class="keywordflow">return</span> sampler_-&gt;hasInformedMeasure();</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;        }</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;</div><div class="line"><a name="l01277"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a212630ab596b0b376c8e58b7b09b52f5"> 1277</a></span>&#160;        <span class="keywordtype">double</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a212630ab596b0b376c8e58b7b09b52f5">BITstar::ImplicitGraph::getInformedMeasure</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> &amp;cost)<span class="keyword"> const</span></div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;            <span class="keywordflow">return</span> sampler_-&gt;getInformedMeasure(cost);</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;        }</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;</div><div class="line"><a name="l01282"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a3921b2e4eb248ba63e8deb2fe880b6de"> 1282</a></span>&#160;        <a class="code" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">BITstar::VertexConstPtr</a> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a3921b2e4eb248ba63e8deb2fe880b6de">BITstar::ImplicitGraph::closestVertexToGoal</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;            <span class="keywordflow">if</span> (findApprox_ == <span class="keyword">false</span>)</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;            {</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;Approximate solutions are not being tracked.&quot;</span>);</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;            }</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;            <span class="keywordflow">return</span> closestVertexToGoal_;</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;        }</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;</div><div class="line"><a name="l01293"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a656c1b485fd0f5a73f51ff92e745d7be"> 1293</a></span>&#160;        <span class="keywordtype">double</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a656c1b485fd0f5a73f51ff92e745d7be">BITstar::ImplicitGraph::smallestDistanceToGoal</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;            <span class="keywordflow">if</span> (findApprox_ == <span class="keyword">false</span>)</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;            {</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;Approximate solutions are not being tracked.&quot;</span>);</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;            }</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;            <span class="keywordflow">return</span> closestDistToGoal_;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;        }</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;</div><div class="line"><a name="l01304"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a36c15f7c61fff5e091f0259925ea7d2c"> 1304</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a36c15f7c61fff5e091f0259925ea7d2c">BITstar::ImplicitGraph::getConnectivityK</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;            <span class="keywordflow">if</span> (useKNearest_ == <span class="keyword">false</span>)</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;            {</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;Using an r-disc graph.&quot;</span>);</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;            }</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;            <span class="keywordflow">return</span> k_;</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;        }</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;</div><div class="line"><a name="l01315"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a58dda8d6fbf02bbe2f884a4c78fa4f28"> 1315</a></span>&#160;        <span class="keywordtype">double</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a58dda8d6fbf02bbe2f884a4c78fa4f28">BITstar::ImplicitGraph::getConnectivityR</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="preprocessor">#ifdef BITSTAR_DEBUG</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;            <span class="keywordflow">if</span> (useKNearest_ == <span class="keyword">true</span>)</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;            {</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classompl_1_1Exception.html">ompl::Exception</a>(<span class="stringliteral">&quot;Using a k-nearest graph.&quot;</span>);</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;            }</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="preprocessor">#endif  // BITSTAR_DEBUG</span></div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;            <span class="keywordflow">return</span> r_;</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;        }</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div><div class="line"><a name="l01326"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8bae302cadff1eec3c7f01316e413359"> 1326</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8bae302cadff1eec3c7f01316e413359">BITstar::ImplicitGraph::setRewireFactor</a>(<span class="keywordtype">double</span> rewireFactor)</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;        {</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;            <span class="comment">// Store</span></div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;            rewireFactor_ = rewireFactor;</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;            <span class="comment">// Check if there&#39;s things to update</span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;            <span class="keywordflow">if</span> (isSetup_)</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;            {</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;                <span class="comment">// Reinitialize the terms:</span></div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;                this-&gt;updateNearestTerms();</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;            }</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;        }</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;</div><div class="line"><a name="l01339"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ad843e38fb5eaf877f8a93dba8af3dd50"> 1339</a></span>&#160;        <span class="keywordtype">double</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ad843e38fb5eaf877f8a93dba8af3dd50">BITstar::ImplicitGraph::getRewireFactor</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;            <span class="keywordflow">return</span> rewireFactor_;</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;        }</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;</div><div class="line"><a name="l01344"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ad16e8dfd69bd7c55287b8ac26e4a7cf9"> 1344</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ad16e8dfd69bd7c55287b8ac26e4a7cf9">BITstar::ImplicitGraph::setUseKNearest</a>(<span class="keywordtype">bool</span> useKNearest)</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;        {</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;            <span class="comment">// Assure that we&#39;re not trying to enable k-nearest with JIT sampling already on</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;            <span class="keywordflow">if</span> (useKNearest &amp;&amp; useJustInTimeSampling_)</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;            {</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;                <a class="code" href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a>(<span class="stringliteral">&quot;%s (ImplicitGraph): The k-nearest variant of BIT* cannot be used with JIT sampling, &quot;</span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;                          <span class="stringliteral">&quot;continuing to use the r-disc variant.&quot;</span>,</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;                          nameFunc_().c_str());</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;            }</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;            {</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;                <span class="comment">// Store</span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;                useKNearest_ = useKNearest;</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;                <span class="comment">// Check if there&#39;s things to update</span></div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;                <span class="keywordflow">if</span> (isSetup_)</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;                {</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;                    <span class="comment">// Calculate the current term:</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;                    this-&gt;updateNearestTerms();</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;                }</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;            }</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;        }</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;</div><div class="line"><a name="l01367"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a768bff7a91e6b6249ae86a400e9d3bf6"> 1367</a></span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a768bff7a91e6b6249ae86a400e9d3bf6">BITstar::ImplicitGraph::getUseKNearest</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;            <span class="keywordflow">return</span> useKNearest_;</div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;        }</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;</div><div class="line"><a name="l01372"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9255f486a1f99c851fc78b3a6287eb37"> 1372</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9255f486a1f99c851fc78b3a6287eb37">BITstar::ImplicitGraph::setJustInTimeSampling</a>(<span class="keywordtype">bool</span> useJit)</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;        {</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;            <span class="comment">// Assure that we&#39;re not trying to enable k-nearest with JIT sampling already on</span></div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;            <span class="keywordflow">if</span> (useKNearest_ &amp;&amp; useJit)</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;            {</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;                <a class="code" href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a>(<span class="stringliteral">&quot;%s (ImplicitGraph): Just-in-time sampling cannot be used with the k-nearest variant of &quot;</span></div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;                          <span class="stringliteral">&quot;BIT*, continuing to use regular sampling.&quot;</span>,</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;                          nameFunc_().c_str());</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;            }</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;            {</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;                <span class="comment">// Store</span></div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;                useJustInTimeSampling_ = useJit;</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;                <span class="comment">// Announce limitation:</span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;                <span class="keywordflow">if</span> (useJit)</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;                {</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;                    <a class="code" href="group__logging.html#ga04bc36d1b8c57ad7e13a8a48451a3a05">OMPL_INFORM</a>(<span class="stringliteral">&quot;%s (ImplicitGraph): Just-in-time sampling is currently only implemented for problems &quot;</span></div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;                                <span class="stringliteral">&quot;seeking to minimize path-length.&quot;</span>,</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;                                nameFunc_().c_str());</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;                }</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;                <span class="comment">// No else</span></div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;            }</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;        }</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;</div><div class="line"><a name="l01397"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a56b776b8e0d8172917d63f8987052b28"> 1397</a></span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a56b776b8e0d8172917d63f8987052b28">BITstar::ImplicitGraph::getJustInTimeSampling</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;            <span class="keywordflow">return</span> useJustInTimeSampling_;</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;        }</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;</div><div class="line"><a name="l01402"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#af7704a9619a5b464c88baf2549494879"> 1402</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#af7704a9619a5b464c88baf2549494879">BITstar::ImplicitGraph::setDropSamplesOnPrune</a>(<span class="keywordtype">bool</span> dropSamples)</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;        {</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;            <span class="comment">// Make sure we&#39;re not already setup</span></div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;            <span class="keywordflow">if</span> (isSetup_)</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;            {</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;                <a class="code" href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a>(<span class="stringliteral">&quot;%s (ImplicitGraph): Periodic sample removal cannot be changed once BIT* is setup. &quot;</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;                          <span class="stringliteral">&quot;Continuing to use the previous setting.&quot;</span>,</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;                          nameFunc_().c_str());</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;            }</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;            {</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;                <span class="comment">// Store</span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;                dropSamplesOnPrune_ = dropSamples;</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;            }</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;        }</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;</div><div class="line"><a name="l01418"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aa1f120585a62c192e6b0d2c7a640b1f9"> 1418</a></span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aa1f120585a62c192e6b0d2c7a640b1f9">BITstar::ImplicitGraph::getDropSamplesOnPrune</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;            <span class="keywordflow">return</span> dropSamplesOnPrune_;</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;        }</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;</div><div class="line"><a name="l01423"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a954aee049fbfd2ff3141c4aa20703298"> 1423</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a954aee049fbfd2ff3141c4aa20703298">BITstar::ImplicitGraph::setTrackApproximateSolutions</a>(<span class="keywordtype">bool</span> findApproximate)</div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;        {</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;            <span class="comment">// Is the flag changing?</span></div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;            <span class="keywordflow">if</span> (findApproximate != findApprox_)</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;            {</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;                <span class="comment">// Store the flag</span></div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;                findApprox_ = findApproximate;</div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;                <span class="comment">// Check if we are enabling or disabling approximate solution support</span></div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;                <span class="keywordflow">if</span> (!findApprox_)</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;                {</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;                    <span class="comment">// We&#39;re turning it off, clear the approximate solution variables:</span></div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;                    closestDistToGoal_ = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;                    closestVertexToGoal_.reset();</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;                }</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;                {</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;                    <span class="comment">// We are turning it on, do we have an exact solution?</span></div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;                    <span class="keywordflow">if</span> (!hasExactSolution_)</div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;                    {</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;                        <span class="comment">// We don&#39;t, find our current best approximate solution:</span></div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;                        this-&gt;findVertexClosestToGoal();</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;                    }</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;                    <span class="comment">// No else, exact is better than approximate.</span></div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;                }</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;            }</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;            <span class="comment">// No else, no change.</span></div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;        }</div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;</div><div class="line"><a name="l01452"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aaa2dab97bab8e1004d9a76161aae4928"> 1452</a></span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aaa2dab97bab8e1004d9a76161aae4928">BITstar::ImplicitGraph::getTrackApproximateSolutions</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;            <span class="keywordflow">return</span> findApprox_;</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;        }</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>NN&gt;</div><div class="line"><a name="l01458"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a66efcf1d72216b475c758750ba014e9f"> 1458</a></span>&#160;        <span class="keywordtype">void</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a66efcf1d72216b475c758750ba014e9f">BITstar::ImplicitGraph::setNearestNeighbors</a>()</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;        {</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;            <span class="comment">// Check if the problem is already setup, if so, the NN structs have data in them and you can&#39;t really</span></div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;            <span class="comment">// change them:</span></div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;            <span class="keywordflow">if</span> (isSetup_)</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;            {</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;                <a class="code" href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a>(<span class="stringliteral">&quot;%s (ImplicitGraph): The nearest neighbour datastructures cannot be changed once the problem &quot;</span></div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;                          <span class="stringliteral">&quot;is setup. Continuing to use the existing containers.&quot;</span>,</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;                          nameFunc_().c_str());</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;            }</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;            {</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;                <span class="comment">// The problem isn&#39;t setup yet, create NN structs of the specified type:</span></div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;                freeStateNN_ = std::make_shared&lt;NN&lt;VertexPtr&gt;&gt;();</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;                vertexNN_ = std::make_shared&lt;NN&lt;VertexPtr&gt;&gt;();</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;            }</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;        }</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;</div><div class="line"><a name="l01476"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a53a2478037876c1e13031b74f54185a4"> 1476</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a53a2478037876c1e13031b74f54185a4">BITstar::ImplicitGraph::numFreeSamples</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;            <span class="keywordflow">return</span> freeStateNN_-&gt;size();</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;        }</div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;</div><div class="line"><a name="l01481"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a4f82e678cd1c577e09a7c031e48f7a0f"> 1481</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a4f82e678cd1c577e09a7c031e48f7a0f">BITstar::ImplicitGraph::numConnectedVertices</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;            <span class="keywordflow">return</span> vertexNN_-&gt;size();</div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;        }</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;</div><div class="line"><a name="l01486"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a28aad353d00ac3098ff308da6e956701"> 1486</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a28aad353d00ac3098ff308da6e956701">BITstar::ImplicitGraph::numStatesGenerated</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;            <span class="keywordflow">return</span> numSamples_;</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;        }</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;</div><div class="line"><a name="l01491"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04bc0deec4e02f66ad6ea82b47e4657c"> 1491</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04bc0deec4e02f66ad6ea82b47e4657c">BITstar::ImplicitGraph::numVerticesConnected</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;            <span class="keywordflow">return</span> numVertices_;</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;        }</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;</div><div class="line"><a name="l01496"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac717d91935890eed3ac85ccfb5eab2b1"> 1496</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac717d91935890eed3ac85ccfb5eab2b1">BITstar::ImplicitGraph::numFreeStatesPruned</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;            <span class="keywordflow">return</span> numFreeStatesPruned_;</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;        }</div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;</div><div class="line"><a name="l01501"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8fa35abf18696b5ab809606889be722e"> 1501</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8fa35abf18696b5ab809606889be722e">BITstar::ImplicitGraph::numVerticesDisconnected</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;            <span class="keywordflow">return</span> numVerticesDisconnected_;</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;        }</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;</div><div class="line"><a name="l01506"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8b8cbe24b6b282752f22d4c06108aba1"> 1506</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8b8cbe24b6b282752f22d4c06108aba1">BITstar::ImplicitGraph::numNearestLookups</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;            <span class="keywordflow">return</span> numNearestNeighbours_;</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;        }</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;</div><div class="line"><a name="l01511"></a><span class="lineno"><a class="line" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a4d6bab0dd0192f45f942018c3ab2e7db"> 1511</a></span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a4d6bab0dd0192f45f942018c3ab2e7db">BITstar::ImplicitGraph::numStateCollisionChecks</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;            <span class="keywordflow">return</span> numStateCollisionChecks_;</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;        }</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;    }  <span class="comment">// geometric</span></div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;}  <span class="comment">// ompl</span></div><div class="ttc" id="classompl_1_1base_1_1PlannerData_html"><div class="ttname"><a href="classompl_1_1base_1_1PlannerData.html">ompl::base::PlannerData</a></div><div class="ttdoc">Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...</div><div class="ttdef"><b>Definition:</b> <a href="base_2PlannerData_8h_source.html#l00174">PlannerData.h:174</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ac290acafb390befb2ef1a7bec439f994"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac290acafb390befb2ef1a7bec439f994">ompl::geometric::BITstar::ImplicitGraph::nearestVertices</a></div><div class="ttdeci">void nearestVertices(const VertexPtr &amp;vertex, VertexPtrVector *neighbourVertices)</div><div class="ttdoc">Get the nearest samples from the vertexNN_ using the appropriate &quot;near&quot; definition (i...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00302">ImplicitGraph.cpp:302</a></div></div>
<div class="ttc" id="namespaceompl_1_1msg_html_affe7852f27c06f98af7eb2579f1e5350"><div class="ttname"><a href="namespaceompl_1_1msg.html#affe7852f27c06f98af7eb2579f1e5350">ompl::msg::log</a></div><div class="ttdeci">void log(const char *file, int line, LogLevel level, const char *m,...)</div><div class="ttdoc">Root level logging function. This should not be invoked directly, but rather used via a logging macro...</div><div class="ttdef"><b>Definition:</b> <a href="Console_8cpp_source.html#l00120">Console.cpp:120</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a9255f486a1f99c851fc78b3a6287eb37"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9255f486a1f99c851fc78b3a6287eb37">ompl::geometric::BITstar::ImplicitGraph::setJustInTimeSampling</a></div><div class="ttdeci">void setJustInTimeSampling(bool useJit)</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01372">ImplicitGraph.cpp:1372</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1ProblemDefinitionPtr_html"><div class="ttname"><a href="classompl_1_1base_1_1ProblemDefinitionPtr.html">ompl::base::ProblemDefinitionPtr</a></div><div class="ttdoc">A shared pointer wrapper for ompl::base::ProblemDefinition. </div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a4f82e678cd1c577e09a7c031e48f7a0f"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a4f82e678cd1c577e09a7c031e48f7a0f">ompl::geometric::BITstar::ImplicitGraph::numConnectedVertices</a></div><div class="ttdeci">unsigned int numConnectedVertices() const</div><div class="ttdoc">The number of vertices in the tree (Size of vertexNN_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01481">ImplicitGraph.cpp:1481</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a46074e6a6f225fd1596cf5df29c5c10e"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a46074e6a6f225fd1596cf5df29c5c10e">ompl::geometric::BITstar::ImplicitGraph::hasAGoal</a></div><div class="ttdeci">bool hasAGoal() const</div><div class="ttdoc">Gets whether the graph contains a goal or not. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01242">ImplicitGraph.cpp:1242</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a53f2774eba2cd3a953026726c92b9fc3"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a53f2774eba2cd3a953026726c92b9fc3">ompl::geometric::BITstar::ImplicitGraph::addVertex</a></div><div class="ttdeci">void addVertex(const VertexPtr &amp;newVertex, bool removeFromFree)</div><div class="ttdoc">Add a vertex to the tree, optionally moving it from the set of unconnected samples. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00741">ImplicitGraph.cpp:741</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_aa1f120585a62c192e6b0d2c7a640b1f9"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aa1f120585a62c192e6b0d2c7a640b1f9">ompl::geometric::BITstar::ImplicitGraph::getDropSamplesOnPrune</a></div><div class="ttdeci">bool getDropSamplesOnPrune() const</div><div class="ttdoc">Get whether unconnected samples are dropped on pruning. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01418">ImplicitGraph.cpp:1418</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a04db46665953783eef161ec985d29fe6"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04db46665953783eef161ec985d29fe6">ompl::geometric::BITstar::ImplicitGraph::addSample</a></div><div class="ttdeci">void addSample(const VertexPtr &amp;newSample)</div><div class="ttdoc">Add an unconnected sample. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00707">ImplicitGraph.cpp:707</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerInputStates_html_ae8ea1c2fd3e0e92dbc289a79dd597c98"><div class="ttname"><a href="classompl_1_1base_1_1PlannerInputStates.html#ae8ea1c2fd3e0e92dbc289a79dd597c98">ompl::base::PlannerInputStates::nextGoal</a></div><div class="ttdeci">const State * nextGoal(const PlannerTerminationCondition &amp;ptc)</div><div class="ttdoc">Return the next valid goal state or nullptr if no more valid goal states are available. Because sampling of goal states may also produce invalid goals, this function takes an argument that specifies whether a termination condition has been reached. If the termination condition evaluates to true the function terminates even if no valid goal has been found. </div><div class="ttdef"><b>Definition:</b> <a href="Planner_8cpp_source.html#l00264">Planner.cpp:264</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ac52b0587ca4de60f74428ac658ed02b3"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac52b0587ca4de60f74428ac658ed02b3">ompl::geometric::BITstar::ImplicitGraph::prune</a></div><div class="ttdeci">std::pair&lt; unsigned int, unsigned int &gt; prune(double prunedMeasure)</div><div class="ttdoc">Prune the samples to the subproblem of the given measure. Pruning is performed by using the prune con...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00681">ImplicitGraph.cpp:681</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a04bc0deec4e02f66ad6ea82b47e4657c"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a04bc0deec4e02f66ad6ea82b47e4657c">ompl::geometric::BITstar::ImplicitGraph::numVerticesConnected</a></div><div class="ttdeci">unsigned int numVerticesConnected() const</div><div class="ttdoc">The total number of vertices added to the graph (numVertices_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01491">ImplicitGraph.cpp:1491</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerTerminationCondition_html"><div class="ttname"><a href="classompl_1_1base_1_1PlannerTerminationCondition.html">ompl::base::PlannerTerminationCondition</a></div><div class="ttdoc">Encapsulate a termination condition for a motion planner. Planners will call operator() to decide whe...</div><div class="ttdef"><b>Definition:</b> <a href="PlannerTerminationCondition_8h_source.html#l00063">PlannerTerminationCondition.h:63</a></div></div>
<div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace. </div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerData_html_ac61c5ab5cfd6a66a58e03b1731c1e454"><div class="ttname"><a href="classompl_1_1base_1_1PlannerData.html#ac61c5ab5cfd6a66a58e03b1731c1e454">ompl::base::PlannerData::addVertex</a></div><div class="ttdeci">unsigned int addVertex(const PlannerDataVertex &amp;st)</div><div class="ttdoc">Adds the given vertex to the graph data. The vertex index is returned. Duplicates are not added...</div><div class="ttdef"><b>Definition:</b> <a href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00391">PlannerData.cpp:391</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a53a2478037876c1e13031b74f54185a4"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a53a2478037876c1e13031b74f54185a4">ompl::geometric::BITstar::ImplicitGraph::numFreeSamples</a></div><div class="ttdeci">unsigned int numFreeSamples() const</div><div class="ttdoc">The number of free samples (size of freeStateNN_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01476">ImplicitGraph.cpp:1476</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a773c3c291205b290893f0e5ca9e21d54"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a773c3c291205b290893f0e5ca9e21d54">ompl::geometric::BITstar::ImplicitGraph::getGraphAsPlannerData</a></div><div class="ttdeci">void getGraphAsPlannerData(ompl::base::PlannerData &amp;data) const</div><div class="ttdoc">Adds the graph to the given PlannerData struct. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00319">ImplicitGraph.cpp:319</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a28aad353d00ac3098ff308da6e956701"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a28aad353d00ac3098ff308da6e956701">ompl::geometric::BITstar::ImplicitGraph::numStatesGenerated</a></div><div class="ttdeci">unsigned int numStatesGenerated() const</div><div class="ttdoc">The total number of states generated (numSamples_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01486">ImplicitGraph.cpp:1486</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a44e05d68d7c67f33b55b9b3a30024508"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a44e05d68d7c67f33b55b9b3a30024508">ompl::geometric::BITstar::ImplicitGraph::startVerticesBeginConst</a></div><div class="ttdeci">VertexPtrVector::const_iterator startVerticesBeginConst() const</div><div class="ttdoc">Returns a const-iterator to the front of the start-vertex vector. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01247">ImplicitGraph.cpp:1247</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a131fbf7c6940f668b1b90269048dc5e9"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a131fbf7c6940f668b1b90269048dc5e9">ompl::geometric::BITstar::ImplicitGraph::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Clear the graph to the state of construction. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00188">ImplicitGraph.cpp:188</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerInputStates_html_a3af0f27cc94711e6055d0221aa4f9c42"><div class="ttname"><a href="classompl_1_1base_1_1PlannerInputStates.html#a3af0f27cc94711e6055d0221aa4f9c42">ompl::base::PlannerInputStates::haveMoreStartStates</a></div><div class="ttdeci">bool haveMoreStartStates() const</div><div class="ttdoc">Check if there are more potential start states. </div><div class="ttdef"><b>Definition:</b> <a href="Planner_8cpp_source.html#l00335">Planner.cpp:335</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ae0300a64779d063a3db9c1752a1145f8"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae0300a64779d063a3db9c1752a1145f8">ompl::geometric::BITstar::ImplicitGraph::ImplicitGraph</a></div><div class="ttdeci">ImplicitGraph(NameFunc nameFunc)</div><div class="ttdoc">Construct an implicit graph. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00076">ImplicitGraph.cpp:76</a></div></div>
<div class="ttc" id="namespaceompl_html_ac07d992fd77292786e9cdc9a0cadaeb0"><div class="ttname"><a href="namespaceompl.html#ac07d992fd77292786e9cdc9a0cadaeb0">ompl::unitNBallMeasure</a></div><div class="ttdeci">double unitNBallMeasure(unsigned int N)</div><div class="ttdoc">The Lebesgue measure (i.e., &quot;volume&quot;) of an n-dimensional ball with a unit radius. </div><div class="ttdef"><b>Definition:</b> <a href="GeometricEquations_8cpp_source.html#l00055">GeometricEquations.cpp:55</a></div></div>
<div class="ttc" id="namespaceompl_1_1base_html_a1125deb13109d3f27b3acab34d79c09c"><div class="ttname"><a href="namespaceompl_1_1base.html#a1125deb13109d3f27b3acab34d79c09c">ompl::base::plannerAlwaysTerminatingCondition</a></div><div class="ttdeci">PlannerTerminationCondition plannerAlwaysTerminatingCondition()</div><div class="ttdoc">Simple termination condition that always returns true. The termination condition will always be met...</div><div class="ttdef"><b>Definition:</b> <a href="PlannerTerminationCondition_8cpp_source.html#l00189">PlannerTerminationCondition.cpp:189</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a8fa35abf18696b5ab809606889be722e"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8fa35abf18696b5ab809606889be722e">ompl::geometric::BITstar::ImplicitGraph::numVerticesDisconnected</a></div><div class="ttdeci">unsigned int numVerticesDisconnected() const</div><div class="ttdoc">The number of tree vertices disconnected (numVerticesDisconnected_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01501">ImplicitGraph.cpp:1501</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a8bae302cadff1eec3c7f01316e413359"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8bae302cadff1eec3c7f01316e413359">ompl::geometric::BITstar::ImplicitGraph::setRewireFactor</a></div><div class="ttdeci">void setRewireFactor(double rewireFactor)</div><div class="ttdoc">Set the rewiring scale factor, s, such that r_rrg = s  r_rrg*. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01326">ImplicitGraph.cpp:1326</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_html_ae2c8c06f2c54b1bf182dc62dce515ff0"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">ompl::geometric::BITstar::VertexConstPtr</a></div><div class="ttdeci">std::shared_ptr&lt; const Vertex &gt; VertexConstPtr</div><div class="ttdoc">A constant vertex shared pointer. </div><div class="ttdef"><b>Definition:</b> <a href="BITstar_8h_source.html#l00126">BITstar.h:126</a></div></div>
<div class="ttc" id="classompl_1_1RNG_html_af9450941c808fc53f30173c364bbfd25"><div class="ttname"><a href="classompl_1_1RNG.html#af9450941c808fc53f30173c364bbfd25">ompl::RNG::uniform01</a></div><div class="ttdeci">double uniform01()</div><div class="ttdoc">Generate a random real between 0 and 1. </div><div class="ttdef"><b>Definition:</b> <a href="RandomNumbers_8h_source.html#l00068">RandomNumbers.h:68</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ad843e38fb5eaf877f8a93dba8af3dd50"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ad843e38fb5eaf877f8a93dba8af3dd50">ompl::geometric::BITstar::ImplicitGraph::getRewireFactor</a></div><div class="ttdeci">double getRewireFactor() const</div><div class="ttdoc">Get the rewiring scale factor. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01339">ImplicitGraph.cpp:1339</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerDataVertex_html"><div class="ttname"><a href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a></div><div class="ttdoc">Base class for a vertex in the PlannerData structure. All derived classes must implement the clone an...</div><div class="ttdef"><b>Definition:</b> <a href="base_2PlannerData_8h_source.html#l00058">PlannerData.h:58</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_html_a5a3eb7712e427445aecf215e4e7f95fa"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar.html#a5a3eb7712e427445aecf215e4e7f95fa">ompl::geometric::BITstar::SearchQueuePtr</a></div><div class="ttdeci">std::shared_ptr&lt; SearchQueue &gt; SearchQueuePtr</div><div class="ttdoc">An search queue shared pointer. </div><div class="ttdef"><b>Definition:</b> <a href="BITstar_8h_source.html#l00150">BITstar.h:150</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ae274427299a7fb5b40d3633adb8c3f0f"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ae274427299a7fb5b40d3633adb8c3f0f">ompl::geometric::BITstar::ImplicitGraph::updateStartAndGoalStates</a></div><div class="ttdeci">void updateStartAndGoalStates(ompl::base::PlannerInputStates &amp;pis, const base::PlannerTerminationCondition &amp;ptc)</div><div class="ttdoc">Adds any new goals or starts that have appeared in the problem definition to the vector of vertices a...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00390">ImplicitGraph.cpp:390</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a656c1b485fd0f5a73f51ff92e745d7be"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a656c1b485fd0f5a73f51ff92e745d7be">ompl::geometric::BITstar::ImplicitGraph::smallestDistanceToGoal</a></div><div class="ttdeci">double smallestDistanceToGoal() const</div><div class="ttdoc">IF BEING TRACKED, returns the how close vertices in the tree are to the goal. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01293">ImplicitGraph.cpp:1293</a></div></div>
<div class="ttc" id="namespaceompl_html"><div class="ttname"><a href="namespaceompl.html">ompl</a></div><div class="ttdoc">Main namespace. Contains everything in this library. </div><div class="ttdef"><b>Definition:</b> <a href="Cost_8h_source.html#l00042">Cost.h:42</a></div></div>
<div class="ttc" id="classompl_1_1RNG_html"><div class="ttname"><a href="classompl_1_1RNG.html">ompl::RNG</a></div><div class="ttdoc">Random number generation. An instance of this class cannot be used by multiple threads at once (membe...</div><div class="ttdef"><b>Definition:</b> <a href="RandomNumbers_8h_source.html#l00058">RandomNumbers.h:58</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a56b776b8e0d8172917d63f8987052b28"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a56b776b8e0d8172917d63f8987052b28">ompl::geometric::BITstar::ImplicitGraph::getJustInTimeSampling</a></div><div class="ttdeci">bool getJustInTimeSampling() const</div><div class="ttdoc">Get whether we&amp;#39;re using just-in-time sampling. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01397">ImplicitGraph.cpp:1397</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_aae3192ccb278d9e5b86f790c708f0ec5"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aae3192ccb278d9e5b86f790c708f0ec5">ompl::geometric::BITstar::ImplicitGraph::startVerticesEndConst</a></div><div class="ttdeci">VertexPtrVector::const_iterator startVerticesEndConst() const</div><div class="ttdoc">Returns a const-iterator to the end of the start-vertex vector. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01252">ImplicitGraph.cpp:1252</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a36c15f7c61fff5e091f0259925ea7d2c"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a36c15f7c61fff5e091f0259925ea7d2c">ompl::geometric::BITstar::ImplicitGraph::getConnectivityK</a></div><div class="ttdeci">unsigned int getConnectivityK() const</div><div class="ttdoc">Get the k of this k-nearest RGG. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01304">ImplicitGraph.cpp:1304</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a9e9ac3d6a6ae20cf086f2539e6b41a44"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a9e9ac3d6a6ae20cf086f2539e6b41a44">ompl::geometric::BITstar::ImplicitGraph::removeVertex</a></div><div class="ttdeci">unsigned int removeVertex(const VertexPtr &amp;oldSample, bool moveToFree)</div><div class="ttdoc">Remove a vertex from the tree, can optionally be allowed to move it to the set of unconnected samples...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00774">ImplicitGraph.cpp:774</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a63d6bb1d8f59740872e0fb1a1124ace5"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a63d6bb1d8f59740872e0fb1a1124ace5">ompl::geometric::BITstar::ImplicitGraph::setup</a></div><div class="ttdeci">void setup(const ompl::base::SpaceInformationPtr &amp;si, const ompl::base::ProblemDefinitionPtr &amp;pdef, const CostHelperPtr &amp;costHelper, const SearchQueuePtr &amp;searchQueue, const ompl::base::Planner *plannerPtr, ompl::base::PlannerInputStates &amp;pis)</div><div class="ttdoc">Setup the ImplicitGraph, must be called before use. Does not take a copy of the PlannerInputStates, but checks it for starts/goals. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00081">ImplicitGraph.cpp:81</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1Planner_html"><div class="ttname"><a href="classompl_1_1base_1_1Planner.html">ompl::base::Planner</a></div><div class="ttdoc">Base class for a planner. </div><div class="ttdef"><b>Definition:</b> <a href="Planner_8h_source.html#l00223">Planner.h:223</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a20da13a2f166cc1c0662e0e05084dda9"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a20da13a2f166cc1c0662e0e05084dda9">ompl::geometric::BITstar::ImplicitGraph::nearestSamples</a></div><div class="ttdeci">void nearestSamples(const VertexPtr &amp;vertex, VertexPtrVector *neighbourSamples)</div><div class="ttdoc">Get the nearest unconnected samples using the appropriate &quot;near&quot; definition (i.e., k or r). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00282">ImplicitGraph.cpp:282</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerData_html_ac09c21494a8c7db500ef1a66bbbb1aa7"><div class="ttname"><a href="classompl_1_1base_1_1PlannerData.html#ac09c21494a8c7db500ef1a66bbbb1aa7">ompl::base::PlannerData::addEdge</a></div><div class="ttdeci">virtual bool addEdge(unsigned int v1, unsigned int v2, const PlannerDataEdge &amp;edge=PlannerDataEdge(), Cost weight=Cost(1.0))</div><div class="ttdoc">Adds a directed edge between the given vertex indexes. An optional edge structure and weight can be s...</div><div class="ttdef"><b>Definition:</b> <a href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00432">PlannerData.cpp:432</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1SpaceInformationPtr_html"><div class="ttname"><a href="classompl_1_1base_1_1SpaceInformationPtr.html">ompl::base::SpaceInformationPtr</a></div><div class="ttdoc">A shared pointer wrapper for ompl::base::SpaceInformation. </div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a37f48910d8abfcf844aadf25a0399b5a"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a37f48910d8abfcf844aadf25a0399b5a">ompl::geometric::BITstar::ImplicitGraph::hasInformedMeasure</a></div><div class="ttdeci">bool hasInformedMeasure() const</div><div class="ttdoc">Query whether the underlying state sampler can provide an informed measure. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01272">ImplicitGraph.cpp:1272</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_aada296d39c8722d30ad4fa308a318b93"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aada296d39c8722d30ad4fa308a318b93">ompl::geometric::BITstar::ImplicitGraph::removeSample</a></div><div class="ttdeci">void removeSample(const VertexPtr &amp;oldSample)</div><div class="ttdoc">Remove an unconnected sample. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00723">ImplicitGraph.cpp:723</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerData_html_a2eea84456784452486aa0065af391f47"><div class="ttname"><a href="classompl_1_1base_1_1PlannerData.html#a2eea84456784452486aa0065af391f47">ompl::base::PlannerData::addStartVertex</a></div><div class="ttdeci">unsigned int addStartVertex(const PlannerDataVertex &amp;v)</div><div class="ttdoc">Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned...</div><div class="ttdef"><b>Definition:</b> <a href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00413">PlannerData.cpp:413</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1State_html"><div class="ttname"><a href="classompl_1_1base_1_1State.html">ompl::base::State</a></div><div class="ttdoc">Definition of an abstract state. </div><div class="ttdef"><b>Definition:</b> <a href="State_8h_source.html#l00049">State.h:49</a></div></div>
<div class="ttc" id="group__logging_html_gab76357dced39cb468d2061d3358f80a6"><div class="ttname"><a href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a></div><div class="ttdeci">#define OMPL_WARN(fmt,...)</div><div class="ttdoc">Log a formatted warning string. </div><div class="ttdef"><b>Definition:</b> <a href="Console_8h_source.html#l00066">Console.h:66</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ac97c8060b25fc19cac38107ae13d6e33"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac97c8060b25fc19cac38107ae13d6e33">ompl::geometric::BITstar::ImplicitGraph::hasSolution</a></div><div class="ttdeci">void hasSolution(const ompl::base::Cost &amp;solnCost)</div><div class="ttdoc">Mark that a solution has been found and that the graph should be limited to the given heuristic value...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00375">ImplicitGraph.cpp:375</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerInputStates_html_a42a3a7bdbbe09caf937e57785ee97d51"><div class="ttname"><a href="classompl_1_1base_1_1PlannerInputStates.html#a42a3a7bdbbe09caf937e57785ee97d51">ompl::base::PlannerInputStates::nextStart</a></div><div class="ttdeci">const State * nextStart()</div><div class="ttdoc">Return the next valid start state or nullptr if no more valid start states are available. </div><div class="ttdef"><b>Definition:</b> <a href="Planner_8cpp_source.html#l00227">Planner.cpp:227</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a0b7c5f309bccfc1ca452cd65feb781b1"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a0b7c5f309bccfc1ca452cd65feb781b1">ompl::geometric::BITstar::ImplicitGraph::addNewSamples</a></div><div class="ttdeci">void addNewSamples(const unsigned int &amp;numSamples)</div><div class="ttdoc">Increase the resolution of the graph-based approximation of the continuous search domain by adding a ...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00642">ImplicitGraph.cpp:642</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ac717d91935890eed3ac85ccfb5eab2b1"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ac717d91935890eed3ac85ccfb5eab2b1">ompl::geometric::BITstar::ImplicitGraph::numFreeStatesPruned</a></div><div class="ttdeci">unsigned int numFreeStatesPruned() const</div><div class="ttdoc">The number of states pruned (numFreeStatesPruned_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01496">ImplicitGraph.cpp:1496</a></div></div>
<div class="ttc" id="classompl_1_1Exception_html"><div class="ttname"><a href="classompl_1_1Exception.html">ompl::Exception</a></div><div class="ttdoc">The exception type for ompl. </div><div class="ttdef"><b>Definition:</b> <a href="Exception_8h_source.html#l00046">Exception.h:46</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_html_a1972ba4a3a68f77ffa2c3319a69dce49"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar.html#a1972ba4a3a68f77ffa2c3319a69dce49">ompl::geometric::BITstar::NameFunc</a></div><div class="ttdeci">std::function&lt; std::string()&gt; NameFunc</div><div class="ttdoc">A utility functor for ImplicitGraph and SearchQueue. </div><div class="ttdef"><b>Definition:</b> <a href="BITstar_8h_source.html#l00153">BITstar.h:153</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a3921b2e4eb248ba63e8deb2fe880b6de"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a3921b2e4eb248ba63e8deb2fe880b6de">ompl::geometric::BITstar::ImplicitGraph::closestVertexToGoal</a></div><div class="ttdeci">VertexConstPtr closestVertexToGoal() const</div><div class="ttdoc">IF BEING TRACKED, returns the closest vertex in the tree to the goal. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01282">ImplicitGraph.cpp:1282</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a83be6b9a2d27eefc72bcc3b83ae6d75f"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a83be6b9a2d27eefc72bcc3b83ae6d75f">ompl::geometric::BITstar::ImplicitGraph::minCost</a></div><div class="ttdeci">ompl::base::Cost minCost() const</div><div class="ttdoc">Get the minimum cost solution possible for this problem. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01267">ImplicitGraph.cpp:1267</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_html_a1330c5b8a068a54fccf22b51ac105a2f"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar.html#a1330c5b8a068a54fccf22b51ac105a2f">ompl::geometric::BITstar::VertexPtrVector</a></div><div class="ttdeci">std::vector&lt; VertexPtr &gt; VertexPtrVector</div><div class="ttdoc">A vector of shared pointers. </div><div class="ttdef"><b>Definition:</b> <a href="BITstar_8h_source.html#l00130">BITstar.h:130</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a212630ab596b0b376c8e58b7b09b52f5"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a212630ab596b0b376c8e58b7b09b52f5">ompl::geometric::BITstar::ImplicitGraph::getInformedMeasure</a></div><div class="ttdeci">double getInformedMeasure(const ompl::base::Cost &amp;cost) const</div><div class="ttdoc">Query the underlying state sampler for the informed measure of the problem. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01277">ImplicitGraph.cpp:1277</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerInputStates_html_adfcf64da095fd8953611e739ac40af99"><div class="ttname"><a href="classompl_1_1base_1_1PlannerInputStates.html#adfcf64da095fd8953611e739ac40af99">ompl::base::PlannerInputStates::haveMoreGoalStates</a></div><div class="ttdeci">bool haveMoreGoalStates() const</div><div class="ttdoc">Check if there are more potential goal states. </div><div class="ttdef"><b>Definition:</b> <a href="Planner_8cpp_source.html#l00342">Planner.cpp:342</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a8b8cbe24b6b282752f22d4c06108aba1"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a8b8cbe24b6b282752f22d4c06108aba1">ompl::geometric::BITstar::ImplicitGraph::numNearestLookups</a></div><div class="ttdeci">unsigned int numNearestLookups() const</div><div class="ttdoc">The number of nearest neighbour calls (numNearestNeighbours_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01506">ImplicitGraph.cpp:1506</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a954aee049fbfd2ff3141c4aa20703298"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a954aee049fbfd2ff3141c4aa20703298">ompl::geometric::BITstar::ImplicitGraph::setTrackApproximateSolutions</a></div><div class="ttdeci">void setTrackApproximateSolutions(bool findApproximate)</div><div class="ttdoc">Set whether to track approximate solutions during the search. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01423">ImplicitGraph.cpp:1423</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a768bff7a91e6b6249ae86a400e9d3bf6"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a768bff7a91e6b6249ae86a400e9d3bf6">ompl::geometric::BITstar::ImplicitGraph::getUseKNearest</a></div><div class="ttdeci">bool getUseKNearest() const</div><div class="ttdoc">Get whether a k-nearest search is being used. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01367">ImplicitGraph.cpp:1367</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_af7704a9619a5b464c88baf2549494879"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#af7704a9619a5b464c88baf2549494879">ompl::geometric::BITstar::ImplicitGraph::setDropSamplesOnPrune</a></div><div class="ttdeci">void setDropSamplesOnPrune(bool dropSamples)</div><div class="ttdoc">Set whether unconnected samples are dropped on pruning. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01402">ImplicitGraph.cpp:1402</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_aa60d9cc83616fbefa8888b625015821e"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aa60d9cc83616fbefa8888b625015821e">ompl::geometric::BITstar::ImplicitGraph::goalVerticesBeginConst</a></div><div class="ttdeci">VertexPtrVector::const_iterator goalVerticesBeginConst() const</div><div class="ttdoc">Returns a const-iterator to the front of the goal-vertex vector. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01257">ImplicitGraph.cpp:1257</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1PlannerInputStates_html"><div class="ttname"><a href="classompl_1_1base_1_1PlannerInputStates.html">ompl::base::PlannerInputStates</a></div><div class="ttdoc">Helper class to extract valid start &amp; goal states. Usually used internally by planners. </div><div class="ttdef"><b>Definition:</b> <a href="Planner_8h_source.html#l00078">Planner.h:78</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a818cc69141d235fafba96f739bcba011"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a818cc69141d235fafba96f739bcba011">ompl::geometric::BITstar::ImplicitGraph::distanceFunction</a></div><div class="ttdeci">double distanceFunction(const VertexConstPtr &amp;a, const VertexConstPtr &amp;b) const</div><div class="ttdoc">The distance function. Calculates the distance directionally from the given state to all the other st...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l00261">ImplicitGraph.cpp:261</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a66efcf1d72216b475c758750ba014e9f"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a66efcf1d72216b475c758750ba014e9f">ompl::geometric::BITstar::ImplicitGraph::setNearestNeighbors</a></div><div class="ttdeci">void setNearestNeighbors()</div><div class="ttdoc">Set a different nearest neighbours datastructure. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01458">ImplicitGraph.cpp:1458</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_ad16e8dfd69bd7c55287b8ac26e4a7cf9"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#ad16e8dfd69bd7c55287b8ac26e4a7cf9">ompl::geometric::BITstar::ImplicitGraph::setUseKNearest</a></div><div class="ttdeci">void setUseKNearest(bool useKNearest)</div><div class="ttdoc">Enable a k-nearest search for instead of an r-disc search. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01344">ImplicitGraph.cpp:1344</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_html_a7f00cb9addc9d74b7189aec381f038fa"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar.html#a7f00cb9addc9d74b7189aec381f038fa">ompl::geometric::BITstar::CostHelperPtr</a></div><div class="ttdeci">std::shared_ptr&lt; CostHelper &gt; CostHelperPtr</div><div class="ttdoc">A cost helper shared pointer. </div><div class="ttdef"><b>Definition:</b> <a href="BITstar_8h_source.html#l00146">BITstar.h:146</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_af0876737708c6003e5c9587c3d6116f9"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#af0876737708c6003e5c9587c3d6116f9">ompl::geometric::BITstar::ImplicitGraph::goalVerticesEndConst</a></div><div class="ttdeci">VertexPtrVector::const_iterator goalVerticesEndConst() const</div><div class="ttdoc">Returns a const-iterator to the end of the goal-vertex vector. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01262">ImplicitGraph.cpp:1262</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_aaa2dab97bab8e1004d9a76161aae4928"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#aaa2dab97bab8e1004d9a76161aae4928">ompl::geometric::BITstar::ImplicitGraph::getTrackApproximateSolutions</a></div><div class="ttdeci">bool getTrackApproximateSolutions() const</div><div class="ttdoc">Get whether approximate solutions are tracked during the search. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01452">ImplicitGraph.cpp:1452</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a58dda8d6fbf02bbe2f884a4c78fa4f28"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a58dda8d6fbf02bbe2f884a4c78fa4f28">ompl::geometric::BITstar::ImplicitGraph::getConnectivityR</a></div><div class="ttdeci">double getConnectivityR() const</div><div class="ttdoc">Get the radius of this r-disc RGG. </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01315">ImplicitGraph.cpp:1315</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_html_adff43a966e7cba88d21a4927602703fa"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">ompl::geometric::BITstar::VertexPtr</a></div><div class="ttdeci">std::shared_ptr&lt; Vertex &gt; VertexPtr</div><div class="ttdoc">A vertex shared pointer. </div><div class="ttdef"><b>Definition:</b> <a href="BITstar_8h_source.html#l00121">BITstar.h:121</a></div></div>
<div class="ttc" id="classompl_1_1NearestNeighbors_html_a69692a816af54715de7afdf0ff15141c"><div class="ttname"><a href="classompl_1_1NearestNeighbors.html#a69692a816af54715de7afdf0ff15141c">ompl::NearestNeighbors::DistanceFunction</a></div><div class="ttdeci">std::function&lt; double(const _T &amp;, const _T &amp;)&gt; DistanceFunction</div><div class="ttdoc">The definition of a distance function. </div><div class="ttdef"><b>Definition:</b> <a href="NearestNeighbors_8h_source.html#l00052">NearestNeighbors.h:52</a></div></div>
<div class="ttc" id="classompl_1_1base_1_1Cost_html"><div class="ttname"><a href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a></div><div class="ttdoc">Definition of a cost value. Can represent the cost of a motion or the cost of a state. </div><div class="ttdef"><b>Definition:</b> <a href="Cost_8h_source.html#l00047">Cost.h:47</a></div></div>
<div class="ttc" id="Console_8h_html"><div class="ttname"><a href="Console_8h.html">Console.h</a></div></div>
<div class="ttc" id="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph_html_a4d6bab0dd0192f45f942018c3ab2e7db"><div class="ttname"><a href="classompl_1_1geometric_1_1BITstar_1_1ImplicitGraph.html#a4d6bab0dd0192f45f942018c3ab2e7db">ompl::geometric::BITstar::ImplicitGraph::numStateCollisionChecks</a></div><div class="ttdeci">unsigned int numStateCollisionChecks() const</div><div class="ttdoc">The number of state collision checks (numStateCollisionChecks_). </div><div class="ttdef"><b>Definition:</b> <a href="ImplicitGraph_8cpp_source.html#l01511">ImplicitGraph.cpp:1511</a></div></div>
<div class="ttc" id="group__logging_html_ga04bc36d1b8c57ad7e13a8a48451a3a05"><div class="ttname"><a href="group__logging.html#ga04bc36d1b8c57ad7e13a8a48451a3a05">OMPL_INFORM</a></div><div class="ttdeci">#define OMPL_INFORM(fmt,...)</div><div class="ttdoc">Log a formatted information string. </div><div class="ttdef"><b>Definition:</b> <a href="Console_8h_source.html#l00068">Console.h:68</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.13</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="js/jquery.js"></script>
<script src="js/jquery.powertip.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/dynsections.js"></script>
<script src="js/ompl.js"></script>
</body>
</html>
