<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl/doc/markdown/optimalPlanningTutorial.md Source File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.8.14"/>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-powertip/1.2.0/jquery.powertip.min.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="constrainedPlanning.html">Constrained Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
                  <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ompl/doc/markdown/optimalPlanningTutorial.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Optimal Planning Tutorial {#optimalPlanningTutorial}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Defining an optimal motion planning problem is almost exactly the same as defining a regular motion planning problem, with two main differences:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;1. You need to specify an optimization objective to `ompl::base::ProblemDefinition`.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;2. You need to use an optimizing planner for the actual motion planning.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;## Finding the shortest path</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;We&#39;ll demonstrate OMPL&#39;s optimal planning framework with an example. In this example, our robot is represented as a (x,y) coordinate on a square, where (0,0) is the square&#39;s bottom-left corner and (1,1) is the square&#39;s top-right corner. There is also an obstacle in this square that the robot cannot pass through; this obstacle is a circle of radius 0.25 centered at (0.5,0.5). To reflect this environment, we use a two-dimensional `ompl::base::RealVectorStateSpace` and define our state validity checker as follows:</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// Our collision checker. For this demo, our robot&#39;s state space</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// lies in [0,1]x[0,1], with a circular obstacle of radius 0.25</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// centered at (0.5,0.5). Any states lying in this circular region are</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;// considered &quot;in collision&quot;.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;class ValidityChecker : public ob::StateValidityChecker</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;{</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;public:</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    ValidityChecker(const ob::SpaceInformationPtr&amp; si) :</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        ob::StateValidityChecker(si) {}</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    // Returns whether the given state&#39;s position overlaps the</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    // circular obstacle</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    bool isValid(const ob::State* state) const</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    {</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        return this-&gt;clearance(state) &gt; 0.0;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    }</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    // Returns the distance from the given state&#39;s position to the</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    // boundary of the circular obstacle.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    double clearance(const ob::State* state) const</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        // We know we&#39;re working with a RealVectorStateSpace in this</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        // example, so we downcast state into the specific type.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        const ob::RealVectorStateSpace::StateType* state2D =</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;            state-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;();</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        // Extract the robot&#39;s (x,y) position from its state</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        double x = state2D-&gt;values[0];</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        double y = state2D-&gt;values[1];</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        // Distance formula between two points, offset by the circle&#39;s</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        // radius</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        return sqrt((x-0.5)*(x-0.5) + (y-0.5)*(y-0.5)) - 0.25;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    }</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;};</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;~~~</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;In our planning code, we then define our state space, its bounds, and our start and goal states. In this example, the start state is at (0,0) and our goal state is (1,1) - i.e. the bottom-left and top-right corners, respectively. This code should be familiar if you&#39;ve worked with regular motion planning in OMPL.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;// Construct the robot state space in which we&#39;re planning. We&#39;re</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;// planning in [0,1]x[0,1], a subset of R^2.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;ob::StateSpacePtr space(new ob::RealVectorStateSpace(2));</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;// Set the bounds of space to be in [0,1].</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;space-&gt;as&lt;ob::RealVectorStateSpace&gt;()-&gt;setBounds(0.0, 1.0);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;// Construct a space information instance for this state space</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;ob::SpaceInformationPtr si(new ob::SpaceInformation(space));</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;// Set the object used to check which states in the space are valid</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;si-&gt;setStateValidityChecker(ob::StateValidityCheckerPtr(new ValidityChecker(si)));</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;si-&gt;setup();</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;// Set our robot&#39;s starting state to be the bottom-left corner of</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;// the environment, or (0,0).</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;ob::ScopedState&lt;&gt; start(space);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;start-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;()-&gt;values[0] = 0.0;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;start-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;()-&gt;values[1] = 0.0;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;// Set our robot&#39;s goal state to be the top-right corner of the</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;// environment, or (1,1).</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;ob::ScopedState&lt;&gt; goal(space);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;goal-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;()-&gt;values[0] = 1.0;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;goal-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;()-&gt;values[1] = 1.0;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;// Create a problem instance</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;ob::ProblemDefinitionPtr pdef(new ob::ProblemDefinition(si));</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;// Set the start and goal states</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;pdef-&gt;setStartAndGoalStates(start, goal);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;~~~</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;Next, we want to define an `ompl::base::OptimizationObjective` for optimal planning. For now, we can specify an objective that corresponds to finding the shortest path between the start and goal states. We&#39;ll define another function that returns this particular objective:</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;// Returns a structure representing the optimization objective to use</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;// for optimal motion planning. This method returns an objective which</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;// attempts to minimize the length in configuration space of computed</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;// paths.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;ob::OptimizationObjectivePtr getPathLengthObjective(const ob::SpaceInformationPtr&amp; si)</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;{</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    return ob::OptimizationObjectivePtr(new ob::PathLengthOptimizationObjective(si));</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;}</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;~~~</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;We can then set this as our objective in our planning code:</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;pdef-&gt;setOptimizationObjective(getPathLengthObjective(si));</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;~~~</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;&gt; Note: The optimizing planner we&#39;re about to use, `ompl::geometric::RRTstar`, actually defaults to optimizing for path length if no optimization objective is specified to the `ompl::base::ProblemDefinition`. This means that, in this case, the above statement isn&#39;t required. But if you want to optimize a metric other than path length, you have to manually specify it to the `ompl::base::ProblemDefinition`.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;Next, we define our optimizing planner and attempt to solve the optimal planning problem:</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;// Construct our optimizing planner using the RRTstar algorithm.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;ob::PlannerPtr optimizingPlanner(new og::RRTstar(si));</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;// Set the problem instance for our planner to solve</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;optimizingPlanner-&gt;setProblemDefinition(pdef);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;optimizingPlanner-&gt;setup();</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;// attempt to solve the planning problem within one second of</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;// planning time</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;ob::PlannerStatus solved = optimizingPlanner-&gt;solve(1.0);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;~~~</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;Here&#39;s an animation demonstrating the progress of the RRTstar planner on the problem we just defined:</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;&lt;div class=&quot;row&quot;&gt;&lt;img src=&quot;images/path-length.gif&quot; class=&quot;col-xs-10 col-xs-offset-1&quot;&gt;&lt;/div&gt;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;Note that when attempting to solve the planning problem, we specify a time limit of 1 second. In regular motion planning, the planner will stop as soon as a path between the start and goal states has been found - this can take far less than 1 second of planning. However, if you execute this example you&#39;ll notice that the planner always takes the full planning time of 1 second. This is because optimizing planners have a stricter stopping requirement than regular planners. Regular planners stop when they&#39;ve found a path from start to goal; on the other hand, optimizing planners stop when they&#39;ve found a path from start to goal that _satisfies the optimization objective_.</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;## Specifying an optimality threshold</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;What does satisfying an optimization objective mean? This behaviour can be customized, but by default, it means finding a path that passes some quality threshold. For shortest path planning, it means finding a path that is shorter than some given length. You&#39;ll notice we never specified this threshold; the default behaviour for `ompl::base::PathLengthOptimizationObjective` is to set the threshold to 0.0 if a threshold wasn&#39;t specified. This means that the objective is only satisfied by paths of length less than 0.0, which means this objective will never be satisfied! Our reasoning for doing this is that, if you don&#39;t specify a threshold, we assume that you want the planner to return the best possible path it can find in the time limit. Therefore, setting a threshold of 0.0 means that the objective will never be satisfied, and guarantee that the planner runs all the way until the specified time limit and returns the best path it could find.</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;We can create an `OptimizationObjective` with a quality threshold of 1.51 by using the `setCostThreshold` method:</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;~~~{.cpp}</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;ob::OptimizationObjectivePtr getThresholdPathLengthObj(const ob::SpaceInformationPtr&amp; si)</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;{</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    ob::OptimizationObjectivePtr obj(new ob::PathLengthOptimizationObjective(si));</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    obj-&gt;setCostThreshold(ob::Cost(1.51));</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    return obj;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;}</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;~~~</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;If you set this as the objective for the `ompl::base::ProblemDefinition` you&#39;ll find that the planner will terminate far more quickly, since it stops planning as soon as it has found a path shorter than the given threshold. Note that when calling `ompl::base::OptimizationObjective::setCostThreshold`, we wrap our threshold value in an `ompl::base::Cost` object. We&#39;ll talk more about the `ompl::base::Cost` object later, but for now you can think of them as a wrapper for `double` values that represent the cost of a path.</div></div><!-- fragment --></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</body>
</html>
