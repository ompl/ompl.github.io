<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl::base::StateSpace Class Reference</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <link href="css/tabs.css" rel="stylesheet">
  <link href="css/doxygen.css" rel="stylesheet">
  <link href="css/search.css" rel="stylesheet">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="css/ompl.css" rel="stylesheet">
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="search/searchdata.js"></script>
  <script src="search/search.js"></script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="https://bitbucket.org/ompl/ompl/src">Browse Repository</a></li>
              <li><a href="teamcity.html">TeamCity Build Server</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
          <!-- Doxygen API search box -->
          <div id="searchli">
            <div id="MSearchBox" class="MSearchBoxInactive">
              <span class="left">
                <img id="MSearchSelect" src="search/mag_sel.png"
                onmouseover="return searchBox.OnSearchSelectShow()"
                onmouseout="return searchBox.OnSearchSelectHide()"
                alt=""/>
                <input type="text" id="MSearchField" value="Search API" accesskey="S"
                onfocus="searchBox.OnSearchFieldFocus(true)"
                onblur="searchBox.OnSearchFieldFocus(false)"
                onkeyup="searchBox.OnSearchFieldChange(event)"/>
              </span><span class="right">
                <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
              </span>
            </div>
          </div>
        </ul>
      </div>
    </div>
  </nav>
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"
  onmouseover="return searchBox.OnSearchSelectShow()"
  onmouseout="return searchBox.OnSearchSelectHide()"
  onkeydown="return searchBox.OnSearchSelectKey(event)">
  <a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="" frameborder="0"name="MSearchResults" id="MSearchResults"></iframe>
  </div>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceompl.html">ompl</a></li><li class="navelem"><a class="el" href="namespaceompl_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classompl_1_1base_1_1StateSpace-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ompl::base::StateSpace Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Representation of a space in which planning can be performed. Topology specific sampling, interpolation and distance are defined.  
 <a href="classompl_1_1base_1_1StateSpace.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StateSpace_8h_source.html">ompl/base/StateSpace.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ompl::base::StateSpace:</div>
<div class="dyncontent">
<div class="center"><img src="classompl_1_1base_1_1StateSpace__inherit__graph.png" border="0" usemap="#ompl_1_1base_1_1StateSpace_inherit__map" alt="Inheritance graph"/></div>
<map name="ompl_1_1base_1_1StateSpace_inherit__map" id="ompl_1_1base_1_1StateSpace_inherit__map">
<area shape="rect" id="node3" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html" title="State space wrapper to use together with CForest. It adds some functionalities to the regular state s..." alt="" coords="373,34,546,75"/><area shape="rect" id="node4" href="classompl_1_1base_1_1CompoundStateSpace.html" title="A space to allow the composition of state spaces. " alt="" coords="364,99,555,141"/><area shape="rect" id="node12" href="classompl_1_1base_1_1DiscreteStateSpace.html" title="A space representing discrete states; i.e. there are a small number of discrete states the system can..." alt="" coords="372,165,547,206"/><area shape="rect" id="node13" href="classompl_1_1base_1_1RealVectorStateSpace.html" title="A state space representing Rn. The distance function is the L2 norm. " alt="" coords="363,230,555,271"/><area shape="rect" id="node14" href="classompl_1_1base_1_1SO2StateSpace.html" title="A state space representing SO(2). The distance function and interpolation take into account angle wra..." alt="" coords="364,296,555,323"/><area shape="rect" id="node15" href="classompl_1_1base_1_1SO3StateSpace.html" title="A state space representing SO(3). The internal representation is done with quaternions. The distance between states is the angle between quaternions and interpolation is done with slerp. " alt="" coords="364,347,555,373"/><area shape="rect" id="node16" href="classompl_1_1base_1_1TimeStateSpace.html" title="A state space representing time. The time can be unbounded, in which case enforceBounds() is a no&#45;op..." alt="" coords="363,397,556,424"/><area shape="rect" id="node6" href="classompl_1_1base_1_1MorseStateSpace.html" title="State space representing MORSE states. " alt="" coords="604,56,804,83"/><area shape="rect" id="node7" href="classompl_1_1base_1_1SE2StateSpace.html" title="A state space representing SE(2) " alt="" coords="609,107,799,133"/><area shape="rect" id="node10" href="classompl_1_1base_1_1SE3StateSpace.html" title="A state space representing SE(3) " alt="" coords="609,157,799,184"/><area shape="rect" id="node11" href="classompl_1_1control_1_1OpenDEStateSpace.html" title="State space representing OpenDE states. " alt="" coords="610,209,798,250"/><area shape="rect" id="node8" href="classompl_1_1base_1_1DubinsStateSpace.html" title="An SE(2) state space where distance is measured by the length of Dubins curves. " alt="" coords="852,77,1057,104"/><area shape="rect" id="node9" href="classompl_1_1base_1_1ReedsSheppStateSpace.html" title="An SE(2) state space where distance is measured by the length of Reeds&#45;Shepp curves. " alt="" coords="853,129,1056,170"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of the address of a substate in a state. This structure stores the indexing information needed to access a particular substate of a state.  <a href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of the address of a value in a state. This structure stores the indexing information needed to access elements of a state (no pointer values are stored)  <a href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a64feddc33bb3b7459c4f589e6cd9d17e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17e">SanityChecks</a> { <br />
&#160;&#160;<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea044307209c21e4830272ca52945a3062">STATESPACE_DISTANCE_DIFFERENT_STATES</a> = (1&lt;&lt;1), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea5acf49ce656838100e44ed7ee7321ab6">STATESPACE_DISTANCE_SYMMETRIC</a> = (1&lt;&lt;2), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea26a108232d6265a1cc8bcc642216a6cf">STATESPACE_INTERPOLATION</a> = (1&lt;&lt;3), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea54e30ec7ef77f42f255951ac6be08f97">STATESPACE_TRIANGLE_INEQUALITY</a> = (1&lt;&lt;4), 
<br />
&#160;&#160;<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea0134f2a38473e775c3037fde1c336d3f">STATESPACE_DISTANCE_BOUND</a> = (1&lt;&lt;5), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea3c050038b3403113c40e3485398a9b18">STATESPACE_RESPECT_BOUNDS</a> = (1&lt;&lt;6), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17eafb4e9823a65ace5477bcc1cfc267b3fc">STATESPACE_ENFORCE_BOUNDS_NO_OP</a> = (1&lt;&lt;7), 
<a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17ea88b4708168876d0b1b010e40285c1cc1">STATESPACE_SERIALIZATION</a> = (1&lt;&lt;8)
<br />
 }</td></tr>
<tr class="memdesc:a64feddc33bb3b7459c4f589e6cd9d17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to use in a bit mask for state space sanity checks. Some basic checks do not have flags associated (they are always executed; for example, whether <a class="el" href="classompl_1_1base_1_1StateSpace.html#abff3478c3fc4da03c94d6f929f6ca7f9" title="Copy a state to another. The memory of source and destination should NOT overlap. ...">copyState()</a> works as expected)  <a href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17e">More...</a><br /></td></tr>
<tr class="separator:a64feddc33bb3b7459c4f589e6cd9d17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa995357fedb73879bc7f0bb946db76d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa995357fedb73879bc7f0bb946db76d1"></a>
typedef <a class="el" href="classompl_1_1base_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa995357fedb73879bc7f0bb946db76d1">StateType</a></td></tr>
<tr class="memdesc:aa995357fedb73879bc7f0bb946db76d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the type of state allocated by this space. <br /></td></tr>
<tr class="separator:aa995357fedb73879bc7f0bb946db76d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acfcc534e7c16c163ef33a05f195a0305"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfcc534e7c16c163ef33a05f195a0305"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#acfcc534e7c16c163ef33a05f195a0305">StateSpace</a> ()</td></tr>
<tr class="memdesc:acfcc534e7c16c163ef33a05f195a0305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Assigns a <b>unique</b> name to the space. <br /></td></tr>
<tr class="separator:acfcc534e7c16c163ef33a05f195a0305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd88dea5b056dae47158f22edb21e562"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afd88dea5b056dae47158f22edb21e562"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#afd88dea5b056dae47158f22edb21e562">as</a> ()</td></tr>
<tr class="memdesc:afd88dea5b056dae47158f22edb21e562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this instance to a desired type.  <a href="#afd88dea5b056dae47158f22edb21e562">More...</a><br /></td></tr>
<tr class="separator:afd88dea5b056dae47158f22edb21e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f4c7086d9f337752ba1522d2dc5b3e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a97f4c7086d9f337752ba1522d2dc5b3e"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a97f4c7086d9f337752ba1522d2dc5b3e">as</a> () const </td></tr>
<tr class="memdesc:a97f4c7086d9f337752ba1522d2dc5b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this instance to a desired type.  <a href="#a97f4c7086d9f337752ba1522d2dc5b3e">More...</a><br /></td></tr>
<tr class="separator:a97f4c7086d9f337752ba1522d2dc5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ca030ac21b5aa209241febcfbae2e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92ca030ac21b5aa209241febcfbae2e7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7">setup</a> ()</td></tr>
<tr class="memdesc:a92ca030ac21b5aa209241febcfbae2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform final setup steps. This function is automatically called by the <a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">SpaceInformation</a>. If any default projections are to be registered, this call will set them and call their <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> method is still called. <br /></td></tr>
<tr class="separator:a92ca030ac21b5aa209241febcfbae2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic functionality for state spaces</div></td></tr>
<tr class="memitem:adfac6c406d6fdbea7d9260e8b58d4d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfac6c406d6fdbea7d9260e8b58d4d11"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#adfac6c406d6fdbea7d9260e8b58d4d11">isCompound</a> () const </td></tr>
<tr class="memdesc:adfac6c406d6fdbea7d9260e8b58d4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the state space is compound. <br /></td></tr>
<tr class="separator:adfac6c406d6fdbea7d9260e8b58d4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ca6eb429ff4f3bb0cf2f485b5f340"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae51ca6eb429ff4f3bb0cf2f485b5f340">isDiscrete</a> () const </td></tr>
<tr class="memdesc:ae51ca6eb429ff4f3bb0cf2f485b5f340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the set of states is discrete.  <a href="#ae51ca6eb429ff4f3bb0cf2f485b5f340">More...</a><br /></td></tr>
<tr class="separator:ae51ca6eb429ff4f3bb0cf2f485b5f340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd8ae994ee6578517a6ffdab1b03dcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd8ae994ee6578517a6ffdab1b03dcf"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a8cd8ae994ee6578517a6ffdab1b03dcf">isHybrid</a> () const </td></tr>
<tr class="memdesc:a8cd8ae994ee6578517a6ffdab1b03dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is a hybrid state space (i.e., both discrete and continuous components exist) <br /></td></tr>
<tr class="separator:a8cd8ae994ee6578517a6ffdab1b03dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448989a6c1d0b9e40a4f5a194ec3a92a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a448989a6c1d0b9e40a4f5a194ec3a92a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a448989a6c1d0b9e40a4f5a194ec3a92a">isMetricSpace</a> () const </td></tr>
<tr class="memdesc:a448989a6c1d0b9e40a4f5a194ec3a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the distance function associated with the space is a metric. <br /></td></tr>
<tr class="separator:a448989a6c1d0b9e40a4f5a194ec3a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4245c946e2a60bf2a6cfa611cbf64ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4245c946e2a60bf2a6cfa611cbf64ced"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a4245c946e2a60bf2a6cfa611cbf64ced">hasSymmetricDistance</a> () const </td></tr>
<tr class="memdesc:a4245c946e2a60bf2a6cfa611cbf64ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the distance function on this state space is symmetric, i.e. distance(s1,s2) = distance(s2,s1). Default implementation returns true. <br /></td></tr>
<tr class="separator:a4245c946e2a60bf2a6cfa611cbf64ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9b314f8a64031e8269cd76489b629d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a9b314f8a64031e8269cd76489b629d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a4a9b314f8a64031e8269cd76489b629d">hasSymmetricInterpolate</a> () const </td></tr>
<tr class="memdesc:a4a9b314f8a64031e8269cd76489b629d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the interpolation function on this state space is symmetric, i.e. interpolate(from, to, t, state) = interpolate(to, from, 1-t, state). Default implementation returns true. <br /></td></tr>
<tr class="separator:a4a9b314f8a64031e8269cd76489b629d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c188c7dc690b152b7a61aae19b9015"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c188c7dc690b152b7a61aae19b9015"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a01c188c7dc690b152b7a61aae19b9015">getName</a> () const </td></tr>
<tr class="memdesc:a01c188c7dc690b152b7a61aae19b9015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the state space. <br /></td></tr>
<tr class="separator:a01c188c7dc690b152b7a61aae19b9015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cc022ef531dcb563f6d3d13b847ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad12cc022ef531dcb563f6d3d13b847ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad12cc022ef531dcb563f6d3d13b847ad">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad12cc022ef531dcb563f6d3d13b847ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the state space. <br /></td></tr>
<tr class="separator:ad12cc022ef531dcb563f6d3d13b847ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626ff04e6b9c4c9fa2c1392713861bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa626ff04e6b9c4c9fa2c1392713861bf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa626ff04e6b9c4c9fa2c1392713861bf">getType</a> () const </td></tr>
<tr class="memdesc:aa626ff04e6b9c4c9fa2c1392713861bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the state space. The type can be used to verify whether two space instances are of the same type (e.g., SO2) <br /></td></tr>
<tr class="separator:aa626ff04e6b9c4c9fa2c1392713861bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af294ec92dcc0e35793570d039d61d019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af294ec92dcc0e35793570d039d61d019"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#af294ec92dcc0e35793570d039d61d019">includes</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;other) const </td></tr>
<tr class="memdesc:af294ec92dcc0e35793570d039d61d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space included (perhaps equal, perhaps a subspace) in this one. <br /></td></tr>
<tr class="separator:af294ec92dcc0e35793570d039d61d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7768e633f4c4c09f02d01f7ad765dcd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7768e633f4c4c09f02d01f7ad765dcd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a7768e633f4c4c09f02d01f7ad765dcd1">includes</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *other) const </td></tr>
<tr class="memdesc:a7768e633f4c4c09f02d01f7ad765dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space included (perhaps equal, perhaps a subspace) in this one. <br /></td></tr>
<tr class="separator:a7768e633f4c4c09f02d01f7ad765dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a2cdf29ab85faa2b76cca36c23229d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a2cdf29ab85faa2b76cca36c23229d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a41a2cdf29ab85faa2b76cca36c23229d">covers</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;other) const </td></tr>
<tr class="memdesc:a41a2cdf29ab85faa2b76cca36c23229d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space that is either included (perhaps equal, perhaps a subspace) in this one, or all of its subspaces are included in this one. <br /></td></tr>
<tr class="separator:a41a2cdf29ab85faa2b76cca36c23229d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e585bf55e4cbb03ad2da5f192df01ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e585bf55e4cbb03ad2da5f192df01ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a3e585bf55e4cbb03ad2da5f192df01ee">covers</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *other) const </td></tr>
<tr class="memdesc:a3e585bf55e4cbb03ad2da5f192df01ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>other</em> is a space that is either included (perhaps equal, perhaps a subspace) in this one, or all of its subspaces are included in this one. <br /></td></tr>
<tr class="separator:a3e585bf55e4cbb03ad2da5f192df01ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9fee742c4811d13f236aecd6b9d901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d9fee742c4811d13f236aecd6b9d901"></a>
<a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9d9fee742c4811d13f236aecd6b9d901">params</a> ()</td></tr>
<tr class="memdesc:a9d9fee742c4811d13f236aecd6b9d901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters for this space. <br /></td></tr>
<tr class="separator:a9d9fee742c4811d13f236aecd6b9d901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f942d26b8d63262ff5fb5e8774bf4e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f942d26b8d63262ff5fb5e8774bf4e0"></a>
const <a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9f942d26b8d63262ff5fb5e8774bf4e0">params</a> () const </td></tr>
<tr class="memdesc:a9f942d26b8d63262ff5fb5e8774bf4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters for this space. <br /></td></tr>
<tr class="separator:a9f942d26b8d63262ff5fb5e8774bf4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6098a238a7cc1925c58e9983ab5f2967"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6098a238a7cc1925c58e9983ab5f2967"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a6098a238a7cc1925c58e9983ab5f2967">getLongestValidSegmentFraction</a> () const </td></tr>
<tr class="memdesc:a6098a238a7cc1925c58e9983ab5f2967"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing discrete validation of motions, the length of the longest segment that does not require state validation needs to be specified. This function returns this length, for this state space, as a fraction of the space's maximum extent. <br /></td></tr>
<tr class="separator:a6098a238a7cc1925c58e9983ab5f2967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e6450ad306d272df39751aa7e690b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad8e6450ad306d272df39751aa7e690b8">setLongestValidSegmentFraction</a> (double segmentFraction)</td></tr>
<tr class="memdesc:ad8e6450ad306d272df39751aa7e690b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">When performing discrete validation of motions, the length of the longest segment that does not require state validation needs to be specified. This function sets this length as a fraction of the space's maximum extent.  <a href="#ad8e6450ad306d272df39751aa7e690b8">More...</a><br /></td></tr>
<tr class="separator:ad8e6450ad306d272df39751aa7e690b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17443b992677f5043d3fc38e9288b9a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17443b992677f5043d3fc38e9288b9a7"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7">validSegmentCount</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state1, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state2) const </td></tr>
<tr class="memdesc:a17443b992677f5043d3fc38e9288b9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many segments of the "longest valid length" fit on the motion from <em>state1</em> to <em>state2</em>. <br /></td></tr>
<tr class="separator:a17443b992677f5043d3fc38e9288b9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9babd71497fc6a6f82fe97f699531ceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9babd71497fc6a6f82fe97f699531ceb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9babd71497fc6a6f82fe97f699531ceb">setValidSegmentCountFactor</a> (unsigned int factor)</td></tr>
<tr class="memdesc:a9babd71497fc6a6f82fe97f699531ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>factor</em> to be the value to multiply the return value of <a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7" title="Count how many segments of the &quot;longest valid length&quot; fit on the motion from state1 to state2...">validSegmentCount()</a>. By default, this value is 1. The higher the value, the smaller the size of the segments considered valid. The effect of this function is immediate (<a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> does not need to be called). <br /></td></tr>
<tr class="separator:a9babd71497fc6a6f82fe97f699531ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed57ae383c07bbc4fddbd9ab66de466b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed57ae383c07bbc4fddbd9ab66de466b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aed57ae383c07bbc4fddbd9ab66de466b">getValidSegmentCountFactor</a> () const </td></tr>
<tr class="memdesc:aed57ae383c07bbc4fddbd9ab66de466b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value used to multiply the return value of <a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7" title="Count how many segments of the &quot;longest valid length&quot; fit on the motion from state1 to state2...">validSegmentCount()</a>. <br /></td></tr>
<tr class="separator:aed57ae383c07bbc4fddbd9ab66de466b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8381e2478361e9326480b622e4c03b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c8381e2478361e9326480b622e4c03b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a0c8381e2478361e9326480b622e4c03b">getLongestValidSegmentLength</a> () const </td></tr>
<tr class="memdesc:a0c8381e2478361e9326480b622e4c03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the longest valid segment at the time <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> was called. <br /></td></tr>
<tr class="separator:a0c8381e2478361e9326480b622e4c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea93afe2f6c3af1702178992554519c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea93afe2f6c3af1702178992554519c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aea93afe2f6c3af1702178992554519c0">computeSignature</a> (std::vector&lt; int &gt; &amp;signature) const </td></tr>
<tr class="memdesc:aea93afe2f6c3af1702178992554519c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an array of ints that uniquely identifies the structure of the state space. The first element of the signature is the number of integers that follow. <br /></td></tr>
<tr class="separator:aea93afe2f6c3af1702178992554519c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functionality specific to state spaces (to be implemented by derived state spaces)</div></td></tr>
<tr class="memitem:a7cfc88ad641d95adbc20c7b6c6b4151d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cfc88ad641d95adbc20c7b6c6b4151d"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a7cfc88ad641d95adbc20c7b6c6b4151d">getDimension</a> () const =0</td></tr>
<tr class="memdesc:a7cfc88ad641d95adbc20c7b6c6b4151d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the space (not the dimension of the surrounding ambient space) <br /></td></tr>
<tr class="separator:a7cfc88ad641d95adbc20c7b6c6b4151d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a72168397b61ee33c0f2bf98ced2e5"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#af7a72168397b61ee33c0f2bf98ced2e5">getMaximumExtent</a> () const =0</td></tr>
<tr class="memdesc:af7a72168397b61ee33c0f2bf98ced2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum value a call to <a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">distance()</a> can return (or an upper bound). For unbounded state spaces, this function can return infinity.  <a href="#af7a72168397b61ee33c0f2bf98ced2e5">More...</a><br /></td></tr>
<tr class="separator:af7a72168397b61ee33c0f2bf98ced2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd95b39e49cf6a251ce650cbf35c399"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dd95b39e49cf6a251ce650cbf35c399"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a5dd95b39e49cf6a251ce650cbf35c399">getMeasure</a> () const =0</td></tr>
<tr class="memdesc:a5dd95b39e49cf6a251ce650cbf35c399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a measure of the space (this can be thought of as a generalization of volume) <br /></td></tr>
<tr class="separator:a5dd95b39e49cf6a251ce650cbf35c399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a52d4000174091df038c603078add78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a52d4000174091df038c603078add78"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a7a52d4000174091df038c603078add78">enforceBounds</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const =0</td></tr>
<tr class="memdesc:a7a52d4000174091df038c603078add78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring the state within the bounds of the state space. For unbounded spaces this function can be a no-op. <br /></td></tr>
<tr class="separator:a7a52d4000174091df038c603078add78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07deb46127836f5795a8c0ceca1a1209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07deb46127836f5795a8c0ceca1a1209"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a07deb46127836f5795a8c0ceca1a1209">satisfiesBounds</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const =0</td></tr>
<tr class="memdesc:a07deb46127836f5795a8c0ceca1a1209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state is inside the bounding box. For unbounded spaces this function can always return true. <br /></td></tr>
<tr class="separator:a07deb46127836f5795a8c0ceca1a1209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3478c3fc4da03c94d6f929f6ca7f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#abff3478c3fc4da03c94d6f929f6ca7f9">copyState</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *destination, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source) const =0</td></tr>
<tr class="memdesc:abff3478c3fc4da03c94d6f929f6ca7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a state to another. The memory of source and destination should NOT overlap.  <a href="#abff3478c3fc4da03c94d6f929f6ca7f9">More...</a><br /></td></tr>
<tr class="separator:abff3478c3fc4da03c94d6f929f6ca7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb781becdcdf8770d61c218632c71bd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb781becdcdf8770d61c218632c71bd5"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5">distance</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state1, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state2) const =0</td></tr>
<tr class="memdesc:acb781becdcdf8770d61c218632c71bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes distance between two states. This function satisfies the properties of a metric if <a class="el" href="classompl_1_1base_1_1StateSpace.html#a448989a6c1d0b9e40a4f5a194ec3a92a" title="Return true if the distance function associated with the space is a metric. ">isMetricSpace()</a> is true, and its return value will always be between 0 and <a class="el" href="classompl_1_1base_1_1StateSpace.html#af7a72168397b61ee33c0f2bf98ced2e5" title="Get the maximum value a call to distance() can return (or an upper bound). For unbounded state spaces...">getMaximumExtent()</a> <br /></td></tr>
<tr class="separator:acb781becdcdf8770d61c218632c71bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b4d56d5b379b3da818baf73e599079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3b4d56d5b379b3da818baf73e599079"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae3b4d56d5b379b3da818baf73e599079">getSerializationLength</a> () const </td></tr>
<tr class="memdesc:ae3b4d56d5b379b3da818baf73e599079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of chars in the serialization of a state in this space. <br /></td></tr>
<tr class="separator:ae3b4d56d5b379b3da818baf73e599079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842fb601d28735dd56a2480dbb460662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a842fb601d28735dd56a2480dbb460662"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a842fb601d28735dd56a2480dbb460662">serialize</a> (void *serialization, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const </td></tr>
<tr class="memdesc:a842fb601d28735dd56a2480dbb460662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the binary representation of <em>state</em> to <em>serialization</em>. <br /></td></tr>
<tr class="separator:a842fb601d28735dd56a2480dbb460662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2d2ac9a93fea0a269382daf585e68a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea2d2ac9a93fea0a269382daf585e68a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aea2d2ac9a93fea0a269382daf585e68a">deserialize</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const void *serialization) const </td></tr>
<tr class="memdesc:aea2d2ac9a93fea0a269382daf585e68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the binary representation of a state from <em>serialization</em> and write it to <em>state</em>. <br /></td></tr>
<tr class="separator:aea2d2ac9a93fea0a269382daf585e68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6babf3addb5ed9608800b7460a20da39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6babf3addb5ed9608800b7460a20da39"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a6babf3addb5ed9608800b7460a20da39">equalStates</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state1, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state2) const =0</td></tr>
<tr class="memdesc:a6babf3addb5ed9608800b7460a20da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two states are equal. <br /></td></tr>
<tr class="separator:a6babf3addb5ed9608800b7460a20da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4220070a3365dd973e09c251f3381107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4220070a3365dd973e09c251f3381107"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a4220070a3365dd973e09c251f3381107">interpolate</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *from, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *to, const double t, <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const =0</td></tr>
<tr class="memdesc:a4220070a3365dd973e09c251f3381107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the state that lies at time <em>t</em> in [0, 1] on the segment that connects <em>from</em> state to <em>to</em> state. The memory location of <em>state</em> is not required to be different from the memory of either <em>from</em> or <em>to</em>. <br /></td></tr>
<tr class="separator:a4220070a3365dd973e09c251f3381107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85423c93ff1f5dfca07d3b27ef58ef61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85423c93ff1f5dfca07d3b27ef58ef61"></a>
virtual <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a85423c93ff1f5dfca07d3b27ef58ef61">allocDefaultStateSampler</a> () const =0</td></tr>
<tr class="memdesc:a85423c93ff1f5dfca07d3b27ef58ef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an instance of the default uniform state sampler for this space. <br /></td></tr>
<tr class="separator:a85423c93ff1f5dfca07d3b27ef58ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f01713e330350e2fa2c6f5c1c1f1d31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f01713e330350e2fa2c6f5c1c1f1d31"></a>
virtual <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a1f01713e330350e2fa2c6f5c1c1f1d31">allocStateSampler</a> () const </td></tr>
<tr class="memdesc:a1f01713e330350e2fa2c6f5c1c1f1d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an instance of the state sampler for this space. This sampler will be allocated with the sampler allocator that was previously specified by <a class="el" href="classompl_1_1base_1_1StateSpace.html#aa88e8a85586b93866ef3b2a6fb31c114" title="Set the sampler allocator to use. ">setStateSamplerAllocator()</a> or, if no sampler allocator was specified, <a class="el" href="classompl_1_1base_1_1StateSpace.html#a85423c93ff1f5dfca07d3b27ef58ef61" title="Allocate an instance of the default uniform state sampler for this space. ">allocDefaultStateSampler()</a> is called. <br /></td></tr>
<tr class="separator:a1f01713e330350e2fa2c6f5c1c1f1d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88e8a85586b93866ef3b2a6fb31c114"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88e8a85586b93866ef3b2a6fb31c114"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa88e8a85586b93866ef3b2a6fb31c114">setStateSamplerAllocator</a> (const <a class="el" href="namespaceompl_1_1base.html#a0898b21bd2fed51298626f7be55779b8">StateSamplerAllocator</a> &amp;ssa)</td></tr>
<tr class="memdesc:aa88e8a85586b93866ef3b2a6fb31c114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sampler allocator to use. <br /></td></tr>
<tr class="separator:aa88e8a85586b93866ef3b2a6fb31c114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c1c40dcb3687c024629119e2d905d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd0c1c40dcb3687c024629119e2d905d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#abd0c1c40dcb3687c024629119e2d905d">clearStateSamplerAllocator</a> ()</td></tr>
<tr class="memdesc:abd0c1c40dcb3687c024629119e2d905d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the state sampler allocator (reset to default) <br /></td></tr>
<tr class="separator:abd0c1c40dcb3687c024629119e2d905d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86d2a2401044774fa4de3345a29d408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae86d2a2401044774fa4de3345a29d408"></a>
virtual <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae86d2a2401044774fa4de3345a29d408">allocState</a> () const =0</td></tr>
<tr class="memdesc:ae86d2a2401044774fa4de3345a29d408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a state that can store a point in the described space. <br /></td></tr>
<tr class="separator:ae86d2a2401044774fa4de3345a29d408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75db7a7ef3d05f13632b7ccc67e6b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb75db7a7ef3d05f13632b7ccc67e6b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aeb75db7a7ef3d05f13632b7ccc67e6b9">freeState</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state) const =0</td></tr>
<tr class="memdesc:aeb75db7a7ef3d05f13632b7ccc67e6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory of the allocated state. <br /></td></tr>
<tr class="separator:aeb75db7a7ef3d05f13632b7ccc67e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functionality specific to accessing real values in a state</div></td></tr>
<tr class="memitem:a8584afb9165d2aa7408fec81c18659f4"><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a8584afb9165d2aa7408fec81c18659f4">getValueAddressAtIndex</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const unsigned int index) const </td></tr>
<tr class="memdesc:a8584afb9165d2aa7408fec81c18659f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many states contain a number of double values. This function provides a means to get the memory address of a double value from state <em>state</em> located at position <em>index</em>. The first double value is returned for <em>index</em> = 0. If <em>index</em> is too large (does not point to any double values in the state), the return value is NULL.  <a href="#a8584afb9165d2aa7408fec81c18659f4">More...</a><br /></td></tr>
<tr class="separator:a8584afb9165d2aa7408fec81c18659f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a758dfef4b4e0ca3aa126862e0e834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a758dfef4b4e0ca3aa126862e0e834"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae8a758dfef4b4e0ca3aa126862e0e834">getValueAddressAtIndex</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const unsigned int index) const </td></tr>
<tr class="memdesc:ae8a758dfef4b4e0ca3aa126862e0e834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of the same function as above;. <br /></td></tr>
<tr class="separator:ae8a758dfef4b4e0ca3aa126862e0e834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a3c20690488593be339b034c65a1ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a3c20690488593be339b034c65a1ec"></a>
const std::vector&lt; <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa5a3c20690488593be339b034c65a1ec">getValueLocations</a> () const </td></tr>
<tr class="memdesc:aa5a3c20690488593be339b034c65a1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locations of values of type double contained in a state from this space. The order of the values is consistent with <a class="el" href="classompl_1_1base_1_1StateSpace.html#a8584afb9165d2aa7408fec81c18659f4" title="Many states contain a number of double values. This function provides a means to get the memory addre...">getValueAddressAtIndex()</a>. The <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> function must have been previously called. <br /></td></tr>
<tr class="separator:aa5a3c20690488593be339b034c65a1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7757bb42622aef8a20ae44b2174124ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7757bb42622aef8a20ae44b2174124ae"></a>
const std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a7757bb42622aef8a20ae44b2174124ae">getValueLocationsByName</a> () const </td></tr>
<tr class="memdesc:a7757bb42622aef8a20ae44b2174124ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the named locations of values of type double contained in a state from this space. The <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> function must have been previously called. <br /></td></tr>
<tr class="separator:a7757bb42622aef8a20ae44b2174124ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1440136336d3b92067e77b8586db5448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1440136336d3b92067e77b8586db5448"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448">getValueAddressAtLocation</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:a1440136336d3b92067e77b8586db5448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the double value in <em>state</em> that <em>loc</em> points to. <br /></td></tr>
<tr class="separator:a1440136336d3b92067e77b8586db5448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b21b2faa7e5f93512a2a4b40f8599ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b21b2faa7e5f93512a2a4b40f8599ab"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a2b21b2faa7e5f93512a2a4b40f8599ab">getValueAddressAtLocation</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:a2b21b2faa7e5f93512a2a4b40f8599ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of the same function as above;. <br /></td></tr>
<tr class="separator:a2b21b2faa7e5f93512a2a4b40f8599ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92aa2f2318020587918fb4dbca2eb07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae92aa2f2318020587918fb4dbca2eb07"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae92aa2f2318020587918fb4dbca2eb07">getValueAddressAtName</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const std::string &amp;name) const </td></tr>
<tr class="memdesc:ae92aa2f2318020587918fb4dbca2eb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the double value in <em>state</em> that <em>name</em> points to. <br /></td></tr>
<tr class="separator:ae92aa2f2318020587918fb4dbca2eb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8399a3f967203a5035da33c5eb5b04cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8399a3f967203a5035da33c5eb5b04cc"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a8399a3f967203a5035da33c5eb5b04cc">getValueAddressAtName</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const std::string &amp;name) const </td></tr>
<tr class="memdesc:a8399a3f967203a5035da33c5eb5b04cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of the same function as above;. <br /></td></tr>
<tr class="separator:a8399a3f967203a5035da33c5eb5b04cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6fc5ba387526bb853b6a2d3d3f2bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02c6fc5ba387526bb853b6a2d3d3f2bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a02c6fc5ba387526bb853b6a2d3d3f2bd">copyToReals</a> (std::vector&lt; double &gt; &amp;reals, const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *source) const </td></tr>
<tr class="memdesc:a02c6fc5ba387526bb853b6a2d3d3f2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all the real values from a state <em>source</em> to the array <em>reals</em> using <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> <br /></td></tr>
<tr class="separator:a02c6fc5ba387526bb853b6a2d3d3f2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d9f193839b8c57a3d1dc11dfb364db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d9f193839b8c57a3d1dc11dfb364db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a86d9f193839b8c57a3d1dc11dfb364db">copyFromReals</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *destination, const std::vector&lt; double &gt; &amp;reals) const </td></tr>
<tr class="memdesc:a86d9f193839b8c57a3d1dc11dfb364db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from <em>reals</em> to the state <em>destination</em> using <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> <br /></td></tr>
<tr class="separator:a86d9f193839b8c57a3d1dc11dfb364db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Management of projections from this state space to Euclidean spaces</div></td></tr>
<tr class="memitem:a309f2cdc5412ff16d31b87fec92b3595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a309f2cdc5412ff16d31b87fec92b3595"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a309f2cdc5412ff16d31b87fec92b3595">registerProjection</a> (const std::string &amp;name, const <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &amp;projection)</td></tr>
<tr class="memdesc:a309f2cdc5412ff16d31b87fec92b3595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a projection for this state space under a specified name. <br /></td></tr>
<tr class="separator:a309f2cdc5412ff16d31b87fec92b3595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79f6342fb2d85f1c2c87bfff812fbbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79f6342fb2d85f1c2c87bfff812fbbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac79f6342fb2d85f1c2c87bfff812fbbf">registerDefaultProjection</a> (const <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &amp;projection)</td></tr>
<tr class="memdesc:ac79f6342fb2d85f1c2c87bfff812fbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the default projection for this state space. <br /></td></tr>
<tr class="separator:ac79f6342fb2d85f1c2c87bfff812fbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d83398ca1647e06036d9e69ebad7cf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d83398ca1647e06036d9e69ebad7cf8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a9d83398ca1647e06036d9e69ebad7cf8">registerProjections</a> ()</td></tr>
<tr class="memdesc:a9d83398ca1647e06036d9e69ebad7cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the projections for this state space. Usually, this is at least the default projection. These are implicit projections, set by the implementation of the state space. This is called by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a>. <br /></td></tr>
<tr class="separator:a9d83398ca1647e06036d9e69ebad7cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e75a507f6e8e538d1542bc9e31b256"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e75a507f6e8e538d1542bc9e31b256"></a>
<a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a05e75a507f6e8e538d1542bc9e31b256">getProjection</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a05e75a507f6e8e538d1542bc9e31b256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection registered under a specific name. <br /></td></tr>
<tr class="separator:a05e75a507f6e8e538d1542bc9e31b256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72230e2d66fc50b2670d21906397eeb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72230e2d66fc50b2670d21906397eeb2"></a>
<a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a72230e2d66fc50b2670d21906397eeb2">getDefaultProjection</a> () const </td></tr>
<tr class="memdesc:a72230e2d66fc50b2670d21906397eeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default projection. <br /></td></tr>
<tr class="separator:a72230e2d66fc50b2670d21906397eeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8b8097e7c5defa159797a80c2ebf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade8b8097e7c5defa159797a80c2ebf2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aade8b8097e7c5defa159797a80c2ebf2">hasProjection</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:aade8b8097e7c5defa159797a80c2ebf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a projection with a specified name is available. <br /></td></tr>
<tr class="separator:aade8b8097e7c5defa159797a80c2ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19df18cdd2ae774d223faac12c116d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19df18cdd2ae774d223faac12c116d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ae19df18cdd2ae774d223faac12c116d0">hasDefaultProjection</a> () const </td></tr>
<tr class="memdesc:ae19df18cdd2ae774d223faac12c116d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a default projection is available. <br /></td></tr>
<tr class="separator:ae19df18cdd2ae774d223faac12c116d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8712f482e90c8a0c666bb89ef0711b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe8712f482e90c8a0c666bb89ef0711b"></a>
const std::map&lt; std::string, <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#abe8712f482e90c8a0c666bb89ef0711b">getRegisteredProjections</a> () const </td></tr>
<tr class="memdesc:abe8712f482e90c8a0c666bb89ef0711b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the registered projections. <br /></td></tr>
<tr class="separator:abe8712f482e90c8a0c666bb89ef0711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations with substates</div></td></tr>
<tr class="memitem:adc3d8370d634b7e6fcb38d072c9ef317"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3d8370d634b7e6fcb38d072c9ef317"></a>
<a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#adc3d8370d634b7e6fcb38d072c9ef317">allocSubspaceStateSampler</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;subspace) const </td></tr>
<tr class="memdesc:adc3d8370d634b7e6fcb38d072c9ef317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a sampler that actually samples only components that are part of <em>subspace</em>. <br /></td></tr>
<tr class="separator:adc3d8370d634b7e6fcb38d072c9ef317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0113a03fd742642bbcd17b435e09fbab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0113a03fd742642bbcd17b435e09fbab"></a>
virtual <a class="el" href="classompl_1_1base_1_1StateSamplerPtr.html">StateSamplerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a0113a03fd742642bbcd17b435e09fbab">allocSubspaceStateSampler</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *subspace) const </td></tr>
<tr class="memdesc:a0113a03fd742642bbcd17b435e09fbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a sampler that actually samples only components that are part of <em>subspace</em>. <br /></td></tr>
<tr class="separator:a0113a03fd742642bbcd17b435e09fbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d545b50a54e230bbdac1e0eb7e945b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7d545b50a54e230bbdac1e0eb7e945b"></a>
<a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac7d545b50a54e230bbdac1e0eb7e945b">getSubstateAtLocation</a> (<a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:ac7d545b50a54e230bbdac1e0eb7e945b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substate of <em>state</em> that is pointed to by <em>loc</em>. <br /></td></tr>
<tr class="separator:ac7d545b50a54e230bbdac1e0eb7e945b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad714cae5c068fb733df05b53b6816d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad714cae5c068fb733df05b53b6816d63"></a>
const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad714cae5c068fb733df05b53b6816d63">getSubstateAtLocation</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, const <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &amp;loc) const </td></tr>
<tr class="memdesc:ad714cae5c068fb733df05b53b6816d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substate of <em>state</em> that is pointed to by <em>loc</em>. <br /></td></tr>
<tr class="separator:ad714cae5c068fb733df05b53b6816d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535a54d0cedf038703db2fbfd00fb5d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535a54d0cedf038703db2fbfd00fb5d0"></a>
const std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a535a54d0cedf038703db2fbfd00fb5d0">getSubstateLocationsByName</a> () const </td></tr>
<tr class="memdesc:a535a54d0cedf038703db2fbfd00fb5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of known substate locations (keys of the map corrspond to names of subspaces) <br /></td></tr>
<tr class="separator:a535a54d0cedf038703db2fbfd00fb5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbffba40d1dff6e3c0b80cc2439f2378"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbffba40d1dff6e3c0b80cc2439f2378"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#afbffba40d1dff6e3c0b80cc2439f2378">getCommonSubspaces</a> (const <a class="el" href="classompl_1_1base_1_1StateSpacePtr.html">StateSpacePtr</a> &amp;other, std::vector&lt; std::string &gt; &amp;subspaces) const </td></tr>
<tr class="memdesc:afbffba40d1dff6e3c0b80cc2439f2378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of subspaces that this space and <em>other</em> have in common. The computed list of <em>subspaces</em> does not contain spaces that cover each other, even though they may be common, as that is redundant information. <br /></td></tr>
<tr class="separator:afbffba40d1dff6e3c0b80cc2439f2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fa8c0af22fe3f28f2fc9d551082455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fa8c0af22fe3f28f2fc9d551082455"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a40fa8c0af22fe3f28f2fc9d551082455">getCommonSubspaces</a> (const <a class="el" href="classompl_1_1base_1_1StateSpace.html">StateSpace</a> *other, std::vector&lt; std::string &gt; &amp;subspaces) const </td></tr>
<tr class="memdesc:a40fa8c0af22fe3f28f2fc9d551082455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of subspaces that this space and <em>other</em> have in common. The computed list of <em>subspaces</em> does not contain spaces that cover each other, even though they may be common, as that is redundant information. <br /></td></tr>
<tr class="separator:a40fa8c0af22fe3f28f2fc9d551082455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1866860e11fb0eb759453df70ba68ae2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1866860e11fb0eb759453df70ba68ae2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a1866860e11fb0eb759453df70ba68ae2">computeLocations</a> ()</td></tr>
<tr class="memdesc:a1866860e11fb0eb759453df70ba68ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the location information for various components of the state space. Either this function or <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> must be called before any calls to <a class="el" href="classompl_1_1base_1_1StateSpace.html#ae92aa2f2318020587918fb4dbca2eb07" title="Get a pointer to the double value in state that name points to. ">getValueAddressAtName()</a>, <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> (and other functions where those are used). <br /></td></tr>
<tr class="separator:a1866860e11fb0eb759453df70ba68ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a68556edd816136a66a0d81544baef08c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68556edd816136a66a0d81544baef08c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a68556edd816136a66a0d81544baef08c">type_</a></td></tr>
<tr class="memdesc:a68556edd816136a66a0d81544baef08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type assigned for this state space. <br /></td></tr>
<tr class="separator:a68556edd816136a66a0d81544baef08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db3152c4edbac084af3ec6962107ddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2db3152c4edbac084af3ec6962107ddb"></a>
<a class="el" href="namespaceompl_1_1base.html#a0898b21bd2fed51298626f7be55779b8">StateSamplerAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a2db3152c4edbac084af3ec6962107ddb">ssa_</a></td></tr>
<tr class="memdesc:a2db3152c4edbac084af3ec6962107ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional state sampler allocator. <br /></td></tr>
<tr class="separator:a2db3152c4edbac084af3ec6962107ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139d63d7b1067a70cb6e744e85fef96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af139d63d7b1067a70cb6e744e85fef96"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#af139d63d7b1067a70cb6e744e85fef96">maxExtent_</a></td></tr>
<tr class="memdesc:af139d63d7b1067a70cb6e744e85fef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extent of this space at the time <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> was called. <br /></td></tr>
<tr class="separator:af139d63d7b1067a70cb6e744e85fef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaba86765fbfc6686312e50934edfd70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaba86765fbfc6686312e50934edfd70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aeaba86765fbfc6686312e50934edfd70">longestValidSegmentFraction_</a></td></tr>
<tr class="memdesc:aeaba86765fbfc6686312e50934edfd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction of the longest valid segment. <br /></td></tr>
<tr class="separator:aeaba86765fbfc6686312e50934edfd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967afde4dc99333aef63eb85554bf81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8967afde4dc99333aef63eb85554bf81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a8967afde4dc99333aef63eb85554bf81">longestValidSegment_</a></td></tr>
<tr class="memdesc:a8967afde4dc99333aef63eb85554bf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The longest valid segment at the time <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> was called. <br /></td></tr>
<tr class="separator:a8967afde4dc99333aef63eb85554bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fbdc24d4e07283890eb68f49bc1467"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3fbdc24d4e07283890eb68f49bc1467"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aa3fbdc24d4e07283890eb68f49bc1467">longestValidSegmentCountFactor_</a></td></tr>
<tr class="memdesc:aa3fbdc24d4e07283890eb68f49bc1467"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factor to multiply the value returned by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a17443b992677f5043d3fc38e9288b9a7" title="Count how many segments of the &quot;longest valid length&quot; fit on the motion from state1 to state2...">validSegmentCount()</a>. Rarely used but useful for things like doubling the resolution. <br /></td></tr>
<tr class="separator:aa3fbdc24d4e07283890eb68f49bc1467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32be9ff082fcb2926cbc8166613e09a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab32be9ff082fcb2926cbc8166613e09a"></a>
std::map&lt; std::string, <a class="el" href="classompl_1_1base_1_1ProjectionEvaluatorPtr.html">ProjectionEvaluatorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ab32be9ff082fcb2926cbc8166613e09a">projections_</a></td></tr>
<tr class="memdesc:ab32be9ff082fcb2926cbc8166613e09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of available projections. <br /></td></tr>
<tr class="separator:ab32be9ff082fcb2926cbc8166613e09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b0b30f238bff63ecb43542aee6ebf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11b0b30f238bff63ecb43542aee6ebf3"></a>
<a class="el" href="classompl_1_1base_1_1ParamSet.html">ParamSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a11b0b30f238bff63ecb43542aee6ebf3">params_</a></td></tr>
<tr class="memdesc:a11b0b30f238bff63ecb43542aee6ebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of parameters for this space. <br /></td></tr>
<tr class="separator:a11b0b30f238bff63ecb43542aee6ebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f6c83355692e7f40d4ead85b9f225b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f6c83355692e7f40d4ead85b9f225b"></a>
std::vector&lt; <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac0f6c83355692e7f40d4ead85b9f225b">valueLocationsInOrder_</a></td></tr>
<tr class="memdesc:ac0f6c83355692e7f40d4ead85b9f225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value locations for all varliables of type double contained in a state; The locations point to values in the same order as that returned by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a8584afb9165d2aa7408fec81c18659f4" title="Many states contain a number of double values. This function provides a means to get the memory addre...">getValueAddressAtIndex()</a> <br /></td></tr>
<tr class="separator:ac0f6c83355692e7f40d4ead85b9f225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24c368e6e9130b505d89c824a9ec1e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24c368e6e9130b505d89c824a9ec1e7"></a>
std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1ValueLocation.html">ValueLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac24c368e6e9130b505d89c824a9ec1e7">valueLocationsByName_</a></td></tr>
<tr class="memdesc:ac24c368e6e9130b505d89c824a9ec1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the known value locations, by name. The names of state spaces access the first element of a state. <a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html" title="A state space representing Rn. The distance function is the L2 norm. ">RealVectorStateSpace</a> dimensions are used to access individual dimensions. <br /></td></tr>
<tr class="separator:ac24c368e6e9130b505d89c824a9ec1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa4613b3ef62e88fbfc23fb6757e34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23aa4613b3ef62e88fbfc23fb6757e34"></a>
std::map&lt; std::string, <a class="el" href="structompl_1_1base_1_1StateSpace_1_1SubstateLocation.html">SubstateLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a23aa4613b3ef62e88fbfc23fb6757e34">substateLocationsByName_</a></td></tr>
<tr class="memdesc:a23aa4613b3ef62e88fbfc23fb6757e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the known substat locations, by name. <br /></td></tr>
<tr class="separator:a23aa4613b3ef62e88fbfc23fb6757e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a45e65cf86a2c5cb1e4394dd8aafb4d3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e65cf86a2c5cb1e4394dd8aafb4d3b"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a45e65cf86a2c5cb1e4394dd8aafb4d3b">DEFAULT_PROJECTION_NAME</a> = &quot;&quot;</td></tr>
<tr class="memdesc:a45e65cf86a2c5cb1e4394dd8aafb4d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name used for the default projection. <br /></td></tr>
<tr class="separator:a45e65cf86a2c5cb1e4394dd8aafb4d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Debugging tools</h2></td></tr>
<tr class="memitem:a5f92fa826285aaa7adff4c1fd07a4023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f92fa826285aaa7adff4c1fd07a4023"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a5f92fa826285aaa7adff4c1fd07a4023">printState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *state, std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a5f92fa826285aaa7adff4c1fd07a4023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a state to a stream. <br /></td></tr>
<tr class="separator:a5f92fa826285aaa7adff4c1fd07a4023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d78e50cceae2e0a432fea171a431324"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d78e50cceae2e0a432fea171a431324"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a0d78e50cceae2e0a432fea171a431324">printSettings</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a0d78e50cceae2e0a432fea171a431324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the settings for this state space to a stream. <br /></td></tr>
<tr class="separator:a0d78e50cceae2e0a432fea171a431324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d0d31d8cf99ca55e83d83be778918"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a988d0d31d8cf99ca55e83d83be778918"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a988d0d31d8cf99ca55e83d83be778918">printProjections</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a988d0d31d8cf99ca55e83d83be778918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of registered projections. This function is also called by <a class="el" href="classompl_1_1base_1_1StateSpace.html#a0d78e50cceae2e0a432fea171a431324" title="Print the settings for this state space to a stream. ">printSettings()</a> <br /></td></tr>
<tr class="separator:a988d0d31d8cf99ca55e83d83be778918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f53aa590e5054a150861d2d1689522"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a24f53aa590e5054a150861d2d1689522">sanityChecks</a> (double zero, double eps, unsigned int flags) const </td></tr>
<tr class="memdesc:a24f53aa590e5054a150861d2d1689522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sanity checks for this state space. Throws an exception if failures are found.  <a href="#a24f53aa590e5054a150861d2d1689522">More...</a><br /></td></tr>
<tr class="separator:a24f53aa590e5054a150861d2d1689522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bf3d53b9a2292d1df64f9908980fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a332bf3d53b9a2292d1df64f9908980fb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a332bf3d53b9a2292d1df64f9908980fb">sanityChecks</a> () const </td></tr>
<tr class="memdesc:a332bf3d53b9a2292d1df64f9908980fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that allows derived state spaces to choose which checks should pass (see SanityChecks flags) and how strict the checks are. This just calls <a class="el" href="classompl_1_1base_1_1StateSpace.html#a24f53aa590e5054a150861d2d1689522" title="Perform sanity checks for this state space. Throws an exception if failures are found. ">sanityChecks()</a> with some default arguments. <br /></td></tr>
<tr class="separator:a332bf3d53b9a2292d1df64f9908980fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d094a956a3819951ea60233ec5d5d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d094a956a3819951ea60233ec5d5d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ac9d094a956a3819951ea60233ec5d5d9">diagram</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac9d094a956a3819951ea60233ec5d5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a Graphviz digraph that represents the containment diagram for the state space. <br /></td></tr>
<tr class="separator:ac9d094a956a3819951ea60233ec5d5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf040ebe3877e36856fa4370434f61b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf040ebe3877e36856fa4370434f61b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#aaf040ebe3877e36856fa4370434f61b5">list</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aaf040ebe3877e36856fa4370434f61b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of all contained state space instances. <br /></td></tr>
<tr class="separator:aaf040ebe3877e36856fa4370434f61b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925ed4f0e97f137b4c2128afe9f36b2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a925ed4f0e97f137b4c2128afe9f36b2f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#a925ed4f0e97f137b4c2128afe9f36b2f">Diagram</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:a925ed4f0e97f137b4c2128afe9f36b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a Graphviz digraph that represents the containment diagram for all the instantiated state spaces. <br /></td></tr>
<tr class="separator:a925ed4f0e97f137b4c2128afe9f36b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab5334644d6c9f8538f59a21bec854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3ab5334644d6c9f8538f59a21bec854"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1StateSpace.html#ad3ab5334644d6c9f8538f59a21bec854">List</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ad3ab5334644d6c9f8538f59a21bec854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of available state space instances. <br /></td></tr>
<tr class="separator:ad3ab5334644d6c9f8538f59a21bec854"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Representation of a space in which planning can be performed. Topology specific sampling, interpolation and distance are defined. </p>
<p>See <a class="el" href="implementingStateSpaces.html">Implementing State Spaces</a>. </p>

<p>Definition at line <a class="el" href="StateSpace_8h_source.html#l00073">73</a> of file <a class="el" href="StateSpace_8h_source.html">StateSpace.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classompl_1_1base_1_1StateSpace.html#a64feddc33bb3b7459c4f589e6cd9d17e">ompl::base::StateSpace::SanityChecks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to use in a bit mask for state space sanity checks. Some basic checks do not have flags associated (they are always executed; for example, whether <a class="el" href="classompl_1_1base_1_1StateSpace.html#abff3478c3fc4da03c94d6f929f6ca7f9" title="Copy a state to another. The memory of source and destination should NOT overlap. ...">copyState()</a> works as expected) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea044307209c21e4830272ca52945a3062"></a>STATESPACE_DISTANCE_DIFFERENT_STATES&#160;</td><td class="fielddoc">
<p>Check whether the distances between non-equal states is strictly positive (<a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">StateSpace::distance()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea5acf49ce656838100e44ed7ee7321ab6"></a>STATESPACE_DISTANCE_SYMMETRIC&#160;</td><td class="fielddoc">
<p>Check whether the distance function is symmetric (<a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">StateSpace::distance()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea26a108232d6265a1cc8bcc642216a6cf"></a>STATESPACE_INTERPOLATION&#160;</td><td class="fielddoc">
<p>Check whether calling <a class="el" href="classompl_1_1base_1_1StateSpace.html#a4220070a3365dd973e09c251f3381107" title="Computes the state that lies at time t in [0, 1] on the segment that connects from state to to state...">StateSpace::interpolate()</a> works as expected. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea54e30ec7ef77f42f255951ac6be08f97"></a>STATESPACE_TRIANGLE_INEQUALITY&#160;</td><td class="fielddoc">
<p>Check whether the triangle inequality holds when using <a class="el" href="classompl_1_1base_1_1StateSpace.html#a4220070a3365dd973e09c251f3381107" title="Computes the state that lies at time t in [0, 1] on the segment that connects from state to to state...">StateSpace::interpolate()</a> and <a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">StateSpace::distance()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea0134f2a38473e775c3037fde1c336d3f"></a>STATESPACE_DISTANCE_BOUND&#160;</td><td class="fielddoc">
<p>Check whether the <a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">StateSpace::distance()</a> is bounded by StateSpace::getExtent() </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea3c050038b3403113c40e3485398a9b18"></a>STATESPACE_RESPECT_BOUNDS&#160;</td><td class="fielddoc">
<p>Check whether sampled states are always within bounds. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17eafb4e9823a65ace5477bcc1cfc267b3fc"></a>STATESPACE_ENFORCE_BOUNDS_NO_OP&#160;</td><td class="fielddoc">
<p>Check that <a class="el" href="classompl_1_1base_1_1StateSpace.html#a7a52d4000174091df038c603078add78" title="Bring the state within the bounds of the state space. For unbounded spaces this function can be a no-...">enforceBounds()</a> does not modify the contents of states that are within bounds. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a64feddc33bb3b7459c4f589e6cd9d17ea88b4708168876d0b1b010e40285c1cc1"></a>STATESPACE_SERIALIZATION&#160;</td><td class="fielddoc">
<p>Check whether the <a class="el" href="classompl_1_1base_1_1StateSpace.html#a842fb601d28735dd56a2480dbb460662" title="Write the binary representation of state to serialization. ">StateSpace::serialize()</a> and <a class="el" href="classompl_1_1base_1_1StateSpace.html#aea2d2ac9a93fea0a269382daf585e68a" title="Read the binary representation of a state from serialization and write it to state. ">StateSpace::deserialize()</a> work as expected. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="StateSpace_8h_source.html#l00131">131</a> of file <a class="el" href="StateSpace_8h_source.html">StateSpace.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afd88dea5b056dae47158f22edb21e562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* ompl::base::StateSpace::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this instance to a desired type. </p>
<p>Make sure the type we are casting to is indeed a state space </p>

<p>Definition at line <a class="el" href="StateSpace_8h_source.html#l00087">87</a> of file <a class="el" href="StateSpace_8h_source.html">StateSpace.h</a>.</p>

</div>
</div>
<a class="anchor" id="a97f4c7086d9f337752ba1522d2dc5b3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* ompl::base::StateSpace::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this instance to a desired type. </p>
<p>Make sure the type we are casting to is indeed a state space </p>

<p>Definition at line <a class="el" href="StateSpace_8h_source.html#l00097">97</a> of file <a class="el" href="StateSpace_8h_source.html">StateSpace.h</a>.</p>

</div>
</div>
<a class="anchor" id="abff3478c3fc4da03c94d6f929f6ca7f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ompl::base::StateSpace::copyState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a state to another. The memory of source and destination should NOT overlap. </p>
<dl class="section note"><dt>Note</dt><dd>For more advanced state copying methods (partial copy, for example), see <a class="el" href="group__advancedStateCopy.html">Advanced methods for copying states</a>. </dd></dl>

<p>Implemented in <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a4dbc38743832260896d42d89e0b3feec">ompl::base::CompoundStateSpace</a>, <a class="el" href="classompl_1_1control_1_1OpenDEStateSpace.html#a7c83c791c78bf85d1422e37e1a3487c1">ompl::control::OpenDEStateSpace</a>, <a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html#a2304bbddd850d5b10eaa70142547b67d">ompl::base::RealVectorStateSpace</a>, <a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#aaa6d4c230754e68138e518518c01f752">ompl::base::CForestStateSpaceWrapper</a>, <a class="el" href="classompl_1_1base_1_1SO3StateSpace.html#a013547ae0375ec0a158cdefe71b670c3">ompl::base::SO3StateSpace</a>, <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#a9b9515b09b9468cbbb066966a8536b95">ompl::base::TimeStateSpace</a>, <a class="el" href="classompl_1_1base_1_1MorseStateSpace.html#aa53cbd66370a518c11ed8cd2d1868de1">ompl::base::MorseStateSpace</a>, <a class="el" href="classompl_1_1base_1_1DiscreteStateSpace.html#a6ce8e181f39cff7ccab6ac5ae2f9cafd">ompl::base::DiscreteStateSpace</a>, and <a class="el" href="classompl_1_1base_1_1SO2StateSpace.html#afa370ede45deafe06b4217cf2641b610">ompl::base::SO2StateSpace</a>.</p>

</div>
</div>
<a class="anchor" id="af7a72168397b61ee33c0f2bf98ced2e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ompl::base::StateSpace::getMaximumExtent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum value a call to <a class="el" href="classompl_1_1base_1_1StateSpace.html#acb781becdcdf8770d61c218632c71bd5" title="Computes distance between two states. This function satisfies the properties of a metric if isMetricS...">distance()</a> can return (or an upper bound). For unbounded state spaces, this function can return infinity. </p>
<dl class="section note"><dt>Note</dt><dd>Tight upper bounds are preferred because the value of the extent is used in the automatic computation of parameters for planning. If the bounds are less tight, the automatically computed parameters will be less useful. </dd></dl>

<p>Implemented in <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a49e40317c4c6ed599f2f56fa40f7f28a">ompl::base::CompoundStateSpace</a>, <a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html#a6bba8c34051ad558739f8beecaa9c647">ompl::base::RealVectorStateSpace</a>, <a class="el" href="classompl_1_1base_1_1SO3StateSpace.html#a539a00cf767a8db9b72498211bb12d39">ompl::base::SO3StateSpace</a>, <a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#afdb62e6a19cf8b81bc4492f44bd04b0b">ompl::base::CForestStateSpaceWrapper</a>, <a class="el" href="classompl_1_1base_1_1DiscreteStateSpace.html#a4a3a24cbf9f5c888b121eb0b4652f99d">ompl::base::DiscreteStateSpace</a>, <a class="el" href="classompl_1_1base_1_1SO2StateSpace.html#a5e8c7bcf005fba03d9f6afca287669a5">ompl::base::SO2StateSpace</a>, and <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#ae7b29110da89f97709a4d259e02a368f">ompl::base::TimeStateSpace</a>.</p>

</div>
</div>
<a class="anchor" id="a8584afb9165d2aa7408fec81c18659f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * ompl::base::StateSpace::getValueAddressAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classompl_1_1base_1_1State.html">State</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Many states contain a number of double values. This function provides a means to get the memory address of a double value from state <em>state</em> located at position <em>index</em>. The first double value is returned for <em>index</em> = 0. If <em>index</em> is too large (does not point to any double values in the state), the return value is NULL. </p>
<dl class="section note"><dt>Note</dt><dd>This function does <b>not</b> map a state to an array of doubles. There may be components of a state that do not correspond to double values and they are 'invisible' to this function. Furthermore, this function is <b>slow</b> and is not intended for use in the implementation of planners. Ideally, state values should not be accessed by index. If accessing of individual state elements is however needed, <a class="el" href="classompl_1_1base_1_1StateSpace.html#a1440136336d3b92067e77b8586db5448" title="Get a pointer to the double value in state that loc points to. ">getValueAddressAtLocation()</a> provides a faster implementation. </dd></dl>

<p>Reimplemented in <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#a88d40189fcde811ba620ebc96af33901">ompl::base::CompoundStateSpace</a>, <a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#a8491c414dbee1689e61be300e6b6d7a7">ompl::base::CForestStateSpaceWrapper</a>, <a class="el" href="classompl_1_1base_1_1RealVectorStateSpace.html#aa263419b2d378049b3315286413d5a2f">ompl::base::RealVectorStateSpace</a>, <a class="el" href="classompl_1_1base_1_1SO3StateSpace.html#a01bdc2556f215089743cd8d0114dc0fa">ompl::base::SO3StateSpace</a>, <a class="el" href="classompl_1_1base_1_1TimeStateSpace.html#af90393504dc7f6a8f7eb335aadc6d590">ompl::base::TimeStateSpace</a>, and <a class="el" href="classompl_1_1base_1_1SO2StateSpace.html#ae7e2c0c9d3fbe8cb0cbfbc61952d815e">ompl::base::SO2StateSpace</a>.</p>

<p>Definition at line <a class="el" href="StateSpace_8cpp_source.html#l00298">298</a> of file <a class="el" href="StateSpace_8cpp_source.html">StateSpace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae51ca6eb429ff4f3bb0cf2f485b5f340"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ompl::base::StateSpace::isDiscrete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the set of states is discrete. </p>
<dl class="section note"><dt>Note</dt><dd>In fact, because of limited numerical precision, the representation of all spaces is discrete; this function returns true if the corresponding mathematical object is a discrete one. </dd></dl>

<p>Reimplemented in <a class="el" href="classompl_1_1base_1_1DiscreteStateSpace.html#a917636cbbddf9d738ec96510ff7ad749">ompl::base::DiscreteStateSpace</a>, and <a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#af283f20fea5da6b2d4f696d619c463a5">ompl::base::CForestStateSpaceWrapper</a>.</p>

<p>Definition at line <a class="el" href="StateSpace_8cpp_source.html#l00755">755</a> of file <a class="el" href="StateSpace_8cpp_source.html">StateSpace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24f53aa590e5054a150861d2d1689522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::StateSpace::sanityChecks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sanity checks for this state space. Throws an exception if failures are found. </p>
<dl class="section note"><dt>Note</dt><dd>This checks if distances are always positive, whether the integration works as expected, etc. </dd></dl>

<p>Reimplemented in <a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#a50fc0e1c36f94b5c3503fc09d49cc403">ompl::base::CForestStateSpaceWrapper</a>.</p>

<p>Definition at line <a class="el" href="StateSpace_8cpp_source.html#l00597">597</a> of file <a class="el" href="StateSpace_8cpp_source.html">StateSpace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8e6450ad306d272df39751aa7e690b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::StateSpace::setLongestValidSegmentFraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>segmentFraction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When performing discrete validation of motions, the length of the longest segment that does not require state validation needs to be specified. This function sets this length as a fraction of the space's maximum extent. </p>
<dl class="section note"><dt>Note</dt><dd>This function's effect is not considered until after <a class="el" href="classompl_1_1base_1_1StateSpace.html#a92ca030ac21b5aa209241febcfbae2e7" title="Perform final setup steps. This function is automatically called by the SpaceInformation. If any default projections are to be registered, this call will set them and call their setup() functions. It is safe to call this function multiple times. At a subsequent call, projections that have been previously user configured are not re-instantiated, but their setup() method is still called. ">setup()</a> has been called. For immediate effects (i.e., during planning) use <a class="el" href="classompl_1_1base_1_1StateSpace.html#a9babd71497fc6a6f82fe97f699531ceb" title="Set factor to be the value to multiply the return value of validSegmentCount(). By default...">setValidSegmentCountFactor()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classompl_1_1base_1_1CompoundStateSpace.html#ac07e99d9d6749436e4e3549023ae96fe">ompl::base::CompoundStateSpace</a>, and <a class="el" href="classompl_1_1base_1_1CForestStateSpaceWrapper.html#a65a75002cb76ff366b7f12b70cdba2f3">ompl::base::CForestStateSpaceWrapper</a>.</p>

<p>Definition at line <a class="el" href="StateSpace_8cpp_source.html#l00812">812</a> of file <a class="el" href="StateSpace_8cpp_source.html">StateSpace.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ompl/base/<a class="el" href="StateSpace_8h_source.html">StateSpace.h</a></li>
<li>ompl/base/src/<a class="el" href="StateSpace_8cpp_source.html">StateSpace.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated on Tue Jun 2 2015 19:05:22 by&#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.9.1</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="js/jquery.js"></script>
<script src="js/jquery.powertip.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/dynsections.js"></script>
<script src="js/ompl.js"></script>
</body>
</html>
