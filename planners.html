<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Ioan A. Șucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.9.3"/>
  <title>Available Planners</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="jquery.js"></script>
  <script src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-expand-md fixed-top navbar-dark">
      <a class="navbar-brand" href="./index.html">OMPL</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
          <li class="nav-item"><a class="nav-link" href="download.html">Download</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="docDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Documentation</a>
            <div class="dropdown-menu" aria-labelledby="docDropdown">
              <a class="dropdown-item" href="https://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a>
              <a class="dropdown-item" href="installation.html">Installation</a>
              <a class="dropdown-item" href="tutorials.html">Tutorials</a>
              <a class="dropdown-item" href="group__demos.html">Demos</a>
              <a class="dropdown-item omplapp" href="gui.html">OMPL.app GUI</a>
              <a class="dropdown-item omplapp" href="webapp.html">OMPL web app</a>
              <a class="dropdown-item" href="python.html">Python Bindings</a>
              <a class="dropdown-item" href="planners.html">Available Planners</a>
              <a class="dropdown-item" href="plannerTerminationConditions.html">Planner Termination Conditions</a>
              <a class="dropdown-item" href="benchmark.html">Benchmarking Planners</a>
              <a class="dropdown-item" href="spaces.html">Available State Spaces</a>
              <a class="dropdown-item" href="optimalPlanning.html">Optimal Planning</a>
              <a class="dropdown-item" href="constrainedPlanning.html">Constrained Planning</a>
              <a class="dropdown-item" href="multiLevelPlanning.html">Multilevel Planning</a>
              <a class="dropdown-item" href="FAQ.html">FAQ</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">External links</div>
              <a class="dropdown-item" href="http://moveit.ros.org">MoveIt</a>
              <a class="dropdown-item" href="http://plannerarena.org">Planner Arena</a>
              <a class="dropdown-item" href="https://moveit.ros.org//moveit!/ros/2013/05/07/icra-motion-planning-tutorial.html">ICRA 2013 Tutorial</a>
              <a class="dropdown-item" href="http://kavrakilab.org/iros2011/">IROS 2011 Tutorial</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="gallery.html">Gallery</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="codeDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Code</a>
            <div class="dropdown-menu" aria-labelledby="codeDropdown">
              <a class="dropdown-item" href="api_overview.html">API Overview</a>
              <a class="dropdown-item" href="annotated.html">Classes</a>
              <a class="dropdown-item" href="files.html">Files</a>
              <a class="dropdown-item" href="styleGuide.html">Style Guide</a>
              <a class="dropdown-item" href="integration.html">Use OMPL within Other Systems</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">Repositories</div>
              <a class="dropdown-item" href="https://github.com/ompl/ompl">ompl on GitHub</a>
              <a class="dropdown-item" href="https://github.com/ompl/omplapp">omplapp on GitHub</a>
              <div class="dropdown-divider"></div>
              <div class="dropdown-header">Continuous Integration</div>
              <a class="dropdown-item" href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux/macOS)</a>
              <a class="dropdown-item" href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux/macOS)</a>
              <a class="dropdown-item" href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a>
              <a class="dropdown-item" href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://github.com/ompl/ompl/issues">Issues</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="communityDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Community</a>
            <div class="dropdown-menu" aria-labelledby="communityDropdown">
              <a class="dropdown-item" href="support.html">Get Support</a>
              <a class="dropdown-item" href="developers.html">Developers/Contributors</a>
              <a class="dropdown-item" href="contrib.html">Submit a Contribution</a>
              <a class="dropdown-item" href="education.html">Education</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="aboutDropdown" role="button"  data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">About</a>
            <div class="dropdown-menu" aria-labelledby="aboutDropdown">
              <a class="dropdown-item" href="license.html">License</a>
              <a class="dropdown-item" href="citations.html">Citations</a>
              <a class="dropdown-item" href="acknowledgements.html">Acknowledgments</a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://ompl.kavrakilab.org/blog.html">Blog</a></li>
        </ul>
                <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </div>
    </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Available Planners </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_ompl_doc_markdown_planners"></a> All implementations listed below are considered fully functional. Within OMPL planners are divided into three categories:</p><ul>
<li><a class="el" href="planners.html#geometric_planners">Geometric planners</a></li>
<li><a class="el" href="planners.html#control_planners">Control-based planners</a></li>
<li><a class="el" href="planners.html#multilevel_planners">Multilevel-based planners</a></li>
</ul>
<p>To see how to benchmark planners, click <a href="benchmark.html">here</a>.</p>
<h1><a class="anchor" id="geometric_planners"></a>
Geometric planners</h1>
<p >Planners in this category only accounts for the geometric and kinematic constraints of the system. It is assumed that any feasible path can be turned into a dynamically feasible trajectory. Any of these planners can be used to <a href="constrainedPlanning.html">plan with geometric constraints</a>. Planners in this category can be divided into several overlapping subcategories:</p>
<div class="plannerlist"><ul>
<li><b>Multi-query planners</b><br  />
 These planners build a roadmap of the entire environment that can be used for multiple queries.<ul>
<li><a class="el" href="classompl_1_1geometric_1_1PRM.html#gPRM">Probabilistic Roadmap Method (PRM)</a><br  />
 This is the sampling-based algorithm. Our implementation uses one thread to construct a roadmap while a second thread checks whether a path exists in the roadmap between a start and goal state. OMPL contains a number of variants of PRM:<ul>
<li><a class="el" href="classompl_1_1geometric_1_1LazyPRM.html#gLazyPRM">LazyPRM</a><br  />
 This planner is similar to regular PRM, but checks the validity of a vertex or edge “lazily,” i.e., only when it is part of a candidate solution path.</li>
<li><a class="el" href="classompl_1_1geometric_1_1PRMstar.html#gPRMstar">PRM*</a><br  />
 While regular PRM attempts to connect states to a fixed number of neighbors, PRM* gradually increases the number of connection attempts as the roadmap grows in a way that provides convergence to the optimal path.</li>
<li><a class="el" href="classompl_1_1geometric_1_1LazyPRMstar.html#gLazyPRMstar">LazyPRM*</a><br  />
 A version of PRM* with lazy state validity checking.</li>
</ul>
</li>
<li><a class="el" href="classompl_1_1geometric_1_1SPARS.html#gSPARS">SPArse Roadmap Spanner algorithm (SPARS)</a><br  />
 SPARS is a planner that provides asymptotic <em>near</em>-optimality (a solution that is within a constant factor of the optimal solution) and includes a meaningful stopping criterion. Although (because?) it does not guarantee optimality, its convergence rate tends to be much higher than PRM*.</li>
<li><a class="el" href="classompl_1_1geometric_1_1SPARStwo.html#gSPARStwo">SPARS2</a><br  />
 SPARS2 is variant of the SPARS algorithm that works through similar mechanics, but uses a different approach to identifying interfaces and computing shortest paths through said interfaces.</li>
</ul>
</li>
<li><b>Single-query planners</b><br  />
 These planners typically grow a tree of states connected by valid motions. These planners differ in the heuristics they use to control <em>where</em> and <em>how</em> the tree is expanded. Some tree-based planners grow <em>two</em> trees: one from the start and one from the goal. Such planners will attempt to connect a state in the start tree with another state in the goal tree.<ul>
<li><a class="el" href="classompl_1_1geometric_1_1RRT.html#gRRT">Rapidly-exploring Random Trees (RRT)</a><br  />
 This is one of the first single query planners. The algorithm is easy to understand and easy to implement. Many, many variants of RRT have been proposed. OMPL contains several RRT variants:<ul>
<li><a class="el" href="classompl_1_1geometric_1_1RRTConnect.html#gRRTC">RRT Connect (RRTConnect)</a><br  />
 This planner is a bidirectional version of RRT (i.e., it grows two trees). It usually outperforms the original RRT algorithm.</li>
<li><a class="el" href="classompl_1_1geometric_1_1RRTstar.html#gRRTstar">RRT*</a><br  />
 An asymptotically optimal version of RRT: the algorithm converges on the optimal path as a function of time. This was the first provably asymptotically planner (together with PRM). Since its publication, several other algorithms have appeared that improve on RRT*'s convergence rate, such as <a class="el" href="classompl_1_1geometric_1_1RRTsharp.html#gRRTsharp">RRT#</a> and <a class="el" href="classompl_1_1geometric_1_1RRTXstatic.html#gRRTXstatic">RRTX</a>.</li>
<li><a class="el" href="classompl_1_1geometric_1_1LBTRRT.html#gLBTRRT">Lower Bound Tree RRT (LBTRRT)</a><br  />
 LBTRRT is a asymptotically near-optimal version of RRT: it is guaranteed to converge to a solution that is within a constant factor of the optimal solution.</li>
<li><a class="el" href="classompl_1_1geometric_1_1SST.html#gSST">Sparse Stable RRT</a><br  />
 SST is an asymptotically near-optimal incremental version of RRT.</li>
<li><a class="el" href="classompl_1_1geometric_1_1TRRT.html#gTRRT">Transition-based RRT (T-RRT)</a><br  />
 T-RRT does not give any hard optimality guarantees, but tries to find short, low-cost paths.</li>
<li><a class="el" href="classompl_1_1geometric_1_1VFRRT.html#gVFRRT">Vector Field RRT</a><br  />
 VF-RRT is a tree-based motion planner that tries to minimize the so-called upstream cost of a path. The upstream cost is defined by an integral over a user-defined vector field.</li>
<li><a class="el" href="classompl_1_1geometric_1_1pRRT.html#gpRRT">Parallel RRT (pRRT)</a><br  />
 Many different parallelization schemes have been proposed for sampling-based planners, including RRT. In this implementation, several threads simultaneously add states to the same tree. Once a solution is found, all threads terminate.</li>
<li><a class="el" href="classompl_1_1geometric_1_1LazyRRT.html#gLazyRRT">Lazy RRT (LazyRRT)</a><br  />
 This planner performs lazy state validity checking (similar to LazyPRM). It is not experimental, but in our experience it does not seem to outperform other planners by a significant margin on any class of problems.</li>
<li><a class="el" href="classompl_1_1geometric_1_1TSRRT.html#gTSRRT">Task-space RRT (TSRRT)</a><br  />
 TSRRT is a variant of RRT where exploration is guided by the task space. It requires an <a class="el" href="classompl_1_1geometric_1_1TaskSpaceConfig.html">ompl::geometric::TaskSpaceConfig</a> instance that defines how to project configuration space states to the task spaces and an inverse operation to lift task space states to the configuration space.</li>
</ul>
</li>
<li><a class="el" href="classompl_1_1geometric_1_1EST.html#gEST">Expansive Space Trees (EST)</a><br  />
 This planner was published around the same time as RRT. In our experience it is not as sensitive to having a good distance measure, which can be difficult to define for complex high-dimensional state spaces. There are actually three versions of EST: the <a class="el" href="classompl_1_1geometric_1_1EST.html#gEST">original version</a> that is close to the first publication, <a class="el" href="classompl_1_1geometric_1_1BiEST.html#gBiEST">a bidirectional version</a>, and a <a class="el" href="classompl_1_1geometric_1_1ProjEST.html#gProjEST">projection-based version</a>. The low-dimensional projection is used to keep track of how the state space has been explored. Most of the time OMPL can automatically determine a reasonable projection. We have implemented a few planners that not necessarily simple variants of EST, but do share the same expansion strategy:<ul>
<li><a class="el" href="classompl_1_1geometric_1_1SBL.html#gSBL">Single-query Bi-directional Lazy collision checking planner (SBL)</a><br  />
 This planner is essentially a bidirectional version of EST with lazy state validity checking.</li>
<li><a class="el" href="classompl_1_1geometric_1_1pSBL.html#gpSBL">Parallel Single-query Bi-directional Lazy collision checking planner (pSBL)</a><br  />
 This planner grows the two trees in SBL with multiple threads in parallel.</li>
</ul>
</li>
<li><a class="el" href="classompl_1_1geometric_1_1KPIECE1.html#gKPIECE1">Kinematic Planning by Interior-Exterior Cell Exploration (KPIECE)</a><br  />
 KPIECE is a tree-based planner that uses a discretization (multiple levels, in general) to guide the exploration of the (continuous) state space. OMPL's implementation is a simplified one, using a single level of discretization: one grid. The grid is imposed on a <em>projection</em> of the state space. When exploring the space, preference is given to the boundary of that part of the grid that has been explored so far. The boundary is defined to be the set of grid cells that have fewer than 2<em>n</em> non-diagonal non-empty neighboring grid cells in an <em>n</em>-dimensional projection space. There are two variants of KPIECE:<ul>
<li><a class="el" href="classompl_1_1geometric_1_1BKPIECE1.html#gBKPIECE1">Bi-directional KPIECE (BKPIECE)</a></li>
<li><a class="el" href="classompl_1_1geometric_1_1LBKPIECE1.html#gLBKPIECE1">Lazy Bi-directional KPIECE (LBKPIECE)</a></li>
</ul>
</li>
<li><a class="el" href="classompl_1_1geometric_1_1STRIDE.html#gSTRIDE">Search Tree with Resolution Independent Density Estimation (STRIDE)</a><br  />
 This planner was inspired by EST. Instead of using a projection, STRIDE uses a <a class="el" href="classompl_1_1NearestNeighborsGNAT.html">Geometric Near-neighbor Access Tree</a> to estimate sampling density directly in the state space. STRIDE is a useful for high-dimensional systems where the free space cannot easily be captured with a low-dimensional (linear) projection.</li>
<li><a class="el" href="classompl_1_1geometric_1_1PDST.html#gPDST">Path-Directed Subdivision Trees (PDST)</a><br  />
 PDST is a planner that has entirely removed the dependency on a distance measure, which is useful in cases where a good distance metric is hard to define. PDST maintains a binary space partitioning such that motions are completely contained within one cell of the partition. The density of motions per cell is used to guide expansion of the tree.</li>
<li><a class="el" href="classompl_1_1geometric_1_1FMT.html#gFMT">Fast Marching Tree algorithm (FMT∗)</a><br  />
 The FMT∗ algorithm performs a “lazy” dynamic programming recursion on a set of probabilistically-drawn samples to grow a tree of paths, which moves outward in cost-to-come space. Unlike all other planners, the numbers of valid samples needs to be chosen beforehand.</li>
<li><a class="el" href="classompl_1_1geometric_1_1BFMT.html#gBFMT">Bidirectional Fast Marching Tree algorithm (BFMT∗)</a><br  />
 Executes two FMT* trees, one from the start and another one from the goal resulting in a faster planner as it explores less space.</li>
</ul>
</li>
<li><b>Multi-level planners</b><br  />
 Planning algorithms which can exploit multiple levels of abstractions. If you want to use them, you should call them with a vector of <code><a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html" title="A shared pointer wrapper for ompl::base::SpaceInformation.">ompl::base::SpaceInformationPtr</a></code>. All planner then guarantee probabilistic completeness, if the supplied abstractions are admissible. There is extensive documentation in the form of a <a href="multiLevelPlanning.html">guide</a>, <a href="multiLevelPlanningTutorial.html">tutorial</a> and <a href="group__demos.html">demos</a>.<ul>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QRRT">Rapidly-exploring Random Quotient space Trees (QRRT)</a><br  />
 A generalization of RRT to plan on different abstraction levels.</li>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QRRTstar">QRRT*</a><br  />
 An asymptotically optimal version of QRRT</li>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QMP">Quotient-Space Roadmap Planner (QMP)</a><br  />
 A generalization of PRM to plan on different abstraction levels.</li>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QMPstar">QMP*</a><br  />
 An asymptotically optimal version of QMP</li>
</ul>
</li>
<li><b>Optimizing planners</b><br  />
 In recent years several sampling-based planning algorithms have been proposed that still provide some optimality guarantees. Typically, an optimal solution is assumed to be shortest path. In OMPL we have a more general framework for expressing the cost of states and paths that allows you to, e.g., maximize the minimum clearance along a path, minimize the mechanical work, or some arbitrary user-defined optimization criterion. See <a class="el" href="optimalPlanning.html">Optimal Planning</a> for more information. Some of the planners below use this general cost framework, but keep in mind that convergence to optimality is <b>not guaranteed</b> when optimizing over something other than path length.<ul>
<li><a class="el" href="classompl_1_1geometric_1_1PRMstar.html#gPRMstar">PRM*</a><br  />
 An asymptotically optimal version of PRM; <em>uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1LazyPRMstar.html#gLazyPRMstar">LazyPRM*</a><br  />
 Lazy version of PRM*; <em>uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1RRTstar.html#gRRTstar">RRT*</a><br  />
 An asymptotically optimal version of RRT; <em>uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1RRTsharp.html#gRRTsharp">RRT#</a><br  />
 A variant of RRT* with an improved convergence rate. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1RRTXstatic.html#gRRTXstatic">RRTX</a><br  />
 A variant of RRT* with an improved convergence rate. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1InformedRRTstar.html#gInformedRRTstar">Informed RRT*</a><br  />
 A variant of RRT* that uses heuristics to bound the search for optimal solutions. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1BITstar.html#gBITstar">Batch Informed Trees (BIT*)</a><br  />
 An anytime asymptotically optimal algorithm that uses heuristics to order and bound the search for optimal solutions. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1ABITstar.html#gABITstar">Advanced BIT* (ABIT*)</a><br  />
 An extension to BIT* that uses advanced graph-search techniques to find initial solutions faster. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1AITstar.html#gAITstar">Adaptively Informed Trees (AIT*)</a><br  />
 An anytime asymptotically optimal algorithm that simultaneously estimates and exploits problem-specific heuristics. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1LBTRRT.html#gLBTRRT">Lower Bound Tree RRT (LBTRRT)</a><br  />
 An asymptotically near-optimal version of RRT.</li>
<li><a class="el" href="classompl_1_1geometric_1_1SST.html#gSST">Sparse Stable RRT</a><br  />
 SST is an asymptotically near-optimal incremental version of RRT.</li>
<li><a class="el" href="classompl_1_1geometric_1_1TRRT.html#gTRRT">Transition-based RRT (T-RRT)</a><br  />
 T-RRT does not give any hard optimality guarantees, but tries to find short, low-cost paths. <em>It uses the general cost framework.</em></li>
<li><a class="el" href="classompl_1_1geometric_1_1SPARS.html#gSPARS">SPARS</a><br  />
 An asymptotically near-optimal roadmap-based planner.</li>
<li><a class="el" href="classompl_1_1geometric_1_1SPARStwo.html#gSPARStwo">SPARS2</a><br  />
 An asymptotically near-optimal roadmap-based planner.</li>
<li><a class="el" href="classompl_1_1geometric_1_1FMT.html#gFMT">FMT*</a><br  />
 An asymptotically optimal tree-based planner.</li>
<li><a class="el" href="classompl_1_1geometric_1_1STRRTstar.html#gSTRRTstar">ST-RRT*</a><br  />
 a bidirectional, time-optimal planner for planning in space-time.</li>
<li><a class="el" href="classompl_1_1geometric_1_1CForest.html#gCForest">CForest</a><br  />
 A meta-planner that runs several instances of asymptotically optimal planners in different threads. When one thread finds a better solution path, the states along the path are passed on to the other threads.</li>
<li><a class="el" href="classompl_1_1geometric_1_1AnytimePathShortening.html#gAPS">AnytimePathShortening (APS)</a><br  />
 APS is a generic wrapper around one or more geometric motion planners that repeatedly applies <a class="el" href="classompl_1_1geometric_1_1PathSimplifier.html">shortcutting</a> and <a class="el" href="classompl_1_1geometric_1_1PathHybridization.html">hybridization</a> to a set of solution paths. Any number and combination of planners can be specified, each is run in a separate thread.</li>
</ul>
</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>How OMPL selects a geometric planner<br  />
 If you use the <a class="el" href="classompl_1_1geometric_1_1SimpleSetup.html" title="Create the set of classes typically needed to solve a geometric problem.">ompl::geometric::SimpleSetup</a> class (highly recommended) to define and solve your motion planning problem, then OMPL will automatically select an appropriate planner (unless you have explicitly specified one). If the state space has a default projection (which is going to be the case if you use any of the built-in state spaces), then it will use <a class="el" href="classompl_1_1geometric_1_1LBKPIECE1.html#gLBKPIECE1">LBKPIECE</a> if a bidirectional planner can be used and otherwise it will use <a class="el" href="classompl_1_1geometric_1_1KPIECE1.html#gKPIECE1">KPIECE</a>. These planners have been shown to work well consistently across many real-world motion planning problems, which is why these planners are the default choice. In case the state space has no default projection, <a class="el" href="classompl_1_1geometric_1_1RRTConnect.html#gRRTC">RRTConnect</a> or regular <a class="el" href="classompl_1_1geometric_1_1RRT.html#gRRT">RRT</a> will be used, depending on whether a bidirectional planner can be used. The notion of a goal is very general in OMPL: it may not even be possible to sample a state that satisfies the goal, in which case OMPL cannot grow a second tree at a goal state.</dd>
<dd>
Feasibility and Optimality<br  />
 The line between feasible and optimal planners is not so black and white in practice. The line between them can be blurred with an appropriate <a class="el" href="classompl_1_1base_1_1PlannerTerminationCondition.html" title="Encapsulate a termination condition for a motion planner. Planners will call operator() to decide whe...">ompl::base::PlannerTerminationCondition</a>. For instance, the <a class="el" href="namespaceompl_1_1base.html#a71261936b94c44c59a9f26168b30ea1f" title="Return a termination condition that will become true as soon as the problem definition has an exact s...">ompl::base::exactSolnPlannerTerminationCondition</a> function returns a termination condition that causes optimizing planners to terminate once the first solution is found. As another example, using a <a class="el" href="classompl_1_1base_1_1CostConvergenceTerminationCondition.html" title=": A termination condition for stopping an optimizing planner based on cost convergence">ompl::base::CostConvergenceTerminationCondition</a> with parameters <code>solutionsWindow=10</code> and <code>epsilon=1</code>, causes an optimizing planner to terminate when <em>exactly</em> 10 solutions have been found. You can use <a class="el" href="namespaceompl_1_1base.html#a743743b4754208eb83ecb3ab20e4df4c" title="Combine two termination conditions into one. If either termination condition returns true,...">ompl::base::plannerOrTerminationCondition</a> and <a class="el" href="namespaceompl_1_1base.html#a6fe113eda8e4fb7306a5849f392db50b" title="Combine two termination conditions into one. Both termination conditions need to return true for this...">ompl::base::plannerAndTerminationCondition</a> to combine planner termination conditions (e.g., “terminate when either 10 solutions have been found <b>or</b> a time limit of 10 seconds is exceeded”). See <a class="el" href="plannerTerminationConditions.html">Planner Termination Conditions</a> for details.</dd></dl>
</div> <div></div><div></div><h2><a class="anchor" id="autotoc_md119"></a>
Other tools:</h2>
<div><ul>
<li><a class="el" href="classompl_1_1geometric_1_1HillClimbing.html#HillClimbing">Hill Climbing</a></li>
<li><a class="el" href="classompl_1_1geometric_1_1GeneticSearch.html#GeneticSearch">Genetic Search</a></li>
</ul>
</div><div></div><h1><a class="anchor" id="control_planners"></a>
Control-based planners</h1>
<div class="plannerlist"> If the system under consideration is subject to differential constraints, then a control-based planner is used. These planners rely on <a class="el" href="classompl_1_1control_1_1StatePropagator.html">state propagation</a> rather than simple interpolation to generate motions. These planners do not require <a class="el" href="classompl_1_1control_1_1StatePropagator.html#acc52d20ab1da84b020aa3dbe5579769e">a steering function</a>, but all of them (except KPIECE) will use it if the user implements it. The first two planners below are kinodynamic adaptations of the corresponding geometric planners above.<ul>
<li><a class="el" href="classompl_1_1control_1_1RRT.html#cRRT">Rapidly-exploring Random Trees (RRT)</a></li>
<li><a class="el" href="classompl_1_1control_1_1SST.html#cSST">Sparse Stable RRT</a><br  />
 SST is an asymptotically near-optimal incremental version of RRT.</li>
<li><a class="el" href="classompl_1_1control_1_1EST.html#cEST">Expansive Space Trees (EST)</a></li>
<li><a class="el" href="classompl_1_1control_1_1KPIECE1.html#cKPIECE1">Kinodynamic Planning by Interior-Exterior Cell Exploration (KPIECE)</a><br  />
 As the name suggest, the control-based version of KPIECE came first, and the geometric versions were derived from it.</li>
<li><a class="el" href="classompl_1_1control_1_1PDST.html#cPDST">Path-Directed Subdivision Trees (PDST)</a><br  />
 The control-based version of PDST actually came before the geometric version. Given the control-based version it was straightforward to also implement a geometric version.</li>
<li><a class="el" href="classompl_1_1control_1_1Syclop.html#cSyclop">Syclop, a meta planner that uses other planners at a lower level</a><br  />
 Syclop is a meta-planner that combines a high-level guide computed over a decomposition of the state space with a low-level planning algorithm. The progress that the low-level planner makes is fed back to the high-level planner which uses this information to update the guide. There are two different versions of Syclop:<ul>
<li><a class="el" href="classompl_1_1control_1_1SyclopRRT.html#cSyclopRRT">Syclop using RRT as the low-level planner</a></li>
<li><a class="el" href="classompl_1_1control_1_1SyclopEST.html#cSyclopEST">Syclop using EST as the low-level planner</a></li>
</ul>
</li>
<li><a class="el" href="classompl_1_1control_1_1LTLPlanner.html#cLTLPlanner">Linear Temporal Logical Planner (LTLPlanner)</a><br  />
 LTLPlanner finds solutions for motion planning problems where the goal is specified by a Linear Temporal Logic (LTL) specification.</li>
</ul>
</div><div class="plannerlist"><dl class="section attention"><dt>Attention</dt><dd>How OMPL selects a control-based planner<br  />
 If you use the <a class="el" href="classompl_1_1control_1_1SimpleSetup.html" title="Create the set of classes typically needed to solve a control problem.">ompl::control::SimpleSetup</a> class (highly recommended) to define and solve your motion planning problem, then OMPL will automatically select an appropriate planner (unless you have explicitly specified one). If the state space has a default projection (which is going to be the case if you use any of the built-in state spaces), then it will use <a class="el" href="classompl_1_1control_1_1KPIECE1.html#cKPIECE1">KPIECE</a>. This planner has been shown to work well consistently across many real-world motion planning problems, which is why it is the default choice. In case the state space has no default projection, <a class="el" href="classompl_1_1control_1_1RRT.html#cRRT">RRT</a> will be used. Note that there are no bidirectional control-based planners, since we do not assume that there is a steering function that can connect two states <em>exactly</em>. </dd></dl>
</div><h1><a class="anchor" id="multilevel_planners"></a>
Multilevel-based planners</h1>
<div class="plannerlist"> <div class="plannerlist"> To solve problems involving high-dimensional state spaces, we often can use multilevel abstractions to simplify the state spaces, thereby allowing dedicated planner to quicker find solutions. The planner in this class support sequences of state spaces and can be utilized both for state spaces with geometric and dynamic constraints. There is extensive documentation in the form of a <a href="multiLevelPlanning.html">guide</a>, <a href="multiLevelPlanningTutorial.html">tutorial</a> and <a href="group__demos.html">demos</a>.<ul>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QRRT">Rapidly-exploring Random Quotient space Trees (QRRT)</a><br  />
 A generalization of RRT to plan on different abstraction levels.</li>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QRRTstar">QRRT*</a><br  />
 An asymptotically optimal version of QRRT</li>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QMP">Quotient-Space Roadmap Planner (QMP)</a><br  />
 A generalization of PRM to plan on different abstraction levels.</li>
<li><a class="el" href="namespaceompl_1_1multilevel.html#QMPstar">QMP*</a><br  />
 An asymptotically optimal version of QMP</li>
<li>Sparse Quotient space roadmap planner (SPQR)*<br  />
 A generalization of SPARS to multi-level planning.  </li>
</ul>
</div></div></div></div><!-- contents -->
</div><!-- PageDoc -->
</div>
<footer class="footer">
  <div class="container">
  <a href="http://www.kavrakilab.org">Kavraki Lab</a>  &bull;
  <a href="https://www.cs.rice.edu">Department of Computer Science</a> &bull;
  <a href="https://www.rice.edu">Rice University</a><br/>
  Funded in part by the <a href="https://www.nsf.gov">National Science Foundation</a><br/>
  Documentation generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.3
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
