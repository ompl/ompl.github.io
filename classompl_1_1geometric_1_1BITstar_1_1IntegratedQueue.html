<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl::geometric::BITstar::IntegratedQueue Class Reference</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <link href="css/tabs.css" rel="stylesheet">
  <link href="css/doxygen.css" rel="stylesheet">
  <link href="css/search.css" rel="stylesheet">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="css/ompl.css" rel="stylesheet">
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="search/searchdata.js"></script>
  <script src="search/search.js"></script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li><li><a href="webapp.html">OMPL web app</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://github.com/ompl/ompl/issues">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
          <!-- Doxygen API search box -->
          <div id="searchli">
            <div id="MSearchBox" class="MSearchBoxInactive">
              <span class="left">
                <img id="MSearchSelect" src="search/mag_sel.png"
                onmouseover="return searchBox.OnSearchSelectShow()"
                onmouseout="return searchBox.OnSearchSelectHide()"
                alt=""/>
                <input type="text" id="MSearchField" value="Search API" accesskey="S"
                onfocus="searchBox.OnSearchFieldFocus(true)"
                onblur="searchBox.OnSearchFieldFocus(false)"
                onkeyup="searchBox.OnSearchFieldChange(event)"/>
              </span><span class="right">
                <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
              </span>
            </div>
          </div>
        </ul>
      </div>
    </div>
  </nav>
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"
  onmouseover="return searchBox.OnSearchSelectShow()"
  onmouseout="return searchBox.OnSearchSelectHide()"
  onkeydown="return searchBox.OnSearchSelectKey(event)">
  <a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="" frameborder="0"name="MSearchResults" id="MSearchResults"></iframe>
  </div>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceompl.html">ompl</a></li><li class="navelem"><a class="el" href="namespaceompl_1_1geometric.html">geometric</a></li><li class="navelem"><a class="el" href="classompl_1_1geometric_1_1BITstar.html">BITstar</a></li><li class="navelem"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html">IntegratedQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ompl::geometric::BITstar::IntegratedQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A queue of edges to be processed that integrates both the expansion of <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1Vertex.html#gVertex">Vertices</a> and the ordering of the resulting edges.
 <a href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IntegratedQueue_8h_source.html">ompl/geometric/planners/bitstar/datastructures/IntegratedQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add27c92e6ae089e333d603c97ddd02e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add27c92e6ae089e333d603c97ddd02e6"></a>
typedef std::pair&lt; <a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>, <a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#add27c92e6ae089e333d603c97ddd02e6">CostPair</a></td></tr>
<tr class="memdesc:add27c92e6ae089e333d603c97ddd02e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for a pair of costs, i.e., the edge sorting key. <br /></td></tr>
<tr class="separator:add27c92e6ae089e333d603c97ddd02e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21877b7d4d5fa45f26366041b2ddf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f21877b7d4d5fa45f26366041b2ddf5"></a>
typedef std::function&lt; <a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>(const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a1f21877b7d4d5fa45f26366041b2ddf5">VertexHeuristicFunc</a></td></tr>
<tr class="memdesc:a1f21877b7d4d5fa45f26366041b2ddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::function definition of a heuristic function for a vertex. <br /></td></tr>
<tr class="separator:a1f21877b7d4d5fa45f26366041b2ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6679b31d47dc8f06b20df66da10715e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6679b31d47dc8f06b20df66da10715e2"></a>
typedef std::function&lt; <a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>(const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#a4a191ef6c088df39365ed444e6987438">VertexConstPtrPair</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a6679b31d47dc8f06b20df66da10715e2">EdgeHeuristicFunc</a></td></tr>
<tr class="memdesc:a6679b31d47dc8f06b20df66da10715e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::function definition of a heuristic function for an edge. <br /></td></tr>
<tr class="separator:a6679b31d47dc8f06b20df66da10715e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65ac275bb9e273f60e7348cec878cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab65ac275bb9e273f60e7348cec878cea"></a>
typedef std::function&lt; double(const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;, const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#ab65ac275bb9e273f60e7348cec878cea">DistanceFunc</a></td></tr>
<tr class="memdesc:ab65ac275bb9e273f60e7348cec878cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::function definition for the distance between two vertices. <br /></td></tr>
<tr class="separator:ab65ac275bb9e273f60e7348cec878cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe556ae151398b2081eb69a86c35aecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe556ae151398b2081eb69a86c35aecc"></a>
typedef std::function&lt; unsigned int(const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;, std::vector&lt; <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &gt; *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#afe556ae151398b2081eb69a86c35aecc">NeighbourhoodFunc</a></td></tr>
<tr class="memdesc:afe556ae151398b2081eb69a86c35aecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::function definition for the neighbourhood of a vertex . <br /></td></tr>
<tr class="separator:afe556ae151398b2081eb69a86c35aecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeec37c6a3ee123e905c409dd7424153b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeec37c6a3ee123e905c409dd7424153b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#aeec37c6a3ee123e905c409dd7424153b">IntegratedQueue</a> (const <a class="el" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ompl::base::OptimizationObjectivePtr</a> &amp;opt, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#ab65ac275bb9e273f60e7348cec878cea">DistanceFunc</a> &amp;distanceFunc, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#afe556ae151398b2081eb69a86c35aecc">NeighbourhoodFunc</a> &amp;nearSamplesFunc, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#afe556ae151398b2081eb69a86c35aecc">NeighbourhoodFunc</a> &amp;nearVerticesFunc, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a1f21877b7d4d5fa45f26366041b2ddf5">VertexHeuristicFunc</a> &amp;<a class="el" href="classompl_1_1geometric_1_1BITstar.html#a817618a1fed949683dfb1872a869661d">lowerBoundHeuristicVertex</a>, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a1f21877b7d4d5fa45f26366041b2ddf5">VertexHeuristicFunc</a> &amp;<a class="el" href="classompl_1_1geometric_1_1BITstar.html#ade5f2d7f662a35de6e974218854bfa8d">currentHeuristicVertex</a>, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a6679b31d47dc8f06b20df66da10715e2">EdgeHeuristicFunc</a> &amp;<a class="el" href="classompl_1_1geometric_1_1BITstar.html#a3678fc3cb8b048fd65c7e4b22741231a">lowerBoundHeuristicEdge</a>, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a6679b31d47dc8f06b20df66da10715e2">EdgeHeuristicFunc</a> &amp;<a class="el" href="classompl_1_1geometric_1_1BITstar.html#a8e22437e524b0be8c0bd1fbe9d05bbac">currentHeuristicEdge</a>, const <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a6679b31d47dc8f06b20df66da10715e2">EdgeHeuristicFunc</a> &amp;<a class="el" href="classompl_1_1geometric_1_1BITstar.html#ade1ffb15f198a34976789f95dea4894d">currentHeuristicEdgeTarget</a>)</td></tr>
<tr class="memdesc:aeec37c6a3ee123e905c409dd7424153b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an integrated queue. <br /></td></tr>
<tr class="separator:aeec37c6a3ee123e905c409dd7424153b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909336b8f1c1748d4e52268841a68ae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a909336b8f1c1748d4e52268841a68ae5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a909336b8f1c1748d4e52268841a68ae5">setDelayedRewiring</a> (bool delayRewiring)</td></tr>
<tr class="memdesc:a909336b8f1c1748d4e52268841a68ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay considering rewiring edges until an initial solution is found. This improves the time required to find an initial solution when doing so requires multiple batches and has no effects on theoretical asymptotic optimality (as the rewiring edges are eventually considered). <br /></td></tr>
<tr class="separator:a909336b8f1c1748d4e52268841a68ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bc7c32c3ec8e7339f797067a85682e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13bc7c32c3ec8e7339f797067a85682e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a13bc7c32c3ec8e7339f797067a85682e">getDelayedRewiring</a> () const </td></tr>
<tr class="memdesc:a13bc7c32c3ec8e7339f797067a85682e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether BIT* is delaying rewiring until a solution is found. <br /></td></tr>
<tr class="separator:a13bc7c32c3ec8e7339f797067a85682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689c53e5ab0bf20bc05f0f733dbc1874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689c53e5ab0bf20bc05f0f733dbc1874"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a689c53e5ab0bf20bc05f0f733dbc1874">insertVertex</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;newVertex)</td></tr>
<tr class="memdesc:a689c53e5ab0bf20bc05f0f733dbc1874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a vertex into the vertex expansion queue. Vertices remain in the vertex queue until pruned or manually removed. A moving token marks the line between expanded and not expanded vertices. <br /></td></tr>
<tr class="separator:a689c53e5ab0bf20bc05f0f733dbc1874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4d9a979592702d2e794a4fe12355b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4d9a979592702d2e794a4fe12355b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#adc4d9a979592702d2e794a4fe12355b5">insertEdge</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae606dd4b834ca3ac621533ba65b3f19a">VertexPtrPair</a> &amp;newEdge)</td></tr>
<tr class="memdesc:adc4d9a979592702d2e794a4fe12355b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an edge into the edge processing queue. Edges are removed from the processing queue. This is only valid if the source vertex is already in the expansion queue (though it may already be expanded). <br /></td></tr>
<tr class="separator:adc4d9a979592702d2e794a4fe12355b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f447973b86790e3738570b5658adf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47f447973b86790e3738570b5658adf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a47f447973b86790e3738570b5658adf3">eraseVertex</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;oldVertex, bool disconnectParent, const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#af2f9b7f4de0bb76ae6ce74874ff08f49">VertexPtrNNPtr</a> &amp;vertexNN, const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#af2f9b7f4de0bb76ae6ce74874ff08f49">VertexPtrNNPtr</a> &amp;freeStateNN, std::vector&lt; <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &gt; *recycledVertices)</td></tr>
<tr class="memdesc:a47f447973b86790e3738570b5658adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a vertex from the vertex expansion queue. Will disconnect the vertex from its parent and remove the associated incoming and outgoing edges from the edge queue as requested. <br /></td></tr>
<tr class="separator:a47f447973b86790e3738570b5658adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceea726309ed615c998cef5f1a578d6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceea726309ed615c998cef5f1a578d6c"></a>
<a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#aceea726309ed615c998cef5f1a578d6c">frontVertex</a> ()</td></tr>
<tr class="memdesc:aceea726309ed615c998cef5f1a578d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the best vertex on the queue without incrementing the vertex queue. <br /></td></tr>
<tr class="separator:aceea726309ed615c998cef5f1a578d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a104b3334cb4161fbce8d684aa5420"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30a104b3334cb4161fbce8d684aa5420"></a>
<a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae606dd4b834ca3ac621533ba65b3f19a">VertexPtrPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a30a104b3334cb4161fbce8d684aa5420">frontEdge</a> ()</td></tr>
<tr class="memdesc:a30a104b3334cb4161fbce8d684aa5420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the best edge on the queue, leaving it on the edge queue. <br /></td></tr>
<tr class="separator:a30a104b3334cb4161fbce8d684aa5420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cbab5c9e792a400809f95659876e73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42cbab5c9e792a400809f95659876e73"></a>
<a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a42cbab5c9e792a400809f95659876e73">frontVertexValue</a> ()</td></tr>
<tr class="memdesc:a42cbab5c9e792a400809f95659876e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the best vertex on the queue without incrementing the vertex queue. <br /></td></tr>
<tr class="separator:a42cbab5c9e792a400809f95659876e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1af1d4bed27a6265a0274c5d45cda9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1af1d4bed27a6265a0274c5d45cda9b"></a>
<a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#add27c92e6ae089e333d603c97ddd02e6">CostPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#ae1af1d4bed27a6265a0274c5d45cda9b">frontEdgeValue</a> ()</td></tr>
<tr class="memdesc:ae1af1d4bed27a6265a0274c5d45cda9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the best edge on the queue, leaving it on the edge queue. <br /></td></tr>
<tr class="separator:ae1af1d4bed27a6265a0274c5d45cda9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf096c0cae2840bea8fc371deb57fbfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf096c0cae2840bea8fc371deb57fbfa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#abf096c0cae2840bea8fc371deb57fbfa">popFrontEdge</a> (<a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae606dd4b834ca3ac621533ba65b3f19a">VertexPtrPair</a> *bestEdge)</td></tr>
<tr class="memdesc:abf096c0cae2840bea8fc371deb57fbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the best edge off the queue, removing it from the edge queue in the process. <br /></td></tr>
<tr class="separator:abf096c0cae2840bea8fc371deb57fbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cb33648c97dc2d775e0f0589b2a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a935cb33648c97dc2d775e0f0589b2a4b"></a>
<a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae606dd4b834ca3ac621533ba65b3f19a">VertexPtrPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a935cb33648c97dc2d775e0f0589b2a4b">popFrontEdge</a> ()</td></tr>
<tr class="memdesc:a935cb33648c97dc2d775e0f0589b2a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the best edge off the queue, removing it from the edge queue in the process. <br /></td></tr>
<tr class="separator:a935cb33648c97dc2d775e0f0589b2a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4e919dcffe30b0ba31d9a647e33e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c4e919dcffe30b0ba31d9a647e33e24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a2c4e919dcffe30b0ba31d9a647e33e24">hasSolution</a> ()</td></tr>
<tr class="memdesc:a2c4e919dcffe30b0ba31d9a647e33e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that a solution has been found. <br /></td></tr>
<tr class="separator:a2c4e919dcffe30b0ba31d9a647e33e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab6a00dc8e2c34d7bfbcce2a0c94d60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ab6a00dc8e2c34d7bfbcce2a0c94d60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a3ab6a00dc8e2c34d7bfbcce2a0c94d60">setThreshold</a> (const <a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a> &amp;costThreshold)</td></tr>
<tr class="memdesc:a3ab6a00dc8e2c34d7bfbcce2a0c94d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the threshold of the queue. <br /></td></tr>
<tr class="separator:a3ab6a00dc8e2c34d7bfbcce2a0c94d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f14f35adb88ef7c2010b5070d489bef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f14f35adb88ef7c2010b5070d489bef"></a>
<a class="el" href="classompl_1_1base_1_1Cost.html">ompl::base::Cost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a1f14f35adb88ef7c2010b5070d489bef">getThreshold</a> () const </td></tr>
<tr class="memdesc:a1f14f35adb88ef7c2010b5070d489bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the threshold of the queue. <br /></td></tr>
<tr class="separator:a1f14f35adb88ef7c2010b5070d489bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4a01a31f1f06f016c0f2df4cc59e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e4a01a31f1f06f016c0f2df4cc59e9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a1e4a01a31f1f06f016c0f2df4cc59e9a">removeEdgesTo</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;cVertex)</td></tr>
<tr class="memdesc:a1e4a01a31f1f06f016c0f2df4cc59e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges in the edge queue that lead to the given vertex. <br /></td></tr>
<tr class="separator:a1e4a01a31f1f06f016c0f2df4cc59e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b6a66c209f634e2a97937958a18b7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48b6a66c209f634e2a97937958a18b7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a48b6a66c209f634e2a97937958a18b7a">removeEdgesFrom</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;pVertex)</td></tr>
<tr class="memdesc:a48b6a66c209f634e2a97937958a18b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges in the edge queue that leave from the given vertex. <br /></td></tr>
<tr class="separator:a48b6a66c209f634e2a97937958a18b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da1f51322521b2f31000f5ae2d811e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1da1f51322521b2f31000f5ae2d811e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#af1da1f51322521b2f31000f5ae2d811e">pruneEdgesTo</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;cVertex)</td></tr>
<tr class="memdesc:af1da1f51322521b2f31000f5ae2d811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune edges in the edge queue that lead to the given vertex using the prune function. <br /></td></tr>
<tr class="separator:af1da1f51322521b2f31000f5ae2d811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053757b3ef228f042492990013c39ca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a053757b3ef228f042492990013c39ca2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a053757b3ef228f042492990013c39ca2">pruneEdgesFrom</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;pVertex)</td></tr>
<tr class="memdesc:a053757b3ef228f042492990013c39ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune edges in the edge queue that leave from the given vertex using the prune function. <br /></td></tr>
<tr class="separator:a053757b3ef228f042492990013c39ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135dd303977d7a0762bc48a03b2bc43f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a135dd303977d7a0762bc48a03b2bc43f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a135dd303977d7a0762bc48a03b2bc43f">markVertexUnsorted</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;vertex)</td></tr>
<tr class="memdesc:a135dd303977d7a0762bc48a03b2bc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the queue as requiring resorting downstream of the specified vertex. <br /></td></tr>
<tr class="separator:a135dd303977d7a0762bc48a03b2bc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193a6e97fac19b38a37bf207991de411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a193a6e97fac19b38a37bf207991de411"></a>
std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a193a6e97fac19b38a37bf207991de411">prune</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;pruneStartPtr, const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#af2f9b7f4de0bb76ae6ce74874ff08f49">VertexPtrNNPtr</a> &amp;vertexNN, const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#af2f9b7f4de0bb76ae6ce74874ff08f49">VertexPtrNNPtr</a> &amp;freeStateNN, std::vector&lt; <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &gt; *recycledVertices)</td></tr>
<tr class="memdesc:a193a6e97fac19b38a37bf207991de411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune the vertex queue of vertices whose their lower-bound heuristic is greater then the threshold. Descendents of pruned vertices that are not pruned themselves are returned to the set of free states. Returns the number of vertices pruned (either removed completely or moved to the set of free states). <br /></td></tr>
<tr class="separator:a193a6e97fac19b38a37bf207991de411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919cf87458536f8f06c15321efbf1007"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a919cf87458536f8f06c15321efbf1007"></a>
std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a919cf87458536f8f06c15321efbf1007">resort</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#af2f9b7f4de0bb76ae6ce74874ff08f49">VertexPtrNNPtr</a> &amp;vertexNN, const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#af2f9b7f4de0bb76ae6ce74874ff08f49">VertexPtrNNPtr</a> &amp;freeStateNN, std::vector&lt; <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &gt; *recycledVertices)</td></tr>
<tr class="memdesc:a919cf87458536f8f06c15321efbf1007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resort the queue, only reinserting edges/vertices if their lower-bound heuristic is less then the threshold. Descendents of pruned vertices that are not pruned themselves are returned to the set of free states. Requires first marking the queue as unsorted. Returns the number of vertices pruned (either removed completely or moved to the set of free states). <br /></td></tr>
<tr class="separator:a919cf87458536f8f06c15321efbf1007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa186c504678d5ee4a5fd9b4c65306229"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa186c504678d5ee4a5fd9b4c65306229"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#aa186c504678d5ee4a5fd9b4c65306229">finish</a> ()</td></tr>
<tr class="memdesc:aa186c504678d5ee4a5fd9b4c65306229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish the queue, clearing all the edge containers and moving the vertex expansion token to the end. After a call to finish, <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a91564e55df815e8b6c7523943712b8ec" title="Returns true if the queue is empty. In the case where the edge queue is empty but the vertex queue is...">isEmpty()</a> will return true. Keeps threshold, list of unsorted vertices, etc. <br /></td></tr>
<tr class="separator:aa186c504678d5ee4a5fd9b4c65306229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00893471a0e44c57ab243a3249dc6810"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00893471a0e44c57ab243a3249dc6810"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a00893471a0e44c57ab243a3249dc6810">reset</a> ()</td></tr>
<tr class="memdesc:a00893471a0e44c57ab243a3249dc6810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the queue, clearing all the edge containers and moving the vertex expansion token to the start. After a call to reset, <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a91564e55df815e8b6c7523943712b8ec" title="Returns true if the queue is empty. In the case where the edge queue is empty but the vertex queue is...">isEmpty()</a> will return false (unless there is no data in the queue of course). Keeps threshold, list of unsorted vertices, etc. <br /></td></tr>
<tr class="separator:a00893471a0e44c57ab243a3249dc6810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af128e2b728f65bd8b2c0c8bed389ee7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af128e2b728f65bd8b2c0c8bed389ee7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#af128e2b728f65bd8b2c0c8bed389ee7b">clear</a> ()</td></tr>
<tr class="memdesc:af128e2b728f65bd8b2c0c8bed389ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue to the state of construction. <br /></td></tr>
<tr class="separator:af128e2b728f65bd8b2c0c8bed389ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8e55721ac2464fdc5f69a3472080c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8e55721ac2464fdc5f69a3472080c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a2d8e55721ac2464fdc5f69a3472080c6">vertexPruneCondition</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;vertex) const </td></tr>
<tr class="memdesc:a2d8e55721ac2464fdc5f69a3472080c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The condition used to prune vertices out of the queue. Compares lowerBoundHeuristicVertex to the given threshold. Returns true if the vertex's best cost is greater than the internally set threshold. Used internally during <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a919cf87458536f8f06c15321efbf1007" title="Resort the queue, only reinserting edges/vertices if their lower-bound heuristic is less then the thr...">resort()</a> <br /></td></tr>
<tr class="separator:a2d8e55721ac2464fdc5f69a3472080c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71827623d6e34af05c37fd725e877229"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71827623d6e34af05c37fd725e877229"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a71827623d6e34af05c37fd725e877229">samplePruneCondition</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;vertex) const </td></tr>
<tr class="memdesc:a71827623d6e34af05c37fd725e877229"><td class="mdescLeft">&#160;</td><td class="mdescRight">The condition used to prune disconnected samples from the free set. Compares lowerBoundHeuristicVertex to the given threshold. Returns true if the vertex's best cost is greater than or equal to the internally set threshold. Used internally during <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a919cf87458536f8f06c15321efbf1007" title="Resort the queue, only reinserting edges/vertices if their lower-bound heuristic is less then the thr...">resort()</a> <br /></td></tr>
<tr class="separator:a71827623d6e34af05c37fd725e877229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e72254247a0b554757301946dfdf932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e72254247a0b554757301946dfdf932"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a0e72254247a0b554757301946dfdf932">edgePruneCondition</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae606dd4b834ca3ac621533ba65b3f19a">VertexPtrPair</a> &amp;edge) const </td></tr>
<tr class="memdesc:a0e72254247a0b554757301946dfdf932"><td class="mdescLeft">&#160;</td><td class="mdescRight">The condition used to prune edge (i.e., vertex-pair) out of the queue. Compares lowerBoundHeuristicEdge to the given threshold. Returns true if the edge's best cost is greater than the internally set threshold. Used internally during <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a919cf87458536f8f06c15321efbf1007" title="Resort the queue, only reinserting edges/vertices if their lower-bound heuristic is less then the thr...">resort()</a> <br /></td></tr>
<tr class="separator:a0e72254247a0b554757301946dfdf932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8ff196d2f081a42aaa0b4546be3d9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8ff196d2f081a42aaa0b4546be3d9b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#adb8ff196d2f081a42aaa0b4546be3d9b">numEdges</a> () const </td></tr>
<tr class="memdesc:adb8ff196d2f081a42aaa0b4546be3d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges in the queue. <br /></td></tr>
<tr class="separator:adb8ff196d2f081a42aaa0b4546be3d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa51b7dc8edf02eb9021aaa936233954"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa51b7dc8edf02eb9021aaa936233954"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#afa51b7dc8edf02eb9021aaa936233954">numVertices</a> () const </td></tr>
<tr class="memdesc:afa51b7dc8edf02eb9021aaa936233954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices left to expand. This has nontrivial cost, as the token must be moved through the list to count. <br /></td></tr>
<tr class="separator:afa51b7dc8edf02eb9021aaa936233954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be70311fb4a8b45d02f544bc0f75405"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4be70311fb4a8b45d02f544bc0f75405"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a4be70311fb4a8b45d02f544bc0f75405">numEdgesTo</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;cVertex) const </td></tr>
<tr class="memdesc:a4be70311fb4a8b45d02f544bc0f75405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges in the queue pointing to a specific vertex. <br /></td></tr>
<tr class="separator:a4be70311fb4a8b45d02f544bc0f75405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ade2f1bdead44b62d8fcc6ea45049c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20ade2f1bdead44b62d8fcc6ea45049c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a20ade2f1bdead44b62d8fcc6ea45049c">numEdgesFrom</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#adff43a966e7cba88d21a4927602703fa">VertexPtr</a> &amp;pVertex) const </td></tr>
<tr class="memdesc:a20ade2f1bdead44b62d8fcc6ea45049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges in the queue coming from a specific vertex. <br /></td></tr>
<tr class="separator:a20ade2f1bdead44b62d8fcc6ea45049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1ceabd4af6cf2efe2cd4cc49a7af32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1ceabd4af6cf2efe2cd4cc49a7af32"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a6c1ceabd4af6cf2efe2cd4cc49a7af32">isSorted</a> () const </td></tr>
<tr class="memdesc:a6c1ceabd4af6cf2efe2cd4cc49a7af32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the queue is still sorted. <br /></td></tr>
<tr class="separator:a6c1ceabd4af6cf2efe2cd4cc49a7af32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94884af3f1943aa984754b6ad91adfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab94884af3f1943aa984754b6ad91adfb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#ab94884af3f1943aa984754b6ad91adfb">isReset</a> () const </td></tr>
<tr class="memdesc:ab94884af3f1943aa984754b6ad91adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue is reset. This means that no edges have been expanded and the vertex expansion token is pointing at the start. <br /></td></tr>
<tr class="separator:ab94884af3f1943aa984754b6ad91adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91564e55df815e8b6c7523943712b8ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91564e55df815e8b6c7523943712b8ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a91564e55df815e8b6c7523943712b8ec">isEmpty</a> ()</td></tr>
<tr class="memdesc:a91564e55df815e8b6c7523943712b8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue is empty. In the case where the edge queue is empty but the vertex queue is not, this function will expand vertices <em>until</em> the edge queue is not empty or there are no vertices to expand. <br /></td></tr>
<tr class="separator:a91564e55df815e8b6c7523943712b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bd297de92bcbe702de030cb9090645"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39bd297de92bcbe702de030cb9090645"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a39bd297de92bcbe702de030cb9090645">isVertexExpanded</a> (const <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &amp;vertex) const </td></tr>
<tr class="memdesc:a39bd297de92bcbe702de030cb9090645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given vertex has been expanded or not. <br /></td></tr>
<tr class="separator:a39bd297de92bcbe702de030cb9090645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea7aa81b9b9a6b128dd1f06b7bd705c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea7aa81b9b9a6b128dd1f06b7bd705c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#a8ea7aa81b9b9a6b128dd1f06b7bd705c">listVertices</a> (std::vector&lt; <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &gt; *vertexQueue)</td></tr>
<tr class="memdesc:a8ea7aa81b9b9a6b128dd1f06b7bd705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the vertices in the vertex queue that are left to be expanded. This is expensive and is only meant for animations/debugging. <br /></td></tr>
<tr class="separator:a8ea7aa81b9b9a6b128dd1f06b7bd705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec953e955b595c3f053bd52ae1f1d760"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec953e955b595c3f053bd52ae1f1d760"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1geometric_1_1BITstar_1_1IntegratedQueue.html#aec953e955b595c3f053bd52ae1f1d760">listEdges</a> (std::vector&lt; std::pair&lt; <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a>, <a class="el" href="classompl_1_1geometric_1_1BITstar.html#ae2c8c06f2c54b1bf182dc62dce515ff0">VertexConstPtr</a> &gt; &gt; *edgeQueue)</td></tr>
<tr class="memdesc:aec953e955b595c3f053bd52ae1f1d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the edge queue. This is expensive and is only meant for animations/debugging. <br /></td></tr>
<tr class="separator:aec953e955b595c3f053bd52ae1f1d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A queue of edges to be processed that integrates both the expansion of <a class="el" href="classompl_1_1geometric_1_1BITstar_1_1Vertex.html#gVertex">Vertices</a> and the ordering of the resulting edges. </p>
<p><a class="anchor" id="IntegratedQueue"></a></p><dl class="section user"><dt>Short Description</dt><dd>An integrated two-stage queue that consists of vertices expanded into edges to be processed. The integrated queue consists of a vertex expansion queue and an edge processing queue. Vertices are expanded as needed from the vertex queue into edges places in the edge queue. Edges are removed from the edge queue for processing by BIT*. The vertex queue is implemented as a static ordered list of the vertices in the graph with a token (i.e., an iterator) pointing to the next vertex that needs to be expanded. This is specifically a multimap ordered on <a class="el" href="classompl_1_1base_1_1Cost.html" title="Definition of a cost value. Can represent the cost of a motion or the cost of a state. ">ompl::base::Cost</a> The edge queue is implemented as an ordered list of potential edges. It is filled by the vertex queue and emptied by popping the best value off the front. It is specifically a multimap ordered on std::pair&lt;ompl::base::Cost, ompl::base::Cost&gt;</dd></dl>
<dl class="section user"><dt>Notes:</dt><dd><ul>
<li>An eraseEdge() function could be made by mimicking the vertex -&gt; vertexQueue_::iterator lookup datastructure for the edgeQueue_ </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="IntegratedQueue_8h_source.html#l00090">90</a> of file <a class="el" href="IntegratedQueue_8h_source.html">IntegratedQueue.h</a>.</p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>ompl/geometric/planners/bitstar/datastructures/<a class="el" href="IntegratedQueue_8h_source.html">IntegratedQueue.h</a></li>
<li>ompl/geometric/planners/bitstar/datastructures/src/<a class="el" href="IntegratedQueue_8cpp_source.html">IntegratedQueue.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.10</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="js/jquery.js"></script>
<script src="js/jquery.powertip.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/dynsections.js"></script>
<script src="js/ompl.js"></script>
</body>
</html>
