<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Constrained Planning Tutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.8.14"/>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-powertip/1.2.0/jquery.powertip.min.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li><li><a href="webapp.html">OMPL web app</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="constrainedPlanning.html">Constrained Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux/macOS)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux/macOS)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
                  <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Constrained Planning Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Defining a constrained motion planning problem is easy and very similar to defining an unconstrained planning problem. The primary difference is the need to define a <em>constraint</em>, and the use of a <em>constrained state space</em>, which wraps around an ambient state space. In this example, we will walk through defining a simple constrained planning problem: a point in \(\mathbb{R}^3\) that is constrained to be on the surface of a sphere, giving a constraint function \(f(q) = \lVert q \rVert - 1\). This is very similar to the problem defined by the demo <a href="ConstrainedPlanningSphere_8cpp_source.html">ConstrainedPlanningSphere</a>.</p>
<h2>Defining the Constraint</h2>
<p>First, let's define our constraint class. Constraints must inherit from the base class <code><a class="el" href="classompl_1_1base_1_1Constraint.html" title="Definition of a differentiable holonomic constraint on a configuration space. See Constrained Plannin...">ompl::base::Constraint</a></code>. Primarily, the function <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a08882bb91416db1a604baaa61525d2cc" title="Compute the constraint function at state. Result is returned in out, which should be allocated to siz...">ompl::base::Constraint::function()</a></code> must be implemented by any concrete implementation of a constraint. A bare-bones version of the sphere constraint we gave above might look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Constraints must inherit from the constraint base class. By default, a</span></div><div class="line"><span class="comment">// numerical approximation to the Jacobian of the constraint function is computed</span></div><div class="line"><span class="comment">// using a central finite difference.</span></div><div class="line"><span class="keyword">class </span>Sphere : <span class="keyword">public</span> <a class="code" href="classompl_1_1base_1_1Constraint.html">ob::Constraint</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ob::Constraint&#39;s constructor takes in two parameters, the dimension of</span></div><div class="line">    <span class="comment">// the ambient state space, and the dimension of the real vector space the</span></div><div class="line">    <span class="comment">// constraint maps into. For our sphere example, as we are planning in R^3, the</span></div><div class="line">    <span class="comment">// dimension of the ambient space is 3, and as our constraint outputs one real</span></div><div class="line">    <span class="comment">// value the second parameter is one (this is also the co-dimension of the</span></div><div class="line">    <span class="comment">// constraint manifold).</span></div><div class="line">    Sphere() : <a class="code" href="namespaceompl_1_1base.html">ob</a>::Constraint(3, 1)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Here we define the actual constraint function, which takes in some state &quot;x&quot;</span></div><div class="line">    <span class="comment">// (from the ambient space) and sets the values of &quot;out&quot; to the result of the</span></div><div class="line">    <span class="comment">// constraint function. Note that we are implementing `function` which has this</span></div><div class="line">    <span class="comment">// function signature, not the one that takes in ompl::base::State.</span></div><div class="line">    <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::Ref&lt;const Eigen::VectorXd&gt; &amp;x, Eigen::Ref&lt;Eigen::VectorXd&gt; out) <span class="keyword">const</span> <span class="keyword">override</span></div><div class="line">    {</div><div class="line">        <span class="comment">// The function that defines a sphere is f(q) = || q || - 1, as discussed</span></div><div class="line">        <span class="comment">// above. Eigen makes this easy to express:</span></div><div class="line">        out[0] = x.norm() - 1;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>We now have a constraint function that defines a sphere in \(\mathbb{R}^3\)! We can visualize the constraint simply as a sphere in \(\mathbb{R}^3\), shown below.</p>
<div class="row"><div class="image">
<img src="images/sphere.png" class="col-xs-6 col-xs-offset-3"/>
</div>
</div><p>Now we can use this constraint to define a constrained state space.</p>
<h3>Constraint Jacobian</h3>
<p>However, we can do better. We would like to include an analytical Jacobian for our constraint function, so that planning more efficient. Either we can compute this by hand, or we can use some symbolic solver (e.g., <code><a class="el" href="ConstraintGeneration_8py_source.html">ConstraintGeneration.py</a></code> shows how to do this with <a href="http://www.sympy.org/en/index.html">SymPy</a>). Either way, we add to our class the function to compute the Jacobian:</p>
<div class="fragment"><div class="line"><span class="comment">// Implement the Jacobian of the constraint function. The Jacobian for the</span></div><div class="line"><span class="comment">// constraint function is an matrix of dimension equal to the co-dimension of the</span></div><div class="line"><span class="comment">// constraint by the ambient dimension (in this case, 1 by 3). Similar to</span></div><div class="line"><span class="comment">// `function` above, we implement the `jacobian` method with the following</span></div><div class="line"><span class="comment">// function signature.</span></div><div class="line"><span class="keywordtype">void</span> Sphere::jacobian(<span class="keyword">const</span> Eigen::Ref&lt;const Eigen::VectorXd&gt; &amp;x, Eigen::Ref&lt;Eigen::MatrixXd&gt; out)<span class="keyword"> const override</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    out = x.transpose().normalized();</div><div class="line">}</div></div><!-- fragment --><p>In general, it is <em>highly</em> recommended that you provide an analytic Jacobian for a constrained planning problem, especially for high-dimensional problems.</p>
<h3>Projection</h3>
<p>One of the primary features of <code><a class="el" href="classompl_1_1base_1_1Constraint.html" title="Definition of a differentiable holonomic constraint on a configuration space. See Constrained Plannin...">ompl::base::Constraint</a></code> is the <em>projection</em> function, <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a84203729cf979b398e8e59f92d136ed3" title="Project a state state given the constraints. If a valid projection cannot be found, this method will return false. Even if this method fails, state will be modified. ">ompl::base::Constraint::project()</a></code>. This function takes as input a potential constraint unsatisfying state and maps it onto the constraint manifold, generating a constraint satisfying state. By default, <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a84203729cf979b398e8e59f92d136ed3" title="Project a state state given the constraints. If a valid projection cannot be found, this method will return false. Even if this method fails, state will be modified. ">ompl::base::Constraint::project()</a></code> implements a Newton's method which performs well in most circumstances.</p>
<p>However, it is possible to override this method with your own projection routine. For example, in the case of our sphere, it could simply normalize the state, placing it on the sphere. Another example would be to use inverse kinematics for a complex robot manipulator.</p>
<h3>Constraint Parameters</h3>
<p><code><a class="el" href="classompl_1_1base_1_1Constraint.html" title="Definition of a differentiable holonomic constraint on a configuration space. See Constrained Plannin...">ompl::base::Constraint</a></code> affords a two parameters that affect performance. The first is <code>tolerance</code>, which can be set with <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a4413eaf904a95e843b85938236a1a2ab" title="Sets the projection tolerance. ">ompl::base::Constraint::setTolerance()</a></code>, or via the constructor. Using the constructor, our <code>Sphere</code> class could like like this:</p>
<div class="fragment"><div class="line">...</div><div class="line">    <span class="comment">// Set ambient and constraint dimension, along with tolerance (1e-3, in this case).</span></div><div class="line">    Sphere() : <a class="code" href="namespaceompl_1_1base.html">ob</a>::Constraint(3, 1, 1e-3)</div><div class="line">...</div></div><!-- fragment --><p><code>tolerance</code> is used in <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a84203729cf979b398e8e59f92d136ed3" title="Project a state state given the constraints. If a valid projection cannot be found, this method will return false. Even if this method fails, state will be modified. ">ompl::base::Constraint::project()</a></code> to determine when a state satisfies the constraints, and in <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a0e4d9def91883487533583390fbd2281" title="Check whether a state state satisfies the constraints. ">ompl::base::Constraint::isSatisfied()</a></code> for the same purpose. For problems that afford lower tolerances (e.g., highly compliant robots), <code>tolerance</code> can be lowered. Lower <code>tolerance</code> values generally simplifies the planning problem, as it is easier to satisfy constraints.</p>
<p>The second is <code>maxIterations</code>, which can be set with <code><a class="el" href="classompl_1_1base_1_1Constraint.html#ab907de9231aac2c08ed507ef5e626210" title="Sets the maximum number of iterations in the projection routine. ">ompl::base::Constraint::setMaxIterations()</a></code>. <code>maxIterations</code> is used in <code><a class="el" href="classompl_1_1base_1_1Constraint.html#a84203729cf979b398e8e59f92d136ed3" title="Project a state state given the constraints. If a valid projection cannot be found, this method will return false. Even if this method fails, state will be modified. ">ompl::base::Constraint::project()</a></code> to limit the number of iterations the projection routine uses, in the case that a satisfying configuration cannot be found. It might be necessary to adjust this value for particularly easy or hard constraint functions to satisfy (decreasing and increasing iterations respectively).</p>
<h2>Defining the Constrained State Space</h2>
<h3>Ambient State Space</h3>
<p>Before we can define a constrained state space, we need to define the ambient state space \(\mathbb{R}^3\).</p>
<div class="fragment"><div class="line"><span class="comment">// Create the ambient space state space for the problem.</span></div><div class="line"><span class="keyword">auto</span> rvss = std::make_shared&lt;ob::RealVectorStateSpace&gt;(3);</div><div class="line"></div><div class="line"><span class="comment">// Set bounds on the space.</span></div><div class="line"><a class="code" href="classompl_1_1base_1_1RealVectorBounds.html">ob::RealVectorBounds</a> bounds(3);</div><div class="line">bounds.setLow(-2);</div><div class="line">bounds.setHigh(2);</div><div class="line"></div><div class="line">rvss-&gt;setBounds(bounds);</div></div><!-- fragment --><p>The ambient space is the space over which the constraint is defined, and is used by our constrained state space.</p>
<h3>Constraint Instance</h3>
<p>We then need to create an instance of our constraint:</p>
<div class="fragment"><div class="line"><span class="comment">// Create our sphere constraint.</span></div><div class="line"><span class="keyword">auto</span> constraint = std::make_shared&lt;Sphere&gt;();</div></div><!-- fragment --><p>The constraint instance is used by our constrained state space.</p>
<h3>Constrained State Space</h3>
<p>Now that we have both the ambient state space and the constraint, we can define the constrained state space. For this example, we will be using <code><a class="el" href="classompl_1_1base_1_1ProjectedStateSpace.html" title="ConstrainedStateSpace encapsulating a projection-based methodology for planning with constraints...">ompl::base::ProjectedStateSpace</a></code>, which implements a projection operator-based methodology for satisfying constraints. However, we could also just as easily use the other constrained state spaces, <code><a class="el" href="classompl_1_1base_1_1AtlasStateSpace.html" title="ConstrainedStateSpace encapsulating a planner-agnostic atlas algorithm for planning on a constraint m...">ompl::base::AtlasStateSpace</a></code> or <code><a class="el" href="classompl_1_1base_1_1TangentBundleStateSpace.html" title="ConstrainedStateSpace encapsulating a planner-agnostic lazy atlas algorithm for planning on a constra...">ompl::base::TangentBundleStateSpace</a></code>, for this problem. We will also be creating a <code><a class="el" href="classompl_1_1base_1_1ConstrainedSpaceInformation.html" title="Space information for a constrained state space. Implements more direct for getting motion states...">ompl::base::ConstrainedSpaceInformation</a></code>, which is an augmentation of <code><a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">ompl::base::SpaceInformation</a></code> with some small modification to take into account constraints.</p>
<div class="fragment"><div class="line"><span class="comment">// Combine the ambient space and the constraint into a constrained state space.</span></div><div class="line"><span class="keyword">auto</span> css = std::make_shared&lt;ob::ProjectedStateSpace&gt;(rvss, constraint);</div><div class="line"></div><div class="line"><span class="comment">// Define the constrained space information for this constrained state space.</span></div><div class="line"><span class="keyword">auto</span> csi = std::make_shared&lt;ob::ConstrainedSpaceInformation&gt;(css);</div></div><!-- fragment --><p>One of the most important things that <code><a class="el" href="classompl_1_1base_1_1ConstrainedSpaceInformation.html" title="Space information for a constrained state space. Implements more direct for getting motion states...">ompl::base::ConstrainedSpaceInformation</a></code> does is call <code><a class="el" href="classompl_1_1base_1_1ConstrainedStateSpace.html#a349cdde886586bc63b243c49176650ba" title="Sets the space information for this state space. Required for collision checking in manifold traversa...">ompl::base::ConstrainedStateSpace::setSpaceInformation</a></code>, which allows for the manifold traversal to do collision checking in tandem with discrete geodesic computation. Now, we have a constrained state space and space information which we can use for planning.</p>
<h2>Defining a Problem</h2>
<p>Let's define a simple problem to solve for this constrained space: traverse the sphere from the south pole to the north pole, avoiding a simple obstacle near the equator. Defining a problem using the constraint framework is as simple as defining an unconstrained problem, and uses the same set of tools. For example, we will be creating a <code><a class="el" href="classompl_1_1geometric_1_1SimpleSetup.html" title="Create the set of classes typically needed to solve a geometric problem. ">ompl::geometric::SimpleSetup</a></code> to help with problem definition.</p>
<div class="fragment"><div class="line"><span class="comment">// Simple Setup</span></div><div class="line"><span class="keyword">auto</span> ss = std::make_shared&lt;og::SimpleSetup&gt;(csi);</div></div><!-- fragment --><h3>State Validity Checker</h3>
<p>Let's define our state validity checker, which is a simple narrow band around the equator with a hole on one side:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> obstacle(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a> *state)</div><div class="line">{</div><div class="line">    <span class="comment">// As ob::ConstrainedStateSpace::StateType inherits from</span></div><div class="line">    <span class="comment">// Eigen::Map&lt;Eigen::VectorXd&gt;, we can grab a reference to it for some easier</span></div><div class="line">    <span class="comment">// state access.</span></div><div class="line">    <span class="keyword">const</span> Eigen::Map&lt;Eigen::VectorXd&gt; &amp;x = *state-&gt;<a class="code" href="classompl_1_1base_1_1State.html#a6178474307b3f364184db9999a639af1">as</a>&lt;<a class="code" href="classompl_1_1base_1_1StateSpace.html#a7d7aa9ecaf711b534e7d4f8b6472e898">ob::ConstrainedStateSpace::StateType</a>&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Alternatively, we could access the underlying real vector state with the</span></div><div class="line">    <span class="comment">// following incantation:</span></div><div class="line">    <span class="comment">//   auto x = state-&gt;as&lt;ob::ConstrainedStateSpace::StateType&gt;()-&gt;getState()-&gt;as&lt;ob::RealVectorStateSpace::StateType&gt;();</span></div><div class="line">    <span class="comment">// Note the use of &quot;getState()&quot; on the constrained state. This accesss the</span></div><div class="line">    <span class="comment">// underlying state that was allocated by the ambient state space.</span></div><div class="line"></div><div class="line">    <span class="comment">// Define a narrow band obstacle with a small hole on one side.</span></div><div class="line">    <span class="keywordflow">if</span> (-0.1 &lt; x[2] &amp;&amp; x[2] &lt; 0.1)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (-0.05 &lt; x[0] &amp;&amp; x[0] &lt; 0.05)</div><div class="line">            <span class="keywordflow">return</span> x[1] &lt; 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Set the state validity checker in simple setup.</span></div><div class="line">ss-&gt;setStateValidityChecker(obstacle);</div></div><!-- fragment --><p>Below, you can see a representation of this obstacle on our sphere.</p>
<div class="row"><div class="image">
<img src="images/obstacles.png" class="col-xs-6 col-xs-offset-3"/>
</div>
</div><h3>Start and Goal</h3>
<p>Now, let's also set the start and goal states, the south and north poles of the sphere. Note that for constrained problems, the start and goal states (if using exact states) must satisfy the constraint function. If they do not, then problems will occur.</p>
<div class="fragment"><div class="line"><span class="comment">// Start and goal vectors.</span></div><div class="line">Eigen::VectorXd sv(3), gv(3);</div><div class="line">sv &lt;&lt; 0, 0, -1;</div><div class="line">gv &lt;&lt; 0, 0,  1;</div><div class="line"></div><div class="line"><span class="comment">// Scoped states that we will add to simple setup.</span></div><div class="line"><a class="code" href="classompl_1_1base_1_1ScopedState.html">ob::ScopedState&lt;&gt;</a> start(css);</div><div class="line"><a class="code" href="classompl_1_1base_1_1ScopedState.html">ob::ScopedState&lt;&gt;</a> goal(css);</div><div class="line"></div><div class="line"><span class="comment">// Copy the values from the vectors into the start and goal states.</span></div><div class="line">start-&gt;as&lt;<a class="code" href="classompl_1_1base_1_1StateSpace.html#a7d7aa9ecaf711b534e7d4f8b6472e898">ob::ConstrainedStateSpace::StateType</a>&gt;()-&gt;copy(sv);</div><div class="line">goal-&gt;as&lt;<a class="code" href="classompl_1_1base_1_1StateSpace.html#a7d7aa9ecaf711b534e7d4f8b6472e898">ob::ConstrainedStateSpace::StateType</a>&gt;()-&gt;copy(gv);</div><div class="line"></div><div class="line"><span class="comment">// If we were using an Atlas or TangentBundleStateSpace, we would also have to anchor these states to charts:</span></div><div class="line"><span class="comment">//   css-&gt;anchorChart(start.get());</span></div><div class="line"><span class="comment">//   css-&gt;anchorChart(goal.get());</span></div><div class="line"><span class="comment">// Which gives a starting point for the atlas to grow.</span></div><div class="line"></div><div class="line">ss-&gt;setStartAndGoalStates(start, goal);</div></div><!-- fragment --><h3>Planner</h3>
<p>Finally, we can add a planner like normal. Let's use <code><a class="el" href="classompl_1_1geometric_1_1PRM.html" title="Probabilistic RoadMap planner. ">ompl::geometric::PRM</a></code>, but any other planner in <code><a class="el" href="namespaceompl_1_1geometric.html" title="This namespace contains code that is specific to planning under geometric constraints. ">ompl::geometric</a></code> would do.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pp = std::make_shared&lt;og::PRM&gt;(csi);</div><div class="line">ss-&gt;setPlanner(pp);</div></div><!-- fragment --><h2>Solving a Problem</h2>
<p>With everything now in place, we can set everything up to get ready for planning:</p>
<div class="fragment"><div class="line">ss-&gt;setup();</div></div><!-- fragment --><p>Same as how defining a problem is similar for constrained and unconstrained problems, solving a problem is also very similar. Let's give our planner 5 seconds of time and see what happens:</p>
<div class="fragment"><div class="line"><span class="comment">// Solve a problem like normal, for 5 seconds.</span></div><div class="line"><a class="code" href="structompl_1_1base_1_1PlannerStatus.html">ob::PlannerStatus</a> stat = ss-&gt;solve(5.);</div><div class="line"><span class="keywordflow">if</span> (stat)</div><div class="line">{</div><div class="line">    <span class="comment">// Path simplification also works when using a constrained state space!</span></div><div class="line">    ss-&gt;simplifySolution(5.);</div><div class="line"></div><div class="line">    <span class="comment">// Get solution path.</span></div><div class="line">    <span class="keyword">auto</span> path = ss-&gt;getSolutionPath();</div><div class="line"></div><div class="line">    <span class="comment">// Interpolation also works on constrained state spaces, and is generally required.</span></div><div class="line">    path.interpolate();</div><div class="line"></div><div class="line">    <span class="comment">// Then do whatever you want with the path, like normal!</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__logging.html#gab76357dced39cb468d2061d3358f80a6">OMPL_WARN</a>(<span class="stringliteral">&quot;No solution found!&quot;</span>);</div></div><!-- fragment --><h3>Interpolation</h3>
<p>Note that in general the initial path that you find is not "continuous". That is, the distance between states in the path (especially after simplification) can be very far apart! If you want a path that has close, intermediate constraint satisfying states, you need to interpolate the path. In the code above, this is achieved with <code><a class="el" href="classompl_1_1geometric_1_1PathGeometric.html#a824b91d04ba886c82c1dda3e356fd1f0" title="Insert a number of states in a path so that the path is made up of (approximately) the states checked...">ompl::geometric::PathGeometric::interpolate()</a></code>.</p>
<h1>In Summary</h1>
<p>With all that, we've now solved a constrained motion planning problem on a sphere. A resulting motion graph for PRM could look something like this, with the simplified solution path highlighted in yellow:</p>
<div class="row"><div class="image">
<img src="images/prm.png" class="col-xs-6 col-xs-offset-3"/>
</div>
</div><p>Overall, planning with constraints is simple to setup and use. Beyond requiring you to define a constraint function and wrap your ambient space in a constrained state space, OMPL works and feels like normal. You can read more in general about constrained planning on the <a href="constrainedPlanning.html">main page</a>. </p>
</div></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Kavraki Lab</a>  &bull;
    <a href="https://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="https://www.rice.edu">Rice University</a><br/>
    Funded in part by the <a href="https://www.nsf.gov">National Science Foundation</a><br/>
    Documentation generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</body>
</html>
