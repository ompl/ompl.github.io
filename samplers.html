<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Available State Samplers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. Șucan, Mark Moll, Lydia E. Kavraki">
  <meta name="generator" content="Doxygen 1.8.14"/>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-powertip/1.2.0/jquery.powertip.min.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <link href="ompl.css" rel="stylesheet">
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li><li><a href="webapp.html">OMPL web app</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="benchmark.html">Benchmarking Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="constrainedPlanning.html">Constrained Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">External links</li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://plannerarena.org">Planner Arena</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="integration.html">Use OMPL within Other Systems</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Repositories</li>
              <li><a href="https://bitbucket.org/ompl/ompl">ompl on Bitbucket (Mercurial)</a></li>
              <li><a href="https://bitbucket.org/ompl/omplapp">omplapp on Bitbucket (Mercurial)</a></li>
              <li><a href="https://github.com/ompl/ompl">ompl on GitHub</a></li>
              <li><a href="https://github.com/ompl/omplapp">omplapp on GitHub</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Continuous Integration</li>
              <li><a href="https://travis-ci.org/ompl/ompl">ompl on Travis CI (Linux/macOS)</a></li>
              <li><a href="https://travis-ci.org/ompl/omplapp">omplapp on Travis CI (Linux/macOS)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/ompl">ompl on AppVeyor CI (Windows)</a></li>
              <li><a href="https://ci.appveyor.com/project/mamoll/omplapp">omplapp on AppVeyor CI (Windows)</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog.html">Blog</a></li>
                  <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Available State Samplers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There are two different kinds of samplers that sound similar, but have different roles: state space samplers (<a class="el" href="classompl_1_1base_1_1StateSampler.html" title="Abstract definition of a state space sampler. ">ompl::base::StateSampler</a>) and <em>valid</em> state samplers (<a class="el" href="classompl_1_1base_1_1ValidStateSampler.html" title="Abstract definition of a state sampler. ">ompl::base::ValidStateSampler</a>). For each type of state space there needs to exist a corresponding derived <a class="el" href="classompl_1_1base_1_1StateSampler.html" title="Abstract definition of a state space sampler. ">ompl::base::StateSampler</a> class that allows one to generate uniform samples from that state space, generate states near another state from that state space and generate states using a Gaussian distribution. The valid state samplers use the state space samplers as a low level primitive. Typically, they generate a number of state samples using the appropriate state space sampler until a valid state is found or a maximum number of iterations is exceeded. The validity of a state is determined through the <a class="el" href="classompl_1_1base_1_1SpaceInformation.html#af911f59919a3044963cd0ae5c0e2627f" title="Check if a given state is valid or not. ">ompl::base::SpaceInformation::isValid</a> method. There are some pre-defined derived <a class="el" href="classompl_1_1base_1_1ValidStateSampler.html" title="Abstract definition of a state sampler. ">ompl::base::ValidStateSampler</a> classes:</p>
<ul>
<li><a class="el" href="classompl_1_1base_1_1UniformValidStateSampler.html" title="A state sampler that only samples valid states, uniformly. ">ompl::base::UniformValidStateSampler</a>: This is the default sampler. It simply calls the state space sampler to generate uniform samples until a valid state is found or a maximum number of iterations is exceeded.</li>
<li><a class="el" href="classompl_1_1base_1_1ObstacleBasedValidStateSampler.html" title="Generate valid samples using obstacle based sampling. First sample an invalid state, then sample a valid state. Then, interpolate from the invalid state to the valid state, returning the first valid state encountered. ">ompl::base::ObstacleBasedValidStateSampler</a>: This sampler tries to first find one invalid sample and one valid sample. Next, it interpolates states incrementally from the valid to the invalid state. It returns the last state that is valid before reaching an invalid state. The idea is that samples near obstacles improve the chance of finding samples in narrow passages. Finding such samples is often the crucial problem in solving motion planning queries.</li>
<li><a class="el" href="classompl_1_1base_1_1GaussianValidStateSampler.html" title="Generate valid samples using the Gaussian sampling strategy. ">ompl::base::GaussianValidStateSampler</a>: This sampler tries to accomplish something similar to the previous one, but in a different way. It repeatedly generates pairs of of states. The first one is uniformly random, while the second one is sampled according to a Gaussian distribution centered around the first sample. If one sample is valid and the other one invalid, the valid one is returned. If both are valid or invalid, it generates a new pair. This process repeats until a maximum number of iterations is exceeded.</li>
<li><a class="el" href="classompl_1_1base_1_1MaximizeClearanceValidStateSampler.html" title="Generate valid samples randomly, but with a bias towards higher clearance. ">ompl::base::MaximizeClearanceValidStateSampler</a>: This sampler behaves a lot like <a class="el" href="classompl_1_1base_1_1UniformValidStateSampler.html" title="A state sampler that only samples valid states, uniformly. ">ompl::base::UniformValidStateSampler</a> but once it finds a valid state, it attempts to find additional valid states with higher clearance. The reported sample is the one with highest clearance.</li>
</ul>
<p>Below we will describe how you can specify a planner to use one of these samplers and how to write your own valid state sampler. The code examples are taken from the <a href="StateSampling_8cpp_source.html">StateSampling.cpp</a> demo program (note that there is also a <a href="StateSampling_8py_source.html">Python version</a> of this demo).</p>
<h1>Using an Existing Sampler</h1>
<p>We cannot set the type of sampler directly in the SimpleSetup or SpaceInformation classes, because each thread needs it own copy of a sampler. Instead, we need to define a <a class="el" href="namespaceompl_1_1base.html#a85c4b4a409c1eac0b865577ff375e1ca" title="Definition of a function that can allocate a valid state sampler. ">ompl::base::ValidStateSamplerAllocator</a>, a function that, given a pointer to an <a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">ompl::base::SpaceInformation</a>, returns <a class="el" href="classompl_1_1base_1_1ValidStateSamplerPtr.html" title="A shared pointer wrapper for ompl::base::ValidStateSampler. ">ompl::base::ValidStateSamplerPtr</a>. This function can also configure the valid state sampler according to the specific space information before returning it. The following simple example shows how to use the ObstacleBasedValidStateSampler:</p>
 <div class="fragment"><div class="line">namespace ob = ompl::base;</div><div class="line">namespace og = ompl::geometric;</div><div class="line">ob::ValidStateSamplerPtr allocOBValidStateSampler(const ob::SpaceInformation *si)</div><div class="line">{</div><div class="line">    // we can perform any additional setup / configuration of a sampler here,</div><div class="line">    // but there is nothing to tweak in case of the ObstacleBasedValidStateSampler.</div><div class="line">    return std::make_shared&lt;ob::ObstacleBasedValidStateSampler&gt;(si);</div><div class="line">}</div></div><!-- fragment --> Other setup steps, such as specifying start and goal states, have been omitted for the sake of clarity.</p>
<h1>Creating a New Valid State Sampler</h1>
<p>A wide variety of heuristics have been proposed to improve the sampling of states. The quality of a sample can be characterized, e.g., by its distance to the nearest obstacle or by the “visibility” from a state. There are also two common cases where problem-specific information can be exploited:</p>
<ul>
<li>If you use a collision checker that returns the distance to the closest obstacle or—even better—returns also the gradient of the distance function, then it would make sense to create a new valid state sampler that can exploit this information.</li>
<li>If you can directly incorporate state validity constraints into the sampling (rather than use the rejection sampling scheme of the standard valid state samplers), then this will help boost performance. We will give an example of such sampler below.</li>
</ul>
<p>In the code below we are planning for a 3D point moving around inside a cube centered at the origin. There is one rectangular obstacle. Since the valid region is easy to describe, we can sample directly from the free space.</p>
 <div class="fragment"><div class="line">namespace ob = ompl::base;</div><div class="line">namespace og = ompl::geometric;</div><div class="line"></div><div class="line">/// @cond IGNORE</div><div class="line"></div><div class="line"></div><div class="line">// This is a problem-specific sampler that automatically generates valid</div><div class="line">// states; it doesn&#39;t need to call SpaceInformation::isValid. This is an</div><div class="line">// example of constrained sampling. If you can explicitly describe the set valid</div><div class="line">// states and can draw samples from it, then this is typically much more</div><div class="line">// efficient than generating random samples from the entire state space and</div><div class="line">// checking for validity.</div><div class="line">class MyValidStateSampler : public ob::ValidStateSampler</div><div class="line">{</div><div class="line">public:</div><div class="line">    MyValidStateSampler(const ob::SpaceInformation *si) : ValidStateSampler(si)</div><div class="line">    {</div><div class="line">        name_ = &quot;my sampler&quot;;</div><div class="line">    }</div><div class="line">    // Generate a sample in the valid part of the R^3 state space</div><div class="line">    // Valid states satisfy the following constraints:</div><div class="line">    // -1&lt;= x,y,z &lt;=1</div><div class="line">    // if .25 &lt;= z &lt;= .5, then |x|&gt;.8 and |y|&gt;.8</div><div class="line">    bool sample(ob::State *state) override</div><div class="line">    {</div><div class="line">        double* val = static_cast&lt;ob::RealVectorStateSpace::StateType*&gt;(state)-&gt;values;</div><div class="line">        double z = rng_.uniformReal(-1,1);</div><div class="line"></div><div class="line">        if (z&gt;.25 &amp;&amp; z&lt;.5)</div><div class="line">        {</div><div class="line">            double x = rng_.uniformReal(0,1.8), y = rng_.uniformReal(0,.2);</div><div class="line">            switch(rng_.uniformInt(0,3))</div><div class="line">            {</div><div class="line">                case 0: val[0]=x-1;  val[1]=y-1;  break;</div><div class="line">                case 1: val[0]=x-.8; val[1]=y+.8; break;</div><div class="line">                case 2: val[0]=y-1;  val[1]=x-1;  break;</div><div class="line">                case 3: val[0]=y+.8; val[1]=x-.8; break;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        else</div><div class="line">        {</div><div class="line">            val[0] = rng_.uniformReal(-1,1);</div><div class="line">            val[1] = rng_.uniformReal(-1,1);</div><div class="line">        }</div><div class="line">        val[2] = z;</div><div class="line">        assert(si_-&gt;isValid(state));</div><div class="line">        return true;</div><div class="line">    }</div><div class="line">    // We don&#39;t need this in the example below.</div><div class="line">    bool sampleNear(ob::State* /*state*/, const ob::State* /*near*/, const double /*distance*/) override</div><div class="line">    {</div><div class="line">        throw ompl::Exception(&quot;MyValidStateSampler::sampleNear&quot;, &quot;not implemented&quot;);</div><div class="line">        return false;</div><div class="line">    }</div><div class="line">protected:</div><div class="line">    ompl::RNG rng_;</div><div class="line">};</div></div><!-- fragment --> We define a valid state allocator similarly as describe above: <div class="fragment"><div class="line">ob::ValidStateSamplerPtr allocMyValidStateSampler(const ob::SpaceInformation *si)</div><div class="line">{</div><div class="line">    return std::make_shared&lt;MyValidStateSampler&gt;(si);</div><div class="line">}</div></div><!-- fragment --> Finally, using the new sampler is done analogously as before: <div class="fragment"><div class="line">        ss.getSpaceInformation()-&gt;setValidStateSamplerAllocator(allocMyValidStateSampler);</div></div><!-- fragment --> </p>
</div></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Kavraki Lab</a>  &bull;
    <a href="https://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="https://www.rice.edu">Rice University</a><br/>
    Funded in part by the <a href="https://www.nsf.gov">National Science Foundation</a><br/>
    Documentation generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</body>
</html>
